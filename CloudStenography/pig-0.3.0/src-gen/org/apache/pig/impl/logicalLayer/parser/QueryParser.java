/* Generated By:JJTree&JavaCC: Do not edit this line. QueryParser.java */
package org.apache.pig.impl.logicalLayer.parser;
import java.io.*;
import java.util.*;
import java.net.URI;
import java.net.URISyntaxException;
import java.lang.reflect.Type;
import org.apache.pig.impl.logicalLayer.*;
import org.apache.pig.impl.logicalLayer.schema.*;
import org.apache.pig.data.DataType;
import org.apache.pig.impl.PigContext;
import org.apache.pig.ExecType;
import org.apache.pig.impl.io.*;
import org.apache.pig.builtin.PigStorage;
import org.apache.pig.builtin.RANDOM;
import org.apache.pig.impl.builtin.GFAny;
import org.apache.pig.impl.logicalLayer.LogicalPlan;
import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.pig.impl.util.MultiMap;
import org.apache.pig.impl.plan.NodeIdGenerator;
import org.apache.pig.impl.plan.OperatorKey;
import org.apache.pig.impl.plan.PlanException;
import org.apache.pig.impl.streaming.StreamingCommand;
import org.apache.pig.impl.streaming.StreamingCommand.HandleSpec;
import org.apache.pig.data.TupleFactory;
import org.apache.pig.data.Tuple;
import org.apache.pig.data.BagFactory;
import org.apache.pig.data.DataBag;
import org.apache.pig.EvalFunc;
import org.apache.pig.ComparisonFunc;
import org.apache.pig.LoadFunc;
import org.apache.pig.StoreFunc;
import org.apache.pig.FuncSpec;
import org.apache.pig.impl.plan.VisitorException;
import org.apache.pig.PigException;
import org.apache.pig.backend.datastorage.DataStorage;
import org.apache.pig.backend.datastorage.ContainerDescriptor;
import org.apache.pig.backend.datastorage.ElementDescriptor;
import org.apache.hadoop.fs.Path;

public class QueryParser/*@bgen(jjtree)*/implements QueryParserTreeConstants, QueryParserConstants {/*@bgen(jjtree)*/
  protected JJTQueryParserState jjtree = new JJTQueryParserState();private PigContext pigContext;
        private Map<LogicalOperator, LogicalPlan> aliases;
        private Map<OperatorKey, LogicalOperator> opTable;
        private String scope;
        private NodeIdGenerator nodeIdGen;
        //a map of alias to logical operator for a quick lookup
        private Map<String, LogicalOperator> mapAliasOp;
        private static Log log = LogFactory.getLog(QueryParser.class);
        private boolean bracketed = false;
        private Map<String, String> fileNameMap;

        private long getNextId() {
                return nodeIdGen.getNextNodeId(scope);
        }

        public QueryParser(InputStream in,
                                           PigContext pigContext,
                                           String scope,
                                           Map<LogicalOperator, LogicalPlan> aliases,
                                           Map<OperatorKey, LogicalOperator> opTable,
                                           Map<String, LogicalOperator> aliasOp,
                                           Map<String, String> fileNameMap) {
                this(in);
                this.pigContext = pigContext;
                this.aliases = aliases;
                this.opTable = opTable;
                this.scope = scope;
                this.nodeIdGen = NodeIdGenerator.getGenerator();
                this.mapAliasOp = aliasOp;
                this.fileNameMap = fileNameMap;
        }

    public QueryParser(InputStream in,
            PigContext pigContext,
            String scope,
            Map<LogicalOperator, LogicalPlan> aliases,
            Map<OperatorKey, LogicalOperator> opTable,
            Map<String, LogicalOperator> aliasOp,
            int start,
            Map<String, String> fileNameMap) {
        this(in, pigContext, scope, aliases, opTable, aliasOp, fileNameMap);
        token_source.input_stream.line = start;
    }

        public class CogroupInput {
                public LogicalOperator op;
                public ArrayList<LogicalPlan> plans;
                public boolean isInner;
        }

    private static String removeQuotes(String str) {
        if (str.startsWith("\u005c'") && str.endsWith("\u005c'"))
            return str.substring(1, str.length() - 1);
        else
            return str;
    }

    public static LogicalPlan generateStorePlan(String scope,
                                                LogicalPlan readFrom,
                                                String fileName,
                                                String func,
                                                LogicalOperator input) throws FrontendException {

        if (func == null) {
            func = PigStorage.class.getName();
        }

        fileName = removeQuotes(fileName);

        long storeNodeId = NodeIdGenerator.getGenerator().getNextNodeId(scope);

        LogicalPlan storePlan = new LogicalPlan();

        LogicalOperator store;
        try {
                store = new LOStore(storePlan,
                                                           new OperatorKey(scope, storeNodeId),
                               new FileSpec(fileName, new FuncSpec(func)));
        } catch (IOException ioe) {
            throw new FrontendException(ioe.getMessage(), ioe);
        }

        try {
                storePlan.add(store);
                storePlan.add(input);
                storePlan.connect(input, store);
                attachPlan(storePlan, input, readFrom, new HashMap<LogicalOperator, Boolean>());
        } catch (ParseException pe) {
            throw new FrontendException(pe.getMessage(), pe);
        }

        if (storePlan.getRoots().size() == 0) throw new RuntimeException("Store plan has no roots!");
        return storePlan;
    }

    static String unquote(String s) {
                return StringUtils.unescapeInputString(s.substring(1, s.length()-1)) ;
        }

        static int undollar(String s) {
                return Integer.parseInt(s.substring(1, s.length()));
        }


    String massageFilename(String filename, PigContext pigContext, boolean isLoad) throws IOException, ParseException {

        // If multiquery is off we revert to the old behavior, which
        // did not try to convert paths to their absolute location.
        boolean isMultiQuery = "true".equalsIgnoreCase(pigContext.getProperties().getProperty("opt.multiquery","true"));
        if (!isMultiQuery) {
            if (!isLoad) { // stores do not require any change
                return filename;
            }

            // Local loads in the hadoop context require copying the
            // file to dfs first.
            if (pigContext.getExecType() != ExecType.LOCAL
                && filename.startsWith(FileLocalizer.LOCAL_PREFIX)) {
                    filename = FileLocalizer.hadoopify(filename, pigContext);
            }
            return filename;
        }

        String fname;

        // If we converted the file name before, we return the old
        // result. This is not done for performance but to make sure
        // we return the same result for relative paths when
        // re-parsing the same script for execution.
        if (null != (fname = fileNameMap.get(filename))) {
            return fname;
        } else {
            fname = filename;
        }

        String scheme, path;

        if (fname.startsWith(FileLocalizer.LOCAL_PREFIX)) {
            // We don't use hadoop path class to do the parsing,
            // because our syntax of saying 'file:foo' for relative
            // paths on the local FS is not a valid URL.
            scheme = "file";
            path = fname.substring(FileLocalizer.LOCAL_PREFIX.length());
        } else {
            // Path implements a custom uri parsing that takes care of
            // unescaped characters (think globs). Using "new
            // URI(fname)" would break.
            URI uri = new Path(fname).toUri();

            scheme = uri.getScheme();
            if (scheme != null) {
                scheme = scheme.toLowerCase();
            }

            path = uri.getPath();
        }

        if (scheme == null || scheme.equals("file") || scheme.equals("hdfs")) {
            if (pigContext.getExecType() != ExecType.LOCAL) {
                if (fname.startsWith(FileLocalizer.LOCAL_PREFIX)) {
                    if (isLoad) {
                        fname = FileLocalizer.hadoopify(fname, pigContext);
                    }
                    return fname;
                }
            }
            DataStorage dfs = pigContext.getDfs();
            ContainerDescriptor desc = dfs.getActiveContainer();
            ElementDescriptor el = dfs.asElement(desc, path);
            fname = el.toString();
        }

        if (!fname.equals(filename)) {
            fileNameMap.put(filename, fname);
        }
        return fname;
    }

        LogicalOperator parseCogroup(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{

                log.trace("Entering parseCogroup");
                log.debug("LogicalPlan: " + lp);

                int n = gis.size();
                log.debug("Number of cogroup inputs = " + n);

                ArrayList<LogicalOperator> los = new ArrayList<LogicalOperator>();
                ArrayList<ArrayList<LogicalPlan>> plans = new ArrayList<ArrayList<LogicalPlan>>();
                MultiMap<LogicalOperator, LogicalPlan> groupByPlans = new MultiMap<LogicalOperator, LogicalPlan>();
                //Map<LogicalOperator, LogicalPlan> groupByPlans = new HashMap<LogicalOperator, LogicalPlan>();
                boolean[] isInner = new boolean[n];

                int arity = gis.get(0).plans.size();

                for (int i = 0; i < n ; i++){

                        CogroupInput gi = gis.get(i);
                        los.add(gi.op);
                        ArrayList<LogicalPlan> planList = gi.plans;
                        plans.add(gi.plans);
                        int numGrpByOps = planList.size();
                        log.debug("Number of group by operators = " + numGrpByOps);

                        if(arity != numGrpByOps) {
                                throw new ParseException("The arity of the group by columns do not match.");
                        }
                        for(int j = 0; j < numGrpByOps; ++j) {
                            groupByPlans.put(gi.op, planList.get(j));
                                for(LogicalOperator root: planList.get(j).getRoots()) {
                                        log.debug("Cogroup input plan root: " + root);
                                }
                        }
                        isInner[i] = gi.isInner;
                }

                LogicalOperator cogroup = new LOCogroup(lp, new OperatorKey(scope, getNextId()), groupByPlans, isInner);
                lp.add(cogroup);
                log.debug("Added operator " + cogroup.getClass().getName() + " object " + cogroup + " to the logical plan " + lp);

                for(LogicalOperator op: los) {
                        lp.connect(op, cogroup);
                        log.debug("Connected operator " + op.getClass().getName() + " to " + cogroup.getClass().getName() + " in the logical plan");
                }

                log.trace("Exiting parseCogroup");
                return cogroup;
        }

        /**
	 * Mimicing parseCogroup as the parsing logic for FRJoin remains exactly the same.
	 */
        LogicalOperator parseFRJoin(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{

                log.trace("Entering parseCogroup");
                log.debug("LogicalPlan: " + lp);

                int n = gis.size();
                log.debug("Number of cogroup inputs = " + n);

                ArrayList<LogicalOperator> los = new ArrayList<LogicalOperator>();
                ArrayList<ArrayList<LogicalPlan>> plans = new ArrayList<ArrayList<LogicalPlan>>();
                MultiMap<LogicalOperator, LogicalPlan> groupByPlans = new MultiMap<LogicalOperator, LogicalPlan>();
                //Map<LogicalOperator, LogicalPlan> groupByPlans = new HashMap<LogicalOperator, LogicalPlan>();
                boolean[] isInner = new boolean[n];

                int arity = gis.get(0).plans.size();

                for (int i = 0; i < n ; i++){

                        CogroupInput gi = gis.get(i);
                        los.add(gi.op);
                        ArrayList<LogicalPlan> planList = gi.plans;
                        plans.add(gi.plans);
                        int numGrpByOps = planList.size();
                        log.debug("Number of group by operators = " + numGrpByOps);

                        if(arity != numGrpByOps) {
                                throw new ParseException("The arity of the group by columns do not match.");
                        }
                        for(int j = 0; j < numGrpByOps; ++j) {
                            groupByPlans.put(gi.op, planList.get(j));
                                for(LogicalOperator root: planList.get(j).getRoots()) {
                                        log.debug("Cogroup input plan root: " + root);
                                }
                        }
                        isInner[i] = gi.isInner;
                }

                LogicalOperator frj = new LOFRJoin(lp, new OperatorKey(scope, getNextId()), groupByPlans, isInner, gis.get(0).op);
                lp.add(frj);
                log.debug("Added operator " + frj.getClass().getName() + " object " + frj + " to the logical plan " + lp);

                for(LogicalOperator op: los) {
                        lp.connect(op, frj);
                        log.debug("Connected operator " + op.getClass().getName() + " to " + frj.getClass().getName() + " in the logical plan");
                }

                log.trace("Exiting parseFRJoin");
                return frj;
        }

        /**
	 * The join operator is translated to foreach 
	 */
        LogicalOperator rewriteJoin(ArrayList<CogroupInput> gis, LogicalPlan lp) throws ParseException, PlanException{

                log.trace("Entering rewriteJoin");
                log.debug("LogicalPlan: " + lp);
                int n = gis.size();
                ArrayList<ExpressionOperator> flattenedColumns = new ArrayList<ExpressionOperator>();
                ArrayList<LogicalPlan> generatePlans = new ArrayList<LogicalPlan>();
                ArrayList<Boolean> flattenList = new ArrayList<Boolean>();

                /*
		 * Construct the projection operators required for the generate
		 * Make sure that the operators are flattened
		 */



                //Construct the cogroup operator and add it to the logical plan
        // for join, inner is true for all the inputs involved in the join
        for (int i = 0; i < n; i++) {
                        (gis.get(i)).isInner = true;
        }
                LogicalOperator cogroup = parseCogroup(gis, lp);
                lp.add(cogroup);
                log.debug("Added operator " + cogroup.getClass().getName() + " to the logical plan");

                for (int i = 0; i < n; i++) {
                        LogicalPlan projectPlan = new LogicalPlan();
                        LogicalOperator projectInput = cogroup;
                        ExpressionOperator column = new LOProject(projectPlan, new OperatorKey(scope, getNextId()), projectInput, i+1);
                        flattenList.add(true);
                        flattenedColumns.add(column);
                        projectPlan.add(column);
            if(projectInput instanceof ExpressionOperator) {
                            projectPlan.add(projectInput);
                            projectPlan.connect(projectInput, column);
            }
                        log.debug("parseCogroup: Added operator " + column.getClass().getName() + " " + column + " to logical plan " + projectPlan);
                        generatePlans.add(projectPlan);
                }



                /*
		 * Construct the foreach operator from the foreach logical plan
		 * Add the foreach operator to the top level logical plan
		 */
                LogicalOperator foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), generatePlans, flattenList);
                lp.add(foreach);
                log.debug("Added operator " + foreach.getClass().getName() + " to the logical plan");
                lp.connect(cogroup, foreach);
                log.debug("Connected operator " + cogroup.getClass().getName() + " to opeator " + foreach.getClass().getName() + " in the logical plan " + lp);

                log.trace("Exiting rewriteJoin");
                return foreach;
        }

        void assertAtomic(LogicalOperator spec, boolean desiredAtomic) throws ParseException{
                Boolean isAtomic = null;
                if ( spec instanceof LOConst ||
                        (spec instanceof LOUserFunc &&
                DataType.isAtomic(((LOUserFunc)spec).getType())))
                        isAtomic = true;
                else if (spec instanceof LOUserFunc)
                        isAtomic = false;

                if (isAtomic != null && isAtomic != desiredAtomic){
                        if (desiredAtomic)
                                throw new ParseException("Atomic field expected but found non-atomic field");
                        else
                                throw new ParseException("Non-atomic field expected but found atomic field");
                }
        }

         void addSplitOutput(LogicalPlan lp, LOSplit splitOp, String alias, LogicalPlan condPlan, int index) throws PlanException{
                LogicalOperator splitOutput = new LOSplitOutput(lp, new OperatorKey(scope, getNextId()), index, condPlan);
                splitOp.addOutput(splitOutput);
                addAlias(alias, splitOutput);
        splitOutput.setAlias(alias);
        addLogicalPlan(splitOutput, lp);

                lp.add(splitOutput);
                log.debug("Added alias: " + splitOutput.getAlias() + " class: "
                        + splitOutput.getClass().getName() + " to the logical plan");

                lp.connect(splitOp, splitOutput);
                log.debug("Connected " + splitOp.getClass().getName() + " to class: "
                        + splitOutput.getClass().getName() + " in the logical plan");

         }

         void addAlias(String alias, LogicalOperator lOp) {
                mapAliasOp.put(alias, lOp);
         }

         LogicalOperator getOp(String alias) {
                return mapAliasOp.get(alias);
         }

     // Check and set files to be automatically shipped for the given StreamingCommand
     // Auto-shipping rules:
     // 1. If the command begins with either perl or python assume that the 
     //    binary is the first non-quoted string it encounters that does not 
     //    start with dash - subject to restrictions in (2).
     // 2. Otherwise, attempt to ship the first string from the command line as 
     //    long as it does not come from /bin, /user/bin, /user/local/bin. 
     //    It will determine that by scanning the path if an absolute path is 
     //    provided or by executing "which". The paths can be made configurable 
     //    via "set stream.skippath <paths>" option.
     private static final String PERL = "perl";
     private static final String PYTHON = "python";
     private void checkAutoShipSpecs(StreamingCommand command, String[] argv)
     throws ParseException {
        // Candidate for auto-ship
        String arg0 = argv[0];

        // Check if command is perl or python ... if so use the first non-option
        // and non-quoted string as the candidate
        if (arg0.equalsIgnoreCase(PERL) || arg0.equalsIgnoreCase(PYTHON)) {
            for (int i=1; i < argv.length; ++i) {
                if (!argv[i].startsWith("-") && !isQuotedString(argv[i])) {
                        checkAndShip(command, argv[i]);
                        break;
                }
            }
        } else {
                // Ship the first argument if it can be ...
                checkAndShip(command, arg0);
        }
     }

     private void checkAndShip(StreamingCommand command, String arg)
     throws ParseException {
        // Don't auto-ship if it is an absolute path...
        if (arg.startsWith("/")) {
                return;
        }

        // $ which arg
        String argPath = which(arg);
        if (argPath != null && !inSkipPaths(argPath)) {
                try {
                    command.addPathToShip(argPath);
                } catch(IOException e) {
                ParseException pe = new ParseException(e.getMessage());
                pe.initCause(e);
                throw pe;
            }
        }

     }

     private boolean isQuotedString(String s) {
        return (s.charAt(0) == '\u005c'' && s.charAt(s.length()-1) == '\u005c'');
     }

     // Check if file is in the list paths to be skipped 
     private boolean inSkipPaths(String file) {
        for (String skipPath : pigContext.getPathsToSkip()) {
                if (file.startsWith(skipPath)) {
                        return true;
                }
        }
        return false;
     }


     private static String which(String file) {
        try {
                ProcessBuilder processBuilder =
                    new ProcessBuilder(new String[] {"which", file});
            Process process = processBuilder.start();

            BufferedReader stdout =
                new BufferedReader(new InputStreamReader(process.getInputStream()));
            String fullPath = stdout.readLine();

            return (process.waitFor() == 0) ? fullPath : null;
        } catch (Exception e) {}
        return null;
     }

     private static final char SINGLE_QUOTE = '\u005c'';
     private static final char DOUBLE_QUOTE = '"';
     private static String[] splitArgs(String command) throws ParseException {
        List<String> argv = new ArrayList<String>();

        int beginIndex = 0;

        while (beginIndex < command.length()) {
            // Skip spaces
            while (Character.isWhitespace(command.charAt(beginIndex))) {
                ++beginIndex;
            }

            char delim = ' ';
            char charAtIndex = command.charAt(beginIndex);
            if (charAtIndex == SINGLE_QUOTE || charAtIndex == DOUBLE_QUOTE) {
                delim = charAtIndex;
            }

            int endIndex = command.indexOf(delim, beginIndex+1);
            if (endIndex == -1) {
                if (Character.isWhitespace(delim)) {
                    // Reached end of command-line
                    argv.add(command.substring(beginIndex));
                    break;
                } else {
                    // Didn't find the ending quote/double-quote
                    throw new ParseException("Illegal command: " + command);
                }
            }

            if (Character.isWhitespace(delim)) {
                // Do not consume the space
                argv.add(command.substring(beginIndex, endIndex));
            } else {
                argv.add(command.substring(beginIndex, endIndex+1));
            }

            beginIndex = endIndex + 1;
        }

        return argv.toArray(new String[argv.size()]);
    }

         //BEGIN
         //I am maintaining state about the operators that should
         //serve as the inputs to generate in the foreach logical
         //plan. I did not want to pass this structure around for
         //the entire parse tree

         private boolean insideGenerate = false; //to check if we are parsing inside a generate statement
         private List<LogicalOperator> generateInputs = new ArrayList<LogicalOperator>();

        boolean insideGenerate() {
                return insideGenerate;
        }

        void setInsideGenerate(boolean b) {
                insideGenerate = b;
        }

        List<LogicalOperator> getGenerateInputs() {
                return generateInputs;
        }

        void resetGenerateInputs() {
                generateInputs.clear();
        }

        void addGenerateInput(LogicalOperator op) {
                generateInputs.add(op);
        }

        void resetGenerateState() {
                insideGenerate = false;
                resetGenerateInputs();
        }

    boolean checkGenerateInput(LogicalOperator in) {
        if(null == generateInputs) return false;
        for(LogicalOperator op: generateInputs) {
            if(op == in) return true;
        }
        return false;
    }

         //END

        private static Map<String, Byte> nameToTypeMap = DataType.genNameToTypeMap();

    public void addLogicalPlan(LogicalOperator op, LogicalPlan plan) {
        aliases.put(op, plan);
    }

    public LogicalPlan getLogicalPlan(LogicalOperator op) {
        return aliases.get(op);
    }

    public static void attachPlan(LogicalPlan lp, LogicalOperator root, LogicalPlan rootPlan, Map<LogicalOperator, Boolean> rootProcessed) throws ParseException {
        log.trace("Entering attachPlan");
        if(null == rootProcessed) {
            rootProcessed = new HashMap<LogicalOperator, Boolean>();
        }
        if((rootProcessed.get(root) != null) && (rootProcessed.get(root))) {
            log.trace("Root has been processed");
            log.trace("Exiting attachPlan");
            return;
        }
        lp.add(root);
        log.debug("Added operator " + root + " to the logical plan " + lp);
        if(null == rootPlan.getPredecessors(root)) {
            log.trace("Exiting attachPlan");
            return;
        }
        for(LogicalOperator rootPred: rootPlan.getPredecessors(root)) {
            attachPlan(lp, rootPred, rootPlan, rootProcessed);
            rootProcessed.put(rootPred, true);
            try {
                lp.connect(rootPred, root);
                log.debug("Connected operator " + rootPred + " to " + root + " in the logical plan " + lp);
            } catch (FrontendException fee) {
                ParseException pe = new ParseException(fee.getMessage());
                pe.initCause(fee);
                throw pe;
            }
        }
        log.trace("Exiting attachPlan");
    }

// Parse is the Starting function.
  final public LogicalPlan Parse() throws ParseException {
 /*@bgen(jjtree) Parse */
        SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator root = null;
        Token t1;
        Token t2;
        LogicalPlan lp = new LogicalPlan();
        log.trace("Entering Parse");
    try {
      if (jj_2_1(3)) {
        t1 = jj_consume_token(IDENTIFIER);
        jj_consume_token(79);
        t2 = jj_consume_token(IDENTIFIER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          jj_consume_token(80);
          TupleSchema();
          jj_consume_token(81);
          break;
        default:
          jj_la1[0] = jj_gen;
          ;
        }
        jj_consume_token(82);
                        {if (true) throw new ParseException(
                        "Currently PIG does not support assigning an existing relation (" + t1.image + ") to another alias (" + t2.image + ")");}
      } else if (jj_2_2(2)) {
        t1 = jj_consume_token(IDENTIFIER);
        jj_consume_token(79);
        root = Expr(lp);
        jj_consume_token(82);
          root.setAlias(t1.image);
          addAlias(t1.image, root);
          pigContext.setLastAlias(t1.image);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DEFINE:
        case LOAD:
        case FILTER:
        case FOREACH:
        case ORDER:
        case DISTINCT:
        case COGROUP:
        case JOIN:
        case CROSS:
        case UNION:
        case GROUP:
        case STREAM:
        case STORE:
        case LIMIT:
        case SAMPLE:
        case IDENTIFIER:
        case 80:
          root = Expr(lp);
          jj_consume_token(82);
          break;
        case SPLIT:
          jj_consume_token(SPLIT);
          root = SplitClause(lp);
          jj_consume_token(82);
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(null != root) {
            log.debug("Adding " + root.getAlias() + " " + root + " to the lookup table " + aliases);

            //Translate all the project(*) leaves in the plan to a sequence of projections
            ProjectStarTranslator translate = new ProjectStarTranslator(lp);
            translate.visit();

            addLogicalPlan(root, lp);

            try {
                            log.debug("Root: " + root.getClass().getName() + " schema: " + root.getSchema());
            } catch(FrontendException fee) {
                ParseException pe = new ParseException(fee.getMessage());
                pe.initCause(fee);
                {if (true) throw pe;}
            }
                }

        ArrayList<LogicalOperator> roots = new ArrayList<LogicalOperator>(lp.getRoots().size());
        for(LogicalOperator op: lp.getRoots()) {
            roots.add(op);
        }

        Map<LogicalOperator, Boolean> rootProcessed = new HashMap<LogicalOperator, Boolean>();
        for(LogicalOperator op: roots) {
            //At this point we have a logical plan for the pig statement
            //In order to construct the entire logical plan we need to traverse
            //each root and get the logical plan it belongs to. From each of those
            //plans we need the predecessors of the root of the current logical plan
            //and so on. This is a computationally intensive operatton but should
            //be fine as its restricted to the parser

            LogicalPlan rootPlan = aliases.get(op);
            if(null != rootPlan) {
                attachPlan(lp, op, rootPlan, rootProcessed);
                rootProcessed.put(op, true);
            }
        }

                log.trace("Exiting Parse");
                {if (true) return lp;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator SplitClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) SplitClause */
        SimpleNode jjtn000 = new SimpleNode(JJTSPLITCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator input;
        ExpressionOperator cond;
        Token alias;
        LOSplit splitOp;
        int index = 0;
        LogicalPlan condPlan;
        log.trace("Entering SplitClause");
    try {
      input = NestedExpr(lp);
      jj_consume_token(INTO);
                splitOp = new LOSplit(lp, input.getOperatorKey(), new ArrayList<LogicalOperator>());
                lp.add(splitOp);
                log.debug("Adding operator " + splitOp.getClass().getName() + " to the logical plan");
        lp.connect(input, splitOp);
                log.debug("Connected alias: " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + splitOp.getClass().getName());
      alias = jj_consume_token(IDENTIFIER);
      jj_consume_token(IF);
      cond = PCond(input.getSchema(), null, condPlan = new LogicalPlan(), input);
                addSplitOutput(lp, splitOp, alias.image, condPlan, index);
                ++index;
                log.debug("Added splitoutput");
      label_1:
      while (true) {
        jj_consume_token(83);
        alias = jj_consume_token(IDENTIFIER);
        jj_consume_token(IF);
        cond = PCond(input.getSchema(), null, condPlan = new LogicalPlan(), input);
                addSplitOutput(lp, splitOp, alias.image, condPlan, index);
                ++index;
                log.debug("Added splitoutput");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[2] = jj_gen;
          break label_1;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting SplitClause"); {if (true) return splitOp;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator Expr(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) Expr */
        SimpleNode jjtn000 = new SimpleNode(JJTEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        Schema schema = null;
        log.trace("Entering Expr");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case 80:
        op = NestedExpr(lp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          jj_consume_token(80);
          schema = TupleSchema();
          jj_consume_token(81);
                                                                     Schema.setSchemaDefaultType(schema, DataType.BYTEARRAY); op.setSchema(schema);
          break;
        default:
          jj_la1[3] = jj_gen;
          ;
        }
        break;
      case DEFINE:
      case LOAD:
      case FILTER:
      case FOREACH:
      case ORDER:
      case DISTINCT:
      case COGROUP:
      case JOIN:
      case CROSS:
      case UNION:
      case GROUP:
      case STREAM:
      case STORE:
      case LIMIT:
      case SAMPLE:
        op = BaseExpr(lp);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting Expr"); {if (true) return op;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator NestedExpr(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) NestedExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        ExpressionOperator eOp;
        Map<String, LogicalOperator> specs = null;
        log.trace("Entering NestedExpr");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        op = Alias(lp);
        break;
      default:
        jj_la1[5] = jj_gen;
        if (jj_2_3(2)) {
          jj_consume_token(80);
          op = NestedExpr(lp);
          jj_consume_token(81);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 80:
            jj_consume_token(80);
            op = BaseExpr(lp);
            jj_consume_token(81);
            break;
          default:
            jj_la1[6] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting NestedExpr"); {if (true) return op;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// A keyword or an identifier
  final public Token IdentifierOrReserved() throws ParseException {
 /*@bgen(jjtree) IdentifierOrReserved */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIERORRESERVED);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t1;
  log.trace("Entering IdentifierOrReserved");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFINE:
        t1 = jj_consume_token(DEFINE);
        break;
      case LOAD:
        t1 = jj_consume_token(LOAD);
        break;
      case FILTER:
        t1 = jj_consume_token(FILTER);
        break;
      case FOREACH:
        t1 = jj_consume_token(FOREACH);
        break;
      case MATCHES:
        t1 = jj_consume_token(MATCHES);
        break;
      case ORDER:
        t1 = jj_consume_token(ORDER);
        break;
      case ARRANGE:
        t1 = jj_consume_token(ARRANGE);
        break;
      case DISTINCT:
        t1 = jj_consume_token(DISTINCT);
        break;
      case COGROUP:
        t1 = jj_consume_token(COGROUP);
        break;
      case JOIN:
        t1 = jj_consume_token(JOIN);
        break;
      case CROSS:
        t1 = jj_consume_token(CROSS);
        break;
      case UNION:
        t1 = jj_consume_token(UNION);
        break;
      case SPLIT:
        t1 = jj_consume_token(SPLIT);
        break;
      case INTO:
        t1 = jj_consume_token(INTO);
        break;
      case IF:
        t1 = jj_consume_token(IF);
        break;
      case ALL:
        t1 = jj_consume_token(ALL);
        break;
      case ANY:
        t1 = jj_consume_token(ANY);
        break;
      case AS:
        t1 = jj_consume_token(AS);
        break;
      case BY:
        t1 = jj_consume_token(BY);
        break;
      case USING:
        t1 = jj_consume_token(USING);
        break;
      case INNER:
        t1 = jj_consume_token(INNER);
        break;
      case OUTER:
        t1 = jj_consume_token(OUTER);
        break;
      case PARALLEL:
        t1 = jj_consume_token(PARALLEL);
        break;
      case GROUP:
        t1 = jj_consume_token(GROUP);
        break;
      case AND:
        t1 = jj_consume_token(AND);
        break;
      case OR:
        t1 = jj_consume_token(OR);
        break;
      case NOT:
        t1 = jj_consume_token(NOT);
        break;
      case GENERATE:
        t1 = jj_consume_token(GENERATE);
        break;
      case FLATTEN:
        t1 = jj_consume_token(FLATTEN);
        break;
      case EVAL:
        t1 = jj_consume_token(EVAL);
        break;
      case ASC:
        t1 = jj_consume_token(ASC);
        break;
      case DESC:
        t1 = jj_consume_token(DESC);
        break;
      case INT:
        t1 = jj_consume_token(INT);
        break;
      case LONG:
        t1 = jj_consume_token(LONG);
        break;
      case FLOAT:
        t1 = jj_consume_token(FLOAT);
        break;
      case DOUBLE:
        t1 = jj_consume_token(DOUBLE);
        break;
      case CHARARRAY:
        t1 = jj_consume_token(CHARARRAY);
        break;
      case BYTEARRAY:
        t1 = jj_consume_token(BYTEARRAY);
        break;
      case BAG:
        t1 = jj_consume_token(BAG);
        break;
      case TUPLE:
        t1 = jj_consume_token(TUPLE);
        break;
      case MAP:
        t1 = jj_consume_token(MAP);
        break;
      case IS:
        t1 = jj_consume_token(IS);
        break;
      case NULL:
        t1 = jj_consume_token(NULL);
        break;
      case STREAM:
        t1 = jj_consume_token(STREAM);
        break;
      case THROUGH:
        t1 = jj_consume_token(THROUGH);
        break;
      case STORE:
        t1 = jj_consume_token(STORE);
        break;
      case SHIP:
        t1 = jj_consume_token(SHIP);
        break;
      case CACHE:
        t1 = jj_consume_token(CACHE);
        break;
      case INPUT:
        t1 = jj_consume_token(INPUT);
        break;
      case OUTPUT:
        t1 = jj_consume_token(OUTPUT);
        break;
      case ERROR:
        t1 = jj_consume_token(ERROR);
        break;
      case STDIN:
        t1 = jj_consume_token(STDIN);
        break;
      case STDOUT:
        t1 = jj_consume_token(STDOUT);
        break;
      case LIMIT:
        t1 = jj_consume_token(LIMIT);
        break;
      case SAMPLE:
        t1 = jj_consume_token(SAMPLE);
        break;
      case IDENTIFIER:
        t1 = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return t1;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

// A reference to an alias
  final public LogicalOperator Alias(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) Alias */
        SimpleNode jjtn000 = new SimpleNode(JJTALIAS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        LogicalOperator op;
        log.trace("Entering Alias");
    try {
      t1 = jj_consume_token(IDENTIFIER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LogicalOperator aliasOp;
                String alias = t1.image;

                aliasOp = getOp(alias);
                if (aliasOp == null) {
                        {if (true) throw new ParseException("Unrecognized alias " + alias);}
                }
                addAlias(alias, aliasOp);
                log.debug("Added " + alias + " to aliasOp");

                lp.add(aliasOp);
                log.debug("Added operator: " + aliasOp.getClass().getName() + " to the logical plan " + lp);
                log.trace("Exiting Alias");
                {if (true) return aliasOp;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator BaseExpr(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) BaseExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTBASEEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        Schema schema;
        Token t1, t2;
        Schema.FieldSchema fs;
        log.trace("Entering BaseExpr");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFINE:
        jj_consume_token(DEFINE);
        op = DefineClause(lp);
        break;
      case LOAD:
        jj_consume_token(LOAD);
        op = LoadClause(lp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          if (jj_2_4(2)) {
            jj_consume_token(80);
            schema = TupleSchema();
            jj_consume_token(81);
                Schema.setSchemaDefaultType(schema, DataType.BYTEARRAY);
                op.setSchema(schema);
                log.debug("Load as schema" + schema);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              fs = AtomSchema();
                schema = new Schema(fs);
                op.setSchema(schema);
                log.debug("Load as atomschema" + schema);
              break;
            default:
              jj_la1[8] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[9] = jj_gen;
          ;
        }
        break;
      case COGROUP:
      case GROUP:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case GROUP:
          jj_consume_token(GROUP);
          break;
        case COGROUP:
          jj_consume_token(COGROUP);
          break;
        default:
          jj_la1[10] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        op = CogroupClause(lp);
        break;
      case FILTER:
        jj_consume_token(FILTER);
        op = FilterClause(lp);
        break;
      case LIMIT:
        jj_consume_token(LIMIT);
        op = LimitClause(lp);
        break;
      case SAMPLE:
        jj_consume_token(SAMPLE);
        op = SampleClause(lp);
        break;
      case ORDER:
        jj_consume_token(ORDER);
        op = OrderClause(lp);
        break;
      case DISTINCT:
        jj_consume_token(DISTINCT);
        op = NestedExpr(lp);
                LogicalOperator distinct = new LODistinct(lp, new OperatorKey(scope, getNextId()));
                lp.add(distinct);
                log.debug("Added operator: " + distinct.getClass().getName() + " to the logical plan");
                lp.connect(op, distinct);
                log.debug("Connected alias: " + op.getAlias() + " operator " + op.getClass().getName() + " to operator " + distinct.getClass().getName());
        op = distinct;
        break;
      case CROSS:
        jj_consume_token(CROSS);
        op = CrossClause(lp);
        break;
      case JOIN:
        jj_consume_token(JOIN);
        op = JoinClause(lp);
        break;
      case UNION:
        jj_consume_token(UNION);
        op = UnionClause(lp);
        break;
      case FOREACH:
        jj_consume_token(FOREACH);
        op = ForEachClause(lp);
        break;
      case STREAM:
        jj_consume_token(STREAM);
        op = StreamClause(lp);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          if (jj_2_5(2)) {
            jj_consume_token(80);
            schema = TupleSchema();
            jj_consume_token(81);
                Schema.setSchemaDefaultType(schema, DataType.BYTEARRAY);
                op.setSchema(schema);
                log.debug("Stream as schema()"+ schema);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case IDENTIFIER:
              fs = AtomSchema();
                schema = new Schema(fs);
                op.setSchema(schema);
                log.debug("Stream as atomschema()" + schema);
              break;
            default:
              jj_la1[11] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          break;
        default:
          jj_la1[12] = jj_gen;
          ;
        }
        break;
      case STORE:
        jj_consume_token(STORE);
        op = StoreClause(lp);
        break;
      default:
        jj_la1[13] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PARALLEL:
        jj_consume_token(PARALLEL);
        t2 = jj_consume_token(INTEGER);
                               op.setRequestedParallelism(Integer.parseInt(t2.image));
        break;
      default:
        jj_la1[14] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting BaseExpr"); {if (true) return op;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator LoadClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) LoadClause */
        SimpleNode jjtn000 = new SimpleNode(JJTLOADCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1, t2, t3;
        String filename;
        String funcName,funcArgs =null;
        FuncSpec funcSpec = null;
        String funcSpecAsString = null;
        LOLoad lo=null;
    String splitBy;
    boolean splittable = true;
        log.trace("Entering LoadClause");
    try {
      filename = FileName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        funcSpec = NonEvalFuncSpec(FunctionType.LOADFUNC);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SPLIT:
        jj_consume_token(SPLIT);
        jj_consume_token(BY);
        t3 = jj_consume_token(QUOTEDSTRING);
                        splitBy = unquote(t3.image);
                        if (splitBy.equalsIgnoreCase("file")) {
                                splittable = false;
                        }
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if (funcSpec == null){
                        funcSpecAsString = PigStorage.class.getName();
                        funcSpec = new FuncSpec(funcSpecAsString);
                        log.debug("LoadClause: funcSpec = " + funcSpec);
                }

        try {
                    lo = new LOLoad(lp, new OperatorKey(scope, getNextId()), new FileSpec(massageFilename(filename, pigContext, true), funcSpec),
                              pigContext.getExecType(), pigContext.getFs(), splittable);
        } catch (IOException ioe) {
            // The autogenerated parser code only catches RuntimeException and
            // ParseException as special Exceptions. All others are caught as
            // Throwable and then re-thrown by casting to ERROR - this can result
            // in ClassCastException if it is due to the IOException here - so
            // wrap the IOException in an "Error" object and throw the Error here
            Error e = new Error(ioe);
            {if (true) throw e;}
        }
                lp.add(lo);
                log.debug("Added operator " + lo.getClass().getName() + " to the logical plan");

                log.trace("Exiting LoadClause");
                {if (true) return lo;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public String StringList() throws ParseException {
 /*@bgen(jjtree) StringList */
        SimpleNode jjtn000 = new SimpleNode(JJTSTRINGLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);StringBuilder sb = new StringBuilder();
        Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTEDSTRING:
        t = jj_consume_token(QUOTEDSTRING);
                            sb.append(t.image);
        label_2:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_2;
          }
          jj_consume_token(83);
          t = jj_consume_token(QUOTEDSTRING);
                                  sb.append(",");sb.append(t.image);
        }
        break;
      default:
        jj_la1[18] = jj_gen;

      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.debug("StringList: " + sb.toString()); {if (true) return sb.toString();}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public String FileName() throws ParseException {
 /*@bgen(jjtree) FileName */
        SimpleNode jjtn000 = new SimpleNode(JJTFILENAME);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
    try {
      t = jj_consume_token(QUOTEDSTRING);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.debug("FileName: " + unquote(t.image)); {if (true) return unquote(t.image);}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator FilterClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) FilterClause */
        SimpleNode jjtn000 = new SimpleNode(JJTFILTERCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator cond; LogicalOperator input;
        LogicalPlan conditionPlan = new LogicalPlan();
        log.trace("Entering FilterClause");
    try {
      input = NestedExpr(lp);
                                log.debug("Filter input: " + input);
      jj_consume_token(BY);
      cond = PCond(input.getSchema(),null,conditionPlan,input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                //LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan, input);
                LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan);
                addAlias(input.getAlias(), input);
                lp.add(filter);
                log.debug("Added operator " + filter.getClass().getName() + " to the logical plan");

                lp.connect(input, filter);
                log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + filter.getClass().getName() +" in the logical plan");

                log.trace("Exiting FilterClause");
                {if (true) return filter;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/*
 * "SAMPLE a x" is translated to "FILTER a BY RANDOM()<x"
 */
  final public LogicalOperator SampleClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) SampleClause */
    SimpleNode jjtn000 = new SimpleNode(JJTSAMPLECLAUSE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);ExpressionOperator cond;
    LogicalOperator input;
    Token t;
    LogicalPlan conditionPlan = new LogicalPlan();
    log.trace("Entering SampleClause");
    try {
      input = NestedExpr(lp);
                            log.debug("Filter input: " + input);
      t = jj_consume_token(DOUBLENUMBER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        LOUserFunc rand = new LOUserFunc(conditionPlan, new OperatorKey(scope, getNextId()), new FuncSpec(RANDOM.class.getName()), DataType.DOUBLE);
        conditionPlan.add(rand);

        double l = Double.parseDouble(t.image);
        LOConst prob = new LOConst(conditionPlan, new OperatorKey(scope, getNextId()), l);
        conditionPlan.add(prob);

        cond = new LOLesserThanEqual(conditionPlan, new OperatorKey(scope, getNextId()));
        conditionPlan.add(cond);
        conditionPlan.connect(rand, cond);
        conditionPlan.connect(prob, cond);

        LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan);
        addAlias(input.getAlias(), input);
        lp.add(filter);
        log.debug("Added operator " + filter.getClass().getName() + " to the logical plan");

        lp.connect(input, filter);
        log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + filter.getClass().getName() +" in the logical plan");

        log.trace("Exiting SampleClause");
        {if (true) return filter;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator LimitClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) LimitClause */
        SimpleNode jjtn000 = new SimpleNode(JJTLIMITCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator input;
        Token t;
        log.trace("Entering LimitClause");
    try {
      input = NestedExpr(lp);
                                log.debug("Limit input: " + input);
      t = jj_consume_token(INTEGER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                long l = Integer.parseInt(t.image);
                LogicalOperator limit = new LOLimit(lp, new OperatorKey(scope, getNextId()), l);
                addAlias(input.getAlias(), input);
                lp.add(limit);
                log.debug("Added operator " + limit.getClass().getName() + " to the logical plan");

                lp.connect(input, limit);
                log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + limit.getClass().getName() +" in the logical plan");

                log.trace("Exiting LimitClause");
                {if (true) return limit;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator PCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) PCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator cond = null;
        log.trace("Entering PCond");
        log.debug("PCond Input: " + input);
    try {
      cond = POrCond(over,specs,lp, input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting PCond"); {if (true) return cond;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator POrCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) POrCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPORCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator lhsCond, rhsCond;
        log.trace("Entering POrCond");
        log.debug("POrCond Input: " + input);
    try {
      lhsCond = PAndCond(over,specs,lp,input);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OR:
          ;
          break;
        default:
          jj_la1[19] = jj_gen;
          break label_3;
        }
        jj_consume_token(OR);
        rhsCond = PAndCond(over,specs,lp,input);
                        ExpressionOperator exprOp = new LOOr(lp, new OperatorKey(scope, getNextId()) );
                        lp.add(exprOp);
                        log.debug("POrCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
                        lp.connect(lhsCond, exprOp);
                        log.debug("POrCond: Connected operator " + lhsCond.getClass().getName() + " " + lhsCond + " to " + exprOp + " logical plan " + lp);
                        lp.connect(rhsCond, exprOp);
                        log.debug("POrCond: Connected operator " + rhsCond.getClass().getName() + " " + rhsCond + " to " + exprOp + " logical plan " + lp);
                        lhsCond = exprOp;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                        log.trace("Exiting POrCond");
                        {if (true) return lhsCond;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator PAndCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) PAndCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPANDCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator lhsCond, rhsCond;
        log.trace("Entering PAndCond");
        log.debug("PAndCond Input: " + input);
    try {
      lhsCond = PUnaryCond(over,specs,lp,input);
      label_4:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AND:
          ;
          break;
        default:
          jj_la1[20] = jj_gen;
          break label_4;
        }
        jj_consume_token(AND);
        rhsCond = PUnaryCond(over,specs,lp,input);
                        ExpressionOperator exprOp = new LOAnd(lp, new OperatorKey(scope, getNextId()) );
                        lp.add(exprOp);
                        log.debug("PAndCond: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
                        lp.connect(lhsCond, exprOp);
                        log.debug("PAndCond: Connected operator " + lhsCond.getClass().getName() + " " + lhsCond + " to " + exprOp + " logical plan " + lp);
                        lp.connect(rhsCond, exprOp);
                        log.debug("PAndCond: Connected operator " + rhsCond.getClass().getName() + " " + rhsCond + " to " + exprOp + " logical plan " + lp);
                        lhsCond = exprOp;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                        log.trace("Exiting PAndCond");
                        {if (true) return lhsCond;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator PUnaryCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) PUnaryCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPUNARYCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator cond = null;
        ExpressionOperator lhs, rhs;
        Token t1;
        List<ExpressionOperator> args;
    EvalFunc evalFunc = null;
        log.trace("Entering PUnaryCond");
    try {
      if (jj_2_6(2147483647)) {
        jj_consume_token(80);
        cond = PCond(over,specs,lp,input);
        jj_consume_token(81);
      } else if (jj_2_7(2147483647)) {
        lhs = InfixExpr(over,specs,lp,input);
        t1 = jj_consume_token(FILTEROP);
        rhs = InfixExpr(over,specs,lp,input);
                //the long switch case to instantiate the right operator
                //I have the long switch case from CompCond
                String op = t1.image;
                op = op.toLowerCase();

                char op1 = op.charAt(0);
        char op2 = op.length() >= 2 ? op.charAt(1) : '0';
        char op3 = op.length() == 3 ? op.charAt(2) : '0';

        switch (op1) {
            // numeric ops first
        case '=':
            if (op2 == '=') {
                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()) );
            } else {
                {if (true) throw new ParseException("Internal error: Invalid filter operator: " + op);}
            }
            break;
        case '<':
            if (op2 == '=') {
                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()));
            }
            break;
        case '>':
            if (op2 == '=') {
                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()));
            }
            break;
        case '!':
            if (op2 == '=') {
                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                {if (true) throw new ParseException("Internal error: Invalid filter operator: " + op);}
            }
            break;
            // now string ops
        case 'e':
            if (op2 == 'q') {
                cond = new LOEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                {if (true) throw new ParseException("Internal error: Invalid filter operator: " + op);}
            }
            break;
        case 'l':
            if (op2 == 't' && op3 == 'e') {
                cond = new LOLesserThanEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                cond = new LOLesserThan(lp, new OperatorKey(scope, getNextId()));
            }
            break;
        case 'g':
            if (op2 == 't' && op3 == 'e') {
                cond = new LOGreaterThanEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                cond = new LOGreaterThan(lp, new OperatorKey(scope, getNextId()));
            }
            break;
        case 'n':
            if (op2 == 'e' && op3 == 'q') {
                cond = new LONotEqual(lp, new OperatorKey(scope, getNextId()));
            } else {
                {if (true) throw new ParseException("Internal error: Invalid filter operator: " + op);}
            }
            break;
        default:
            {if (true) throw new ParseException("Internal error: Invalid filter operator: " + op);}
        }

        lp.add(cond);
                log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
                lp.connect(lhs, cond);
                log.debug("PUnaryCond: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + cond + " logical plan " + lp);
                lp.connect(rhs, cond);
                log.debug("PUnaryCond: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + cond + " logical plan " + lp);
      } else if (jj_2_8(2147483647)) {
        lhs = InfixExpr(over,specs,lp,input);
        jj_consume_token(MATCHES);
        t1 = jj_consume_token(QUOTEDSTRING);
                LOConst rconst = new LOConst(lp, new OperatorKey(scope, getNextId()), unquote(t1.image));
                rconst.setType(DataType.CHARARRAY);
                                cond = new LORegexp(lp, new OperatorKey(scope, getNextId()));
                                lp.add(rconst);
                                lp.add(cond);
                                log.debug("PUnaryCond: Added operator " + cond.getClass().getName() + " " + cond + " to logical plan " + lp);
                                lp.connect(lhs, cond);
                                lp.connect(rconst, cond);
                                log.debug("PUnaryCond: Connected operator " + cond.getClass().getName() + " " + cond + " to " + lhs + " logical plan " + lp);
      } else if (jj_2_9(2147483647)) {
        cond = EvalFuncSpec(over,specs,lp, input, FunctionType.EVALFUNC);
      } else if (jj_2_10(1)) {
        cond = PNullCond(over,specs,lp,input);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NOT:
          cond = PNotCond(over,specs,lp,input);
          break;
        default:
          jj_la1[21] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting PUnaryCond"); {if (true) return cond;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator PNotCond(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) PNotCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPNOTCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator c1;
        log.trace("Entering PNotCond");
    try {
      jj_consume_token(NOT);
      c1 = PUnaryCond(over,specs,lp,input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator eOp = new LONot(lp, new OperatorKey(scope, getNextId()));
                lp.add(eOp);
                log.debug("PNotCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
                lp.connect(c1, eOp);
                log.debug("PNotCond: Connected operator " + eOp.getClass().getName() + " " + eOp + " to " + c1 + " logical plan " + lp);
                log.trace("Exiting PNotCond");
                {if (true) return eOp;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator PNullCond(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) PNullCond */
        SimpleNode jjtn000 = new SimpleNode(JJTPNULLCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator c1;
    boolean not = false;
        log.trace("Entering PNullCond");
    try {
      c1 = InfixExpr(over,specs,lp,input);
      jj_consume_token(IS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        jj_consume_token(NOT);
                                                       not = true;
        break;
      default:
        jj_la1[22] = jj_gen;
        ;
      }
      jj_consume_token(NULL);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator eOp = new LOIsNull(lp, new OperatorKey(scope, getNextId()));
                lp.add(eOp);
                log.debug("PNullCond: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
                lp.connect(c1, eOp);
                log.debug("PNullCond: Connected operator " + eOp.getClass().getName() + " " + eOp + " to " + c1 + " logical plan " + lp);
        ExpressionOperator notNull = null;
        if (not) {
            notNull = new LONot(lp, new OperatorKey(scope, getNextId()));
            lp.add(notNull);
                    log.debug("PNullCond: Added operator " + notNull.getClass().getName() + " " + notNull + " to logical plan " + lp);
            lp.connect(eOp, notNull);
                    log.debug("PNullCond: Connected operator " + notNull.getClass().getName() + " " + notNull + " to " + eOp + " logical plan " + lp);
            eOp = notNull;
        }
                log.trace("Exiting PNullCond");
                {if (true) return eOp;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator CogroupClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) CogroupClause */
        SimpleNode jjtn000 = new SimpleNode(JJTCOGROUPCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);CogroupInput gi;
        ArrayList<CogroupInput> gis = new ArrayList<CogroupInput>();
        LogicalOperator cogroup;
        log.trace("Entering CoGroupClause");
    try {
      gi = GroupItem(lp);
                              gis.add(gi);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[23] = jj_gen;
          break label_5;
        }
        jj_consume_token(83);
        gi = GroupItem(lp);
                                  gis.add(gi);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                cogroup = parseCogroup(gis, lp);
                log.trace("Exiting CoGroupClause");
                {if (true) return cogroup;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public CogroupInput GroupItem(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) GroupItem */
        SimpleNode jjtn000 = new SimpleNode(JJTGROUPITEM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator es;
        LogicalOperator cgOp;
        boolean isInner = false;
        ArrayList<LogicalPlan> listPlans = new ArrayList<LogicalPlan>();
        LogicalPlan groupByPlan;
        ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
        ArrayList<Schema> userDefinedSchemaList = new ArrayList<Schema>();
        log.trace("Entering GroupItem");
        log.debug("LogicalPlan: " + lp);
    try {
      cgOp = NestedExpr(lp);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BY:
        jj_consume_token(BY);
        if (jj_2_11(2147483647)) {
          jj_consume_token(80);
          es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList, userDefinedSchemaList);
                                                 listPlans.add(groupByPlan);
          label_6:
          while (true) {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case 83:
              ;
              break;
            default:
              jj_la1[24] = jj_gen;
              break label_6;
            }
            jj_consume_token(83);
            es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList, userDefinedSchemaList);
                                                         listPlans.add(groupByPlan);
          }
          jj_consume_token(81);
        } else if (jj_2_12(1)) {
          es = FlattenedGenerateItem(cgOp.getSchema(), null, groupByPlan = new LogicalPlan(), cgOp, flattenList, userDefinedSchemaList);
                                                 listPlans.add(groupByPlan);
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case ALL:
        jj_consume_token(ALL);
                                        es = new LOConst(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), "all");
                    es.setType(DataType.CHARARRAY);
                                        groupByPlan.add(es);
                                        log.debug("GroupItem: Added operator " + es.getClass().getName() + " " + es + " to logical plan " + groupByPlan);
                                        listPlans.add(groupByPlan);
        break;
      case ANY:
        jj_consume_token(ANY);
                                        es = new LOUserFunc(groupByPlan = new LogicalPlan(), new OperatorKey(scope, getNextId()), new FuncSpec(GFAny.class.getName()), DataType.INTEGER);
                                        groupByPlan.add(es);
                                        log.debug("GroupItem: Added operator " + es.getClass().getName() + " " + es + " to logical plan " + groupByPlan);
                                        listPlans.add(groupByPlan);
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INNER:
      case OUTER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INNER:
          jj_consume_token(INNER);
                          isInner = true;
          break;
        case OUTER:
          jj_consume_token(OUTER);
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                CogroupInput cogroupInput = new CogroupInput();

                cogroupInput.plans = listPlans;
                cogroupInput.op = cgOp;
                cogroupInput.isInner = isInner;

                log.trace("Exiting GroupItem");
                {if (true) return cogroupInput;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator OrderClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) OrderClause */
        SimpleNode jjtn000 = new SimpleNode(JJTORDERCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        ExpressionOperator col;
        boolean star = false;
        ArrayList<ExpressionOperator> sortCols = new ArrayList<ExpressionOperator>();
        ArrayList<LogicalPlan> sortColPlans = new ArrayList<LogicalPlan>();
        ArrayList<Boolean> ascOrder = new ArrayList<Boolean>();
        boolean asc = true;
        String funcName = null;
        Token t1;
    FuncSpec funcSpec = null;
        log.trace("Entering OrderClause");
    try {
      op = NestedExpr(lp);
      jj_consume_token(BY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case DOLLARVAR:
      case 80:
        col = SortCol(op.getSchema(), lp, op, ascOrder, sortColPlans);
        label_7:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[28] = jj_gen;
            break label_7;
          }
          jj_consume_token(83);
          col = SortCol(op.getSchema(), lp, op, ascOrder, sortColPlans);
        }
        break;
      case STAR:
        jj_consume_token(STAR);
                        star = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
        case DESC:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            break;
          case DESC:
            jj_consume_token(DESC);
                                                       asc = false;
            break;
          default:
            jj_la1[29] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[30] = jj_gen;
          ;
        }
            LogicalPlan sortColPlan = new LogicalPlan();
                    LOProject projectStar = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), op, -1);
                        ((LOProject)projectStar).setStar(true);
            sortColPlan.add(projectStar);
            sortColPlans.add(sortColPlan);
                        log.debug("Set star to true");
                        if(asc) {
                                ascOrder.add(true);
                        } else {
                                ascOrder.add(false);
                        }
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        funcSpec = NonEvalFuncSpec(FunctionType.COMPARISONFUNC);
        break;
      default:
        jj_la1[32] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LOSort sort = new LOSort(lp, new OperatorKey(scope, getNextId()), sortColPlans, ascOrder,
                                          funcSpec );
                sort.setStar(star);
                sort.setLimit(-1);
                lp.add(sort);
                log.debug("Added operator " + sort.getClass().getName() + " to the logical plan");

                lp.connect(op, sort);
                log.debug("Connecting sort input alias " + op.getAlias() + " operator " + op.getClass().getName() + " to operator " + sort.getClass().getName() + " in the logical plan");

                log.trace("Exiting OrderClause");
                {if (true) return sort;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator SortCol(Schema over, LogicalPlan lp, LogicalOperator op, ArrayList<Boolean> ascOrder, ArrayList<LogicalPlan> sortColPlans) throws ParseException {
 /*@bgen(jjtree) SortCol */
        SimpleNode jjtn000 = new SimpleNode(JJTSORTCOL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator col;
    int colNum;
        boolean asc = true;
        LogicalPlan sortColPlan = new LogicalPlan();
        log.trace("Entering SortCol");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case DOLLARVAR:
        //col = ColOrSpec(op.getSchema(), null, sortColPlan, op) [<ASC> | <DESC> {asc = false;}]
                        colNum = ColNameOrNum(op.getSchema());
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
        case DESC:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            break;
          case DESC:
            jj_consume_token(DESC);
                                                                       asc = false;
            break;
          default:
            jj_la1[33] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[34] = jj_gen;
          ;
        }
                        if(asc) {
                                log.debug("Ascending");
                                ascOrder.add(true);
                        } else {
                                log.debug("Descending");
                                ascOrder.add(false);
                        }
            col = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), op, colNum);
            sortColPlan.add(col);
                        sortColPlans.add(sortColPlan);
        break;
      case 80:
        jj_consume_token(80);
        colNum = ColNameOrNum(op.getSchema());
        jj_consume_token(81);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
        case DESC:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            break;
          case DESC:
            jj_consume_token(DESC);
                                                                                       asc = false;
            break;
          default:
            jj_la1[35] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[36] = jj_gen;
          ;
        }
                                if(asc) {
                                        log.debug("Ascending");
                                        ascOrder.add(true);
                                } else {
                                        log.debug("Descending");
                                        ascOrder.add(false);
                                }
                col = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), op, colNum);
                sortColPlan.add(col);
                                sortColPlans.add(sortColPlan);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting SortCol");
                {if (true) return col;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public int ColNameOrNum(Schema over) throws ParseException {
 /*@bgen(jjtree) ColNameOrNum */
        SimpleNode jjtn000 = new SimpleNode(JJTCOLNAMEORNUM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        log.trace("Entering ColNameOrNum");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOLLARVAR:
        t = jj_consume_token(DOLLARVAR);
                          jjtree.closeNodeScope(jjtn000, true);
                          jjtc000 = false;
                         {if (true) return undollar(t.image);}
        break;
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                int i;

        try {
                    if ( over == null ||  (i = over.getPosition(t.image)) == -1) {
                            {if (true) throw new ParseException("Invalid alias: " + t.image + " in " + over);}
                    }
        } catch (FrontendException fee) {
                ParseException pe = new ParseException(fee.getMessage());
                pe.initCause(fee);
            {if (true) throw pe;}
        }

                log.trace("Exiting ColNameOrNum");
                {if (true) return i;}
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator CrossClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) CrossClause */
        SimpleNode jjtn000 = new SimpleNode(JJTCROSSCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        ArrayList<LogicalOperator> inputs = new ArrayList<LogicalOperator>();
        log.trace("Entering CrossClause");
    try {
      op = NestedExpr(lp);
                              inputs.add(op);
      label_8:
      while (true) {
        jj_consume_token(83);
        op = NestedExpr(lp);
                                   inputs.add(op);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[39] = jj_gen;
          break label_8;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LogicalOperator cross = new LOCross(lp, new OperatorKey(scope, getNextId()));
                lp.add(cross);
                log.debug("Added operator " + cross.getClass().getName() + " to the logical plan");

                for (LogicalOperator lop: inputs) {
                                lp.connect(lop, cross);
                                log.debug("Connected operator " + lop.getClass().getName() + " " + lop + " to " + cross + " logical plan " + lp);
                }
                log.debug("Connected cross inputs to the cross operator");

                log.trace("Exiting CrossClause");
                {if (true) return cross;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator JoinClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) JoinClause */
        SimpleNode jjtn000 = new SimpleNode(JJTJOINCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);CogroupInput gi;
        ArrayList<CogroupInput> gis = new ArrayList<CogroupInput>();
        log.trace("Entering JoinClause");
        log.debug("LogicalPlan: " + lp);
        LogicalOperator frj = null;
    try {
      gi = GroupItem(lp);
                              gis.add(gi);
      label_9:
      while (true) {
        jj_consume_token(83);
        gi = GroupItem(lp);
                                  gis.add(gi);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[40] = jj_gen;
          break label_9;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 84:
          jj_consume_token(84);
          break;
        case 85:
          jj_consume_token(85);
          break;
        default:
          jj_la1[41] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                   frj = parseFRJoin(gis, lp);
        break;
      default:
        jj_la1[42] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting JoinClause"); {if (true) return (frj==null) ? rewriteJoin(gis, lp) : frj;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator UnionClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) UnionClause */
        SimpleNode jjtn000 = new SimpleNode(JJTUNIONCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator op;
        ArrayList<LogicalOperator> inputs = new ArrayList<LogicalOperator>();
        log.trace("Entering UnionClause");
    try {
      op = NestedExpr(lp);
                             inputs.add(op);
      label_10:
      while (true) {
        jj_consume_token(83);
        op = NestedExpr(lp);
                                  inputs.add(op);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[43] = jj_gen;
          break label_10;
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LogicalOperator union = new LOUnion(lp, new OperatorKey(scope, getNextId()));
                lp.add(union);
                log.debug("Added operator " + union.getClass().getName() + " to the logical plan");

                for (LogicalOperator lop: inputs) {
                        lp.connect(lop, union);
                        log.debug("Connected union input operator " + lop.getClass().getName() + " to operator " + lop.getClass().getName() + " in the logical plan");
                }

                log.trace("Exiting UnionClause");
                {if (true) return union;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator ForEachClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) ForEachClause */
        SimpleNode jjtn000 = new SimpleNode(JJTFOREACHCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ArrayList<LogicalOperator> specList = new ArrayList<LogicalOperator>();
        LogicalOperator input, foreach;
        LogicalPlan foreachPlan = new LogicalPlan();
    ArrayList<LogicalPlan> foreachPlans = new ArrayList<LogicalPlan>();
        log.trace("Entering ForEachClause");
    try {
      input = NestedExpr(lp);
      specList = NestedBlock(input.getSchema(), specList, foreachPlan, input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        LOGenerate generate = (LOGenerate)specList.get(specList.size() - 1);
        List<LogicalPlan> generatePlans = generate.getGeneratePlans();
        List<Boolean> flattenList = generate.getFlatten();
        List<Schema> userDefinedSchemaList = generate.getUserDefinedSchema();
        /*
        Generate's nested plans will be translated to foreach's nested plan
        If generate contains an expression that does not require generate's
        inputs then it should be made part of foreach without the generate
        For the remaining expressions, the entire DAG till generate has to be
        duplicated and then the nested plan attached to a new generate
        */

        for (int planCtr = 0; planCtr < generatePlans.size(); ++planCtr) {
            LogicalPlan generatePlan = generatePlans.get(planCtr);
            List<LogicalOperator> planRoots = new ArrayList<LogicalOperator>(generatePlan.getRoots());
            boolean needGenerateInput = false;
            boolean needForEachInput = false;
            MultiMap<LogicalOperator, LogicalOperator> mapProjectInputs = null;
            Map<LogicalOperator, Boolean> rootProcessed = new HashMap<LogicalOperator, Boolean>();
            for(LogicalOperator root: planRoots) {
                if(root instanceof ExpressionOperator && !(root instanceof LOProject)) {
                    if(checkGenerateInput(root)) {
                        needGenerateInput = true;
                        attachPlan(generatePlan, root, foreachPlan, rootProcessed);
                        rootProcessed.put(root, true);
                    }
                }
            }

            planRoots = generatePlan.getRoots();
            needGenerateInput = false;
            needForEachInput = false;

            for(LogicalOperator root: planRoots) {
                if(root instanceof LOProject) {
                    LOProject project = (LOProject)root;
                    LogicalOperator projectInput = project.getExpression();
                    if(checkGenerateInput(projectInput) || !(projectInput.equals(input))) {
                        needGenerateInput = true;
                        if(null == mapProjectInputs) {
                            mapProjectInputs = new MultiMap<LogicalOperator, LogicalOperator>();
                        }
                        mapProjectInputs.put(root, projectInput);
                    } else {
                        needForEachInput = true;
                    }
                }
            }
            if(needGenerateInput) {
                /*
                Duplicate the logical plan until the generate but excluding generate
                Create a new generate operator with the plan being iterated on
                Attach the generate as the leaf and add the duplicated plan to
                the list of foreach plans
                */

                for(LogicalOperator project: mapProjectInputs.keySet()) {
                    for(LogicalOperator projectInput: mapProjectInputs.get(project)) {
                        generatePlan.add(projectInput);
                        generatePlan.connect(projectInput, project);
                        attachPlan(generatePlan, projectInput, foreachPlan, rootProcessed);
                        rootProcessed.put(projectInput, true);
                    }
                }
            }
            LogicalPlanCloner lpCloner = new LogicalPlanCloner(generatePlan);
            LogicalPlan generatePlanClone;
            try {
                generatePlanClone = lpCloner.getClonedPlan();
            } catch (CloneNotSupportedException cnse) {
                ParseException pe = new ParseException("Not able to clone foreach plan");
                pe.initCause(cnse);
                {if (true) throw pe;}
            }
            RemoveRedundantOperators removeOperators = new RemoveRedundantOperators(generatePlanClone);
            try {
                removeOperators.visit();
            } catch (VisitorException ve) {
                ParseException pe = new ParseException("Could not remove redundant operators in foreach plan.");
                pe.initCause(ve);
                {if (true) throw pe;}
            }
            foreachPlans.add(generatePlanClone);
        }

                resetGenerateState();
                foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), (ArrayList)foreachPlans, (ArrayList)flattenList, (ArrayList) userDefinedSchemaList);
                try {
                        lp.add(foreach);
                        log.debug("Added operator " + foreach.getClass().getName() + " to the logical plan");

                        lp.connect(input, foreach);
                        log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " object " + input + " to operator " + foreach.getClass().getName() + " in the logical plan");
                } catch (PlanException planException) {
                        ParseException pe = new ParseException(planException.getMessage());
                        pe.initCause(planException);
                        {if (true) throw pe;}
                }

                log.trace("Exiting ForEachClause");
                {if (true) return foreach;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator StreamClause(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) StreamClause */
        SimpleNode jjtn000 = new SimpleNode(JJTSTREAMCLAUSE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator input;
        StreamingCommand command;
    try {
      input = NestedExpr(lp);
      jj_consume_token(THROUGH);
      command = Command();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LOStream loStream = new LOStream(lp, new OperatorKey(scope, getNextId()), input,
                    pigContext.createExecutableManager(), command);
        //addAlias(input.getAlias(), input);
        lp.add(loStream);
        lp.connect(input, loStream);
        {if (true) return loStream;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public StreamingCommand Command() throws ParseException {
                             /*@bgen(jjtree) Command */
                             SimpleNode jjtn000 = new SimpleNode(JJTCOMMAND);
                             boolean jjtc000 = true;
                             jjtree.openNodeScope(jjtn000);Token t; StreamingCommand command;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXECCOMMAND:
        t = jj_consume_token(EXECCOMMAND);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                String[] argv = splitArgs(unquote(t.image));
                command = new StreamingCommand(pigContext, argv);
        checkAutoShipSpecs(command, argv);
                {if (true) return command;}
        break;
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                command = pigContext.getCommandForAlias(t.image);
                if (command == null) {
                        {if (true) throw new ParseException("Undefined command-alias: " + t.image +
                                                 " used as stream operator");}
                }

                {if (true) return command;}
        break;
      default:
        jj_la1[44] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator DefineClause(LogicalPlan lp) throws ParseException {
                                                /*@bgen(jjtree) DefineClause */
                                                SimpleNode jjtn000 = new SimpleNode(JJTDEFINECLAUSE);
                                                boolean jjtc000 = true;
                                                jjtree.openNodeScope(jjtn000);Token t; Token cmd; String functionName, functionArgs;
    try {
      t = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXECCOMMAND:
        cmd = jj_consume_token(EXECCOMMAND);
            StreamingCommand command =
               new StreamingCommand(pigContext, splitArgs(unquote(cmd.image)));
            String[] paths;
            StreamingCommand.HandleSpec[] handleSpecs;
        label_11:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SHIP:
          case CACHE:
          case INPUT:
          case OUTPUT:
          case ERROR:
            ;
            break;
          default:
            jj_la1[45] = jj_gen;
            break label_11;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case SHIP:
            jj_consume_token(SHIP);
            jj_consume_token(80);
            paths = PathList();
            jj_consume_token(81);
                if (paths.length == 0) {
                        command.setShipFiles(false);
                } else {
                    for (String path : paths) {
                        try {
                            command.addPathToShip(path);
                        } catch(IOException e) {
                                ParseException pe = new ParseException(e.getMessage());
                                pe.initCause(e);
                            {if (true) throw pe;}
                        }
                    }
                }
            break;
          case CACHE:
            jj_consume_token(CACHE);
            jj_consume_token(80);
            paths = PathList();
            jj_consume_token(81);
                for (String path : paths) {
                    try {
                        command.addPathToCache(path);
                    } catch(IOException e) {
                        ParseException pe = new ParseException(e.getMessage());
                        pe.initCause(e);
                        {if (true) throw pe;}
                    }
                }
            break;
          case INPUT:
            jj_consume_token(INPUT);
            jj_consume_token(80);
            InputOutputSpec(command, StreamingCommand.Handle.INPUT);
            jj_consume_token(81);
            break;
          case OUTPUT:
            jj_consume_token(OUTPUT);
            jj_consume_token(80);
            InputOutputSpec(command, StreamingCommand.Handle.OUTPUT);
            jj_consume_token(81);
            break;
          case ERROR:
            jj_consume_token(ERROR);
            jj_consume_token(80);
            ErrorSpec(command, t.image);
            jj_consume_token(81);
            break;
          default:
            jj_la1[46] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
            pigContext.registerStreamCmd(t.image, command);
        break;
      case IDENTIFIER:
        functionName = QualifiedFunction();
        jj_consume_token(80);
        functionArgs = StringList();
        jj_consume_token(81);
            pigContext.registerFunction(t.image, new FuncSpec(functionName + "(" + functionArgs + ")"));
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        // Return the dummy LODefine
        LogicalOperator lo = new LODefine(lp, new OperatorKey(scope, getNextId()));
        lp.add(lo);
        {if (true) return lo;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public String[] PathList() throws ParseException {
                       /*@bgen(jjtree) PathList */
                       SimpleNode jjtn000 = new SimpleNode(JJTPATHLIST);
                       boolean jjtc000 = true;
                       jjtree.openNodeScope(jjtn000);Token t; List<String> pathList = new ArrayList<String>();
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTEDSTRING:
        t = jj_consume_token(QUOTEDSTRING);
                        pathList.add(unquote(t.image));
        label_12:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[48] = jj_gen;
            break label_12;
          }
          jj_consume_token(83);
          t = jj_consume_token(QUOTEDSTRING);
                              pathList.add(unquote(t.image));
        }
        break;
      default:
        jj_la1[49] = jj_gen;

      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return pathList.toArray(new String[pathList.size()]);}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void InputOutputSpec(StreamingCommand command, StreamingCommand.Handle handle) throws ParseException {
 /*@bgen(jjtree) InputOutputSpec */
    SimpleNode jjtn000 = new SimpleNode(JJTINPUTOUTPUTSPEC);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);String stream, deserializer;
    StreamingCommand.HandleSpec[] handleSpecs;
    String functionName = "PigStorage", functionArgs="";
    byte funcType = (handle.compareTo(StreamingCommand.Handle.INPUT) != 0 ? FunctionType.LOADFUNC : FunctionType.STOREFUNC) ;
    FuncSpec funcSpec = null;
    try {
      stream = CommandStream();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        funcSpec = NonEvalFuncSpec(funcType);
        break;
      default:
        jj_la1[50] = jj_gen;
        ;
      }
        deserializer = (funcSpec == null? functionName + "(" + ")" : funcSpec.toString());
        command.addHandleSpec(handle,
                              new HandleSpec(stream, deserializer)
                             );
      label_13:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[51] = jj_gen;
          break label_13;
        }
        jj_consume_token(83);
        stream = CommandStream();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case USING:
          jj_consume_token(USING);
          funcSpec = NonEvalFuncSpec(funcType);
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
            deserializer = (funcSpec == null? functionName + "(" + ")" : funcSpec.toString());
            command.addHandleSpec(handle,
                                  new HandleSpec(stream, deserializer)
                                 );
      }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
  }

  final public String CommandStream() throws ParseException {
                         /*@bgen(jjtree) CommandStream */
                         SimpleNode jjtn000 = new SimpleNode(JJTCOMMANDSTREAM);
                         boolean jjtc000 = true;
                         jjtree.openNodeScope(jjtn000);Token t;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STDIN:
        t = jj_consume_token(STDIN);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return "stdin";}
        break;
      case STDOUT:
        t = jj_consume_token(STDOUT);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return "stdout";}
        break;
      case QUOTEDSTRING:
        t = jj_consume_token(QUOTEDSTRING);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
     {if (true) return unquote(t.image);}
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public void ErrorSpec(StreamingCommand command, String alias) throws ParseException {
                                                         /*@bgen(jjtree) ErrorSpec */
                                                         SimpleNode jjtn000 = new SimpleNode(JJTERRORSPEC);
                                                         boolean jjtc000 = true;
                                                         jjtree.openNodeScope(jjtn000);Token t1, t2; int limit = StreamingCommand.MAX_TASKS;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QUOTEDSTRING:
        t1 = jj_consume_token(QUOTEDSTRING);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LIMIT:
          jj_consume_token(LIMIT);
          t2 = jj_consume_token(INTEGER);
                                 limit = Integer.parseInt(t2.image);
          break;
        default:
          jj_la1[54] = jj_gen;
          ;
        }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                command.setLogDir(unquote(t1.image));
                command.setLogFilesLimit(limit);
        break;
      default:
        jj_la1[55] = jj_gen;
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        command.setLogDir(alias);
      }
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public LogicalOperator StoreClause(LogicalPlan lp) throws ParseException {
                                               /*@bgen(jjtree) StoreClause */
                                               SimpleNode jjtn000 = new SimpleNode(JJTSTORECLAUSE);
                                               boolean jjtc000 = true;
                                               jjtree.openNodeScope(jjtn000);LogicalOperator lo; Token t; String fileName; String functionSpec = null;
                                                String functionName, functionArgs; FuncSpec funcSpec = null;
    try {
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(INTO);
      fileName = FileName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        funcSpec = NonEvalFuncSpec(FunctionType.STOREFUNC);
        break;
      default:
        jj_la1[56] = jj_gen;
        ;
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if (funcSpec == null) {
            funcSpec = new FuncSpec(PigStorage.class.getName() + "()");
        }

        LogicalOperator store = new LOStore(lp, new OperatorKey(scope, getNextId()),
                                            new FileSpec(massageFilename(fileName, pigContext, false), funcSpec));

        LogicalOperator input = mapAliasOp.get(t.image);
        if (input == null)
            {if (true) throw new ParseException("Unable to find alias " + t.image);}

        lp.add(store);
        lp.add(input);
        lp.connect(input, store);
        {if (true) return store;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ArrayList<LogicalOperator> NestedBlock(Schema over, ArrayList<LogicalOperator> specList, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedBlock */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDBLOCK);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator spec;
        Map<String, LogicalOperator> specs = new HashMap<String, LogicalOperator>();
        log.trace("Entering NestedBlock");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GENERATE:
        spec = GenerateStatement(over,specs, lp, input);
                                                         specList.add(spec);
        break;
      case 86:
        jj_consume_token(86);
        label_14:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[57] = jj_gen;
            break label_14;
          }
          NestedCommand(over,specs,specList, lp, input);
          jj_consume_token(82);
        }
        spec = GenerateStatement(over,specs,lp,input);
        jj_consume_token(82);
        jj_consume_token(87);
         specList.add(spec);
        break;
      default:
        jj_la1[58] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting NestedBlock"); {if (true) return specList;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void NestedCommand(Schema over, Map<String, LogicalOperator> specs, List<LogicalOperator> specList, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedCommand */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDCOMMAND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        LogicalOperator item;
        LogicalOperator eOp = null;
        log.trace("Entering NestedCommand");
    try {
      t = jj_consume_token(IDENTIFIER);
      jj_consume_token(79);
      if (jj_2_13(2147483647)) {
        item = InfixExpr(over,specs,lp, input);
        lp.add(item);
      } else if (jj_2_14(2147483647)) {
        eOp = NestedProject(over,specs,lp,input);
                item = eOp;
                lp.add(eOp);
                log.debug("Added operator " + eOp.getClass().getName() + " " + eOp + " to the logical plan " + lp);
      } else if (jj_2_15(1)) {
        item = InfixExpr(over,specs,lp, input);
        lp.add(item);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FILTER:
          item = NestedFilter(over,specs,lp, input);
          break;
        case ORDER:
        case ARRANGE:
          item = NestedSortOrArrange(over,specs,lp, input);
          break;
        case DISTINCT:
          item = NestedDistinct(over,specs,lp, input);
          break;
        case LIMIT:
          item = NestedLimit(over,specs,lp, input);
          break;
        default:
          jj_la1[59] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                String alias = t.image;
                item.setAlias(alias);
                specs.put(alias,item);
                log.debug("Added " + alias + " to the specs map");
                specList.add(item);
                log.debug("Added " + alias + " to the specList");

                log.trace("Exiting NestedCommand");
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public LogicalOperator NestedProject(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedProject */
    SimpleNode jjtn000 = new SimpleNode(JJTNESTEDPROJECT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Token t;
        ArrayList<Integer> colList = new ArrayList<Integer>();
    int i = -1;
    LogicalOperator foreachInput = null;
    Schema subSchema = null;
        log.trace("Entering NestedFilter");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        t = jj_consume_token(IDENTIFIER);
        if(null != specs) {
            foreachInput = specs.get(t.image);
        }
        if(null == foreachInput) {
            try {
                            if ((null == over) ||  (i = over.getPosition(t.image)) == -1) {
                                    {if (true) throw new ParseException("Invalid alias: " + t.image + " in " + over);}
                            }
            } catch (FrontendException fee) {
                ParseException pe = new ParseException(fee.getMessage());
                pe.initCause(fee);
                {if (true) throw pe;}
            }
            foreachInput = new LOProject(lp, new OperatorKey(scope, getNextId()), input, i);
        }

        try {
            lp.add(foreachInput);
            if(input instanceof ExpressionOperator) {
                lp.add(input);
                lp.connect(input, foreachInput);
            }
        } catch (Exception planException) {
                ParseException pe = new ParseException(planException.getMessage());
            pe.initCause(planException);
            {if (true) throw pe;}
        }
        break;
      case DOLLARVAR:
        t = jj_consume_token(DOLLARVAR);
        foreachInput = new LOProject(lp, new OperatorKey(scope, getNextId()), input, undollar(t.image));
        break;
      default:
        jj_la1[60] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if(foreachInput instanceof ExpressionOperator) {
            subSchema = ((ExpressionOperator)foreachInput).getFieldSchema().schema;
        } else {
            subSchema = foreachInput.getSchema();
        }
      jj_consume_token(88);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case DOLLARVAR:
        i = ColNameOrNum(subSchema);
                                 colList.add(i);
        break;
      case 80:
        jj_consume_token(80);
        i = ColNameOrNum(subSchema);
                                     colList.add(i);
        label_15:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[61] = jj_gen;
            break label_15;
          }
          jj_consume_token(83);
          i = ColNameOrNum(over);
                                                                                   colList.add(i);
        }
        jj_consume_token(81);
        break;
      default:
        jj_la1[62] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        ArrayList<LogicalPlan> foreachPlans = new ArrayList<LogicalPlan>();
        ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
        for(int j: colList) {
            LogicalPlan plan = new LogicalPlan();
            LOProject project = new LOProject(plan, new OperatorKey(scope, getNextId()), foreachInput, j);
            plan.add(project);
            foreachPlans.add(plan);
            flattenList.add(false);
        }
                LogicalOperator foreach = new LOForEach(lp, new OperatorKey(scope, getNextId()), foreachPlans, flattenList);
        lp.add(foreach);
        lp.add(foreachInput);
        lp.connect(foreachInput, foreach);
        {if (true) return foreach;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator NestedFilter(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedFilter */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDFILTER);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator cond;
        Schema subSchema = null;
        LogicalOperator eOp;
        LogicalPlan conditionPlan = new LogicalPlan();
    Token t;
        log.trace("Entering NestedFilter");
    try {
      jj_consume_token(FILTER);
      if (jj_2_16(2147483647)) {
        eOp = NestedProject(over, specs, lp, input);
      } else if (null != specs.get(getToken(1).image)) {
        t = jj_consume_token(IDENTIFIER);
                                                                          eOp = specs.get(t.image);
      } else if (jj_2_17(1)) {
        eOp = BaseEvalSpec(over, specs, lp, input);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
         subSchema = eOp.getSchema();
      jj_consume_token(BY);
      cond = PCond(subSchema,null,conditionPlan,eOp);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                lp.add(eOp);
                log.debug("Added " + eOp.getAlias() + " to the logical plan");
                //LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan, eOp);
                LogicalOperator filter = new LOFilter(lp, new OperatorKey(scope, getNextId()), conditionPlan);
                lp.add(filter);
                log.debug("Added nested filter operator " + filter.getClass().getName() + " to the logical plan");

                lp.connect(eOp, filter);
                log.debug("Connected the filter input to the filter");

                log.trace("Exiting NestedFilter");
                {if (true) return filter;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator NestedSortOrArrange(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedSortOrArrange */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDSORTORARRANGE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator col;
        boolean star = false;
        ArrayList<LogicalPlan> sortColPlans = new ArrayList<LogicalPlan>();
        ArrayList<Boolean> ascOrder = new ArrayList<Boolean>();
        String funcName = null;
        LogicalOperator eOp;
        Token t;
        boolean asc = true;
    FuncSpec funcSpec = null;
        log.trace("Entering NestedSortOrArrange");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ORDER:
        jj_consume_token(ORDER);
        break;
      case ARRANGE:
        jj_consume_token(ARRANGE);
        break;
      default:
        jj_la1[63] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      if (jj_2_18(2147483647)) {
        eOp = NestedProject(over, specs, lp, input);
      } else if (null != specs.get(getToken(1).image)) {
        t = jj_consume_token(IDENTIFIER);
                                                                          eOp = specs.get(t.image);
      } else if (jj_2_19(1)) {
        eOp = BaseEvalSpec(over, specs, lp, input);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(BY);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
      case DOLLARVAR:
      case 80:
        col = SortCol(eOp.getSchema(), lp, eOp, ascOrder, sortColPlans);
        label_16:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[64] = jj_gen;
            break label_16;
          }
          jj_consume_token(83);
          col = SortCol(eOp.getSchema(), lp, eOp, ascOrder, sortColPlans);
        }
        break;
      case STAR:
        jj_consume_token(STAR);
                          star = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASC:
        case DESC:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ASC:
            jj_consume_token(ASC);
            break;
          case DESC:
            jj_consume_token(DESC);
                                                         asc = false;
            break;
          default:
            jj_la1[65] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[66] = jj_gen;
          ;
        }
                LogicalPlan sortColPlan = new LogicalPlan();
                        LOProject projectStar = new LOProject(sortColPlan, new OperatorKey(scope, getNextId()), eOp, -1);
                            ((LOProject)projectStar).setStar(true);
                sortColPlan.add(projectStar);
                sortColPlans.add(sortColPlan);
                                if(asc) {
                                        ascOrder.add(true);
                                } else {
                                        ascOrder.add(false);
                                }
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case USING:
        jj_consume_token(USING);
        funcSpec = NonEvalFuncSpec(FunctionType.COMPARISONFUNC);
        break;
      default:
        jj_la1[68] = jj_gen;
        ;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.debug("Before creating LOSort");
                LOSort sort = new LOSort(lp, new OperatorKey(scope, getNextId()), sortColPlans, ascOrder,
                                          funcSpec);
                sort.setStar(star);
                log.debug("After creating LOSort");
                try {
                        lp.add(eOp);
                        log.debug("Added " + eOp +  " " + eOp.getClass().getName() + " to the logical plan");
                        lp.add(sort);
                        log.debug("Added operator " + sort.getClass().getName() + " to the logical plan");

                        lp.connect(eOp, sort);
                        log.debug("Connected alias " + eOp.getAlias() + " operator " + eOp.getClass().getName() + " to operator " + sort.getClass().getName() + " the logical plan");
                } catch (PlanException planException) {
                        ParseException pe = new ParseException(planException.getMessage());
                        pe.initCause(planException);
                        {if (true) throw pe;}
                }

                log.trace("Exiting NestedSortOrArrange");
                {if (true) return sort;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator NestedDistinct(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedDistinct */
        SimpleNode jjtn000 = new SimpleNode(JJTNESTEDDISTINCT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        LogicalOperator eOp;
        log.trace("Entering NestedDistinct");
    try {
      jj_consume_token(DISTINCT);
      if (jj_2_20(2147483647)) {
        eOp = NestedProject(over, specs, lp, input);
      } else if (null != specs.get(getToken(1).image)) {
        t = jj_consume_token(IDENTIFIER);
                                                                          eOp = specs.get(t.image);
      } else if (jj_2_21(1)) {
        eOp = BaseEvalSpec(over, specs, lp, input);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                lp.add(eOp);
                log.debug("Added " + eOp.getAlias() + " to the logical plan");
                LogicalOperator distinct = new LODistinct(lp, new OperatorKey(scope, getNextId()));
                lp.add(distinct);
                log.debug("Added operator " + distinct.getClass().getName() + " to the logical plan");

                lp.connect(eOp, distinct);
                log.debug("Connected alias " + input.getAlias() + " operator " + input.getClass().getName() + " to operator " + distinct.getClass().getName() + " in the logical plan");

                log.trace("Exiting NestedDistinct");
                {if (true) return distinct;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator NestedLimit(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NestedLimit */
    SimpleNode jjtn000 = new SimpleNode(JJTNESTEDLIMIT);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);LogicalOperator eOp;
    Schema subSchema = null;
    Token t;
    log.trace("Entering LimitClause");
    try {
      jj_consume_token(LIMIT);
      if (jj_2_22(2147483647)) {
        eOp = NestedProject(over, specs, lp, input);
      } else if (null != specs.get(getToken(1).image)) {
        t = jj_consume_token(IDENTIFIER);
                                                                          eOp = specs.get(t.image);
      } else if (jj_2_23(1)) {
        eOp = BaseEvalSpec(over, specs, lp, input);
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
     subSchema = eOp.getSchema();
      t = jj_consume_token(INTEGER);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        lp.add(eOp);
        log.debug("Added " + eOp.getAlias() + " to the logical plan");
        long l = Integer.parseInt(t.image);
        LogicalOperator limit = new LOLimit(lp, new OperatorKey(scope, getNextId()), l);
        lp.add(limit);
        log.debug("Added operator " + limit.getClass().getName() + " to the logical plan");

        lp.connect(eOp, limit);
        log.debug("Connected the limit input to the limit");

        log.trace("Exiting NestedLimit");
        {if (true) return limit;}
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator GenerateStatement(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) GenerateStatement */
        SimpleNode jjtn000 = new SimpleNode(JJTGENERATESTATEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);LogicalOperator spec = null;
        Schema schema;
        setInsideGenerate(true);
        log.trace("Entering GenerateStatement");
    try {
      jj_consume_token(GENERATE);
      spec = FlattenedGenerateItemList(over,specs,lp,input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.debug("Connecting generate inputs");
                for(LogicalOperator op: getGenerateInputs()) {
                        lp.connect(op, spec);
                        log.debug("Connected operator: " + op + " to " + spec + " in logical plan " + lp);
                }
                log.trace("Exiting GenerateStatement");
                {if (true) return spec;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public LogicalOperator FlattenedGenerateItemList(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) FlattenedGenerateItemList */
        SimpleNode jjtn000 = new SimpleNode(JJTFLATTENEDGENERATEITEMLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ArrayList<LogicalPlan> generatePlans = new ArrayList<LogicalPlan>();
        ArrayList<Boolean> flattenList = new ArrayList<Boolean>();
        ArrayList<Schema> userDefinedSchemaList = new ArrayList<Schema>();
        ExpressionOperator item;
        LogicalPlan generatePlan;
        log.trace("Entering FlattenedGenerateItemList");
    try {
      item = FlattenedGenerateItem(over, specs, generatePlan = new LogicalPlan(), input, flattenList, userDefinedSchemaList);
                generatePlans.add(generatePlan);
      label_17:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[69] = jj_gen;
          break label_17;
        }
        jj_consume_token(83);
        item = FlattenedGenerateItem(over, specs, generatePlan = new LogicalPlan(), input, flattenList, userDefinedSchemaList);
                generatePlans.add(generatePlan);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                LogicalOperator generate = new LOGenerate(lp, new OperatorKey(scope, getNextId()), generatePlans, flattenList, userDefinedSchemaList);
                lp.add(generate);
                log.debug("Added operator " + generate.getClass().getName() + " to the logical plan");
                log.trace("Exiting FlattenedGenerateItemList");
                {if (true) return generate;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator FlattenedGenerateItem(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input, ArrayList<Boolean> flattenList, ArrayList<Schema> userDefinedSchemaList) throws ParseException {
 /*@bgen(jjtree) FlattenedGenerateItem */
        SimpleNode jjtn000 = new SimpleNode(JJTFLATTENEDGENERATEITEM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator item;
        Schema schema = null;
        Token t;
        Schema.FieldSchema fs = null;
        boolean flatten = false;
        log.trace("Entering FlattenedGenerateItem");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLATTEN:
        jj_consume_token(FLATTEN);
        jj_consume_token(80);
        item = InfixExpr(over,specs,lp,input);
        jj_consume_token(81);
                        flatten = true;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case AS:
          jj_consume_token(AS);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 80:
            jj_consume_token(80);
            schema = TupleSchema();
            jj_consume_token(81);
            break;
          case IDENTIFIER:
            fs = FieldSchema();
            break;
          default:
            jj_la1[70] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[71] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[74] = jj_gen;
        if (jj_2_25(1)) {
          if (jj_2_24(1)) {
            item = InfixExpr(over,specs,lp,input);
          } else {
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STAR:
              jj_consume_token(STAR);
                        LOProject project = new LOProject(lp, new OperatorKey(scope, getNextId()), input, -1);
                        project.setStar(true);
                        item = project;
                        lp.add(project);
            if(input instanceof ExpressionOperator) {
                            lp.add(input);
                            lp.connect(input, project);
            }
                        log.debug("FGItem: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
              break;
            default:
              jj_la1[72] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case AS:
            jj_consume_token(AS);
            fs = FieldSchema();
            break;
          default:
            jj_la1[73] = jj_gen;
            ;
          }
        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.debug("item: " + item.getClass().getName());
        if(null != fs) {
            schema = new Schema(fs);
        }
            flattenList.add(flatten);
        userDefinedSchemaList.add(schema);
                log.trace("Exiting FlattenedGenerateItem");
                {if (true) return item;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator InfixExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) InfixExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTINFIXEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator expr;
        log.trace("Entering InFixExpr");
    try {
      expr = AdditiveExpr(over,specs,lp,input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting InFixExpr");{if (true) return expr;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator AdditiveExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) AdditiveExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTADDITIVEEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        ExpressionOperator lhs, rhs, exprOp;
        log.trace("Entering AdditiveExpr");
    try {
      lhs = MultiplicativeExpr(over,specs,lp,input);
      label_18:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 89:
        case 90:
          ;
          break;
        default:
          jj_la1[75] = jj_gen;
          break label_18;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 89:
          t = jj_consume_token(89);
          break;
        case 90:
          t = jj_consume_token(90);
          break;
        default:
          jj_la1[76] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        rhs = MultiplicativeExpr(over,specs,lp,input);
                        assertAtomic(lhs,true);
                        assertAtomic(rhs,true);
                        if (t.image.equals("+")){
                                exprOp = new LOAdd(lp, new OperatorKey(scope, getNextId()));
                        }else{
                                exprOp = new LOSubtract(lp, new OperatorKey(scope, getNextId()));
                        }
                        lp.add(exprOp);
                        log.debug("AdditiveExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
                        lp.connect(lhs, exprOp);
                        log.debug("AdditiveExpr: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + exprOp + " logical plan " + lp);
                        lp.connect(rhs, exprOp);
                        log.debug("AdditiveExpr: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + exprOp + " logical plan " + lp);
                        lhs = exprOp;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting AdditiveExpr");
                {if (true) return lhs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator MultiplicativeExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) MultiplicativeExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTMULTIPLICATIVEEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t;
        ExpressionOperator lhs, rhs, exprOp;
        log.trace("Entering MultiplicativeExpr");
    try {
      lhs = CastExpr(over,specs,lp,input);
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
        case 91:
        case 92:
          ;
          break;
        default:
          jj_la1[77] = jj_gen;
          break label_19;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          t = jj_consume_token(STAR);
          break;
        case 91:
          t = jj_consume_token(91);
          break;
        case 92:
          t = jj_consume_token(92);
          break;
        default:
          jj_la1[78] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        rhs = CastExpr(over,specs,lp,input);
                        assertAtomic(lhs,true);
                        assertAtomic(rhs,true);
                        if (t.image.equals("*")){
                                exprOp = new LOMultiply(lp, new OperatorKey(scope, getNextId()));
                        }else if (t.image.equals("/")){
                                exprOp = new LODivide(lp, new OperatorKey(scope, getNextId()));
                        }else {
                                exprOp = new LOMod(lp, new OperatorKey(scope, getNextId()));
                        }
                        lp.add(exprOp);
                        log.debug("MultiplicativeExpr: Added operator " + exprOp.getClass().getName() + " " + exprOp + " to logical plan " + lp);
                        lp.connect(lhs, exprOp);
                        log.debug("MultiplicativeExpr: Connected operator " + lhs.getClass().getName() + " " + lhs+ " to " + exprOp + " logical plan " + lp);
                        lp.connect(rhs, exprOp);
                        log.debug("MultiplicativeExpr: Connected operator " + rhs.getClass().getName() + " " + rhs+ " to " + exprOp + " logical plan " + lp);
                        lhs = exprOp;
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        log.trace("Exiting MultiplicativeExpr");
                        {if (true) return lhs;}
    } catch (Throwable jjte000) {
                  if (jjtc000) {
                    jjtree.clearNodeScope(jjtn000);
                    jjtc000 = false;
                  } else {
                    jjtree.popNode();
                  }
                  if (jjte000 instanceof RuntimeException) {
                    {if (true) throw (RuntimeException)jjte000;}
                  }
                  if (jjte000 instanceof ParseException) {
                    {if (true) throw (ParseException)jjte000;}
                  }
                  {if (true) throw (Error)jjte000;}
    } finally {
                  if (jjtc000) {
                    jjtree.closeNodeScope(jjtn000, true);
                  }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator CastExpr(Schema over, Map<String, LogicalOperator> specs,LogicalPlan lp,LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) CastExpr */
    SimpleNode jjtn000 = new SimpleNode(JJTCASTEXPR);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);byte type = DataType.BYTEARRAY;
    Schema.FieldSchema fs = null;
    ExpressionOperator cast;
    ExpressionOperator exprOp;
    boolean castRequired = false;
    log.trace("Entering Cast");
    try {
      if (jj_2_26(2)) {
        jj_consume_token(80);
        fs = TypeFieldSchema();
                                             castRequired = true;
        jj_consume_token(81);
      } else {
        ;
      }
      exprOp = UnaryExpr(over, specs, lp, input);
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
        if(castRequired) {
            cast = new LOCast(lp, new OperatorKey(scope, getNextId()), fs.type);
            fs.alias = exprOp.getFieldSchema().alias;
            // unset the field schema computed above since it should
            // be recomputed later from the TypeCheckingVisitor
            // This is because operators might be added/removed
            // from the plan which might affect the field schema. So
            // the TypeCheckingVisitor would be right place to
            // compute the field schema
            exprOp.unsetFieldSchema();
            cast.setFieldSchema(fs);
            lp.add(cast);
                    log.debug("Added operator " + cast.getClass().getName() + " " + cast + " to logical plan " + lp);
            lp.connect(exprOp, cast);
                    log.debug("Connected operator " + exprOp.getClass().getName() + " " + exprOp + " to " + cast + " logical plan " + lp);
            log.trace("Exiting Cast");
            {if (true) return cast;}
        } else {
            log.trace("Exiting Cast");
            {if (true) return exprOp;}
        }
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        {if (true) throw (RuntimeException)jjte000;}
      }
      if (jjte000 instanceof ParseException) {
        {if (true) throw (ParseException)jjte000;}
      }
      {if (true) throw (Error)jjte000;}
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator UnaryExpr(Schema over,  Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) UnaryExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTUNARYEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator expr;
        log.trace("Entering UnaryExpr");
    try {
      if (jj_2_27(2147483647)) {
        expr = BaseEvalSpec(over,specs,lp,input);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 80:
          jj_consume_token(80);
          expr = InfixExpr(over,specs,lp,input);
          jj_consume_token(81);
          break;
        case 90:
          expr = NegativeExpr(over,specs,lp,input);
          break;
        default:
          jj_la1[79] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting UnaryExpr");{if (true) return expr;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator NegativeExpr(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) NegativeExpr */
        SimpleNode jjtn000 = new SimpleNode(JJTNEGATIVEEXPR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator c1;
        LogicalPlan exprPlan = new LogicalPlan();
        log.trace("Entering NegativeExpr");
    try {
      jj_consume_token(90);
      c1 = CastExpr(over,specs,lp,input);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator eOp = new LONegative(lp, new OperatorKey(scope, getNextId()));
                lp.add(eOp);
                log.debug("NegativeExpr: Added operator " + eOp.getClass().getName() + " " + eOp + " to logical plan " + lp);
                lp.connect(c1, eOp);
                log.trace("Exiting NegativeExpr");
                {if (true) return eOp;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator BaseEvalSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) BaseEvalSpec */
        SimpleNode jjtn000 = new SimpleNode(JJTBASEEVALSPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator item;
        ExpressionOperator projection;
        Schema subSchema = null;
        Token t;
    Object key = new Object();
        log.trace("Entering BaseEvalSpec");
    try {
      if (jj_2_29(2147483647)) {
        item = Const(lp);
      } else if (jj_2_30(1)) {
        if (jj_2_28(2147483647)) {
          item = EvalFuncSpec(over,specs,lp,input, FunctionType.EVALFUNC);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case GROUP:
          case IDENTIFIER:
          case DOLLARVAR:
            item = ColOrSpec(over,specs,lp,input);
            break;
          case 80:
            item = BinCond(over,specs,lp,input);
            break;
          default:
            jj_la1[80] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        label_20:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 88:
          case 93:
            ;
            break;
          default:
            jj_la1[81] = jj_gen;
            break label_20;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 88:
                        Schema.FieldSchema fs = item.getFieldSchema();
            if(null != fs) {
                            subSchema = fs.schema;
            }
                        log.debug("subSchema: " + subSchema);
            jj_consume_token(88);
            projection = BracketedSimpleProj(subSchema,lp,item);
                                assertAtomic(item,false);
                                item = projection;
            break;
          case 93:
            jj_consume_token(93);
            key = AtomDatum();
                        assertAtomic(item, false);
                        ExpressionOperator mapLookup = new LOMapLookup(lp, new OperatorKey(scope, getNextId()), key, DataType.BYTEARRAY, null);
                        lp.add(mapLookup);
                        log.debug("BaseEvalSpec: Added operator " + mapLookup.getClass().getName() + " " + mapLookup + " to logical plan " + lp);
                        lp.connect(item, mapLookup);
                        item = mapLookup;
                        log.debug("BaseEvalSpec: Connected operator " + item.getClass().getName() + " " + item+ " to " + mapLookup + " logical plan " + lp);
            break;
          default:
            jj_la1[82] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting BaseEvalSpec"); {if (true) return item;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator BinCond(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) BinCond */
        SimpleNode jjtn000 = new SimpleNode(JJTBINCOND);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator cond;
        ExpressionOperator ifTrue, ifFalse;
        LogicalPlan conditionPlan = new LogicalPlan();
        LogicalPlan truePlan = new LogicalPlan();
        LogicalPlan falsePlan = new LogicalPlan();
        log.trace("Entering BinCond");
    try {
      jj_consume_token(80);
      cond = PCond(over,specs,lp,input);
      jj_consume_token(94);
      ifTrue = InfixExpr(over,specs,lp,input);
      jj_consume_token(95);
      ifFalse = InfixExpr(over,specs,lp,input);
      jj_consume_token(81);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator bincond = new LOBinCond(lp, new OperatorKey(scope, getNextId()));
                lp.add(bincond);
                log.debug("BinCond: Added operator " + bincond.getClass().getName() + " " + bincond + " to logical plan " + lp);
                lp.connect(cond, bincond);
                lp.connect(ifTrue, bincond);
                lp.connect(ifFalse, bincond);
                log.trace("Exiting BinCond");
                {if (true) return bincond;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator EvalFuncSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input, byte funcType) throws ParseException {
 /*@bgen(jjtree) EvalFuncSpec */
        SimpleNode jjtn000 = new SimpleNode(JJTEVALFUNCSPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String funcName = null;
        FuncSpec funcSpec = null;
        String funcNameAlias = null;
    boolean registeredFunction = false;
        List<ExpressionOperator> args;
        ExpressionOperator userFunc;
    LOUserFunc userAliasFunc = null;
    Object func = null;
        log.trace("Entering EvalFuncSpec");
    try {
      if (jj_2_31(1)) {
        if (null != pigContext.getFuncSpecFromAlias(getToken(1).image)) {

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        funcNameAlias = QualifiedFunction();
                func = pigContext.instantiateFuncFromAlias(funcNameAlias);
                try{
            FunctionType.tryCasting(func, funcType);
                } catch (Exception e){
                        ParseException pe = new ParseException(e.getMessage());
                        pe.initCause(e);
                        {if (true) throw pe;}
                }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          func = EvalFunction(funcType);
          break;
        default:
          jj_la1[83] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(80);
      args = EvalArgs(over,specs,lp,input);
      jj_consume_token(81);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(null != func) {
            funcName = func.getClass().getName();
            if(null != funcNameAlias) {
                funcSpec = pigContext.getFuncSpecFromAlias(funcNameAlias);
            } else {
                funcSpec = new FuncSpec(funcName);
            }
            byte type = DataType.BYTEARRAY;
            switch(funcType) {
            case FunctionType.EVALFUNC:
                Type javaType = ((EvalFunc)func).getReturnType();
                type = DataType.findType(javaType);
                log.debug("Return type of UDF: " + DataType.findTypeName(type));
                log.debug("EvalFuncSpec: funcSpec: " + funcSpec);
                break;
            default:
                {if (true) throw new ParseException("Received an unknown function type: " + funcType);}
            }
                        userFunc = new LOUserFunc(lp, new OperatorKey(scope, getNextId()), funcSpec, type);
        } else {
            {if (true) throw new ParseException("Could not instantiate function: " + funcNameAlias);}
        }
                lp.add(userFunc);
                log.debug("EvalFuncSpec: Added operator " + userFunc.getClass().getName() + " " + userFunc + " to logical plan " + lp);
                for(ExpressionOperator exprOp: args) {
                        lp.connect(exprOp, userFunc);
                        log.debug("EvalFuncSpec: Connected operator " + exprOp.getClass().getName() + " " + exprOp+ " to " + userFunc + " logical plan " + lp);
                }
                log.trace("Exiting EvalFuncSpec");
                {if (true) return userFunc;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public FuncSpec NonEvalFuncSpec(byte funcType) throws ParseException {
 /*@bgen(jjtree) NonEvalFuncSpec */
        SimpleNode jjtn000 = new SimpleNode(JJTNONEVALFUNCSPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String functionName = null;
        FuncSpec funcSpec = null;
        String funcNameAlias = null;
    String functionArgs = null;
    Object func = null;
        log.trace("Entering NonEvalFuncSpec");
    try {
      if (jj_2_32(1)) {
        if (null != pigContext.getFuncSpecFromAlias(getToken(1).image)) {

        } else {
          jj_consume_token(-1);
          throw new ParseException();
        }
        funcNameAlias = QualifiedFunction();
                func = pigContext.instantiateFuncFromAlias(funcNameAlias);
                try{
            FunctionType.tryCasting(func, funcType);
                } catch (Exception e){
                        ParseException pe = new ParseException(e.getMessage());
                        pe.initCause(e);
                        {if (true) throw pe;}
                }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          functionName = QualifiedFunction();
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 80:
            jj_consume_token(80);
            functionArgs = StringList();
            jj_consume_token(81);
            break;
          default:
            jj_la1[84] = jj_gen;
            ;
          }
          break;
        default:
          jj_la1[85] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(null != func) {
            functionName = func.getClass().getName();
            if(null != funcNameAlias) {
                funcSpec = pigContext.getFuncSpecFromAlias(funcNameAlias);
            } else {
                funcSpec = new FuncSpec(functionName);
            }
        } else if (functionName != null) {
            funcSpec = new FuncSpec(functionName + (functionArgs == null? "(" + ")" : "(" + functionArgs + ")"));
        } else {
            {if (true) throw new ParseException("Could not instantiate function: " + funcNameAlias);}
        }
            switch(funcType) {
            case FunctionType.COMPARISONFUNC:
            case FunctionType.LOADFUNC:
            case FunctionType.STOREFUNC:
                func = pigContext.instantiateFuncFromSpec(funcSpec);
                        try{
                    FunctionType.tryCasting(func, funcType);
                        } catch (Exception e){
                                ParseException pe = new ParseException(e.getMessage());
                                pe.initCause(e);
                                {if (true) throw pe;}
                        }
                break;
            default:
                {if (true) throw new ParseException("Received an unknown function type: " + funcType);}
            }
                log.trace("Exiting NonEvalFuncSpec");
                {if (true) return funcSpec;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public List<ExpressionOperator> EvalArgs(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) EvalArgs */
        SimpleNode jjtn000 = new SimpleNode(JJTEVALARGS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ArrayList<ExpressionOperator> specList = new ArrayList<ExpressionOperator>();
        ExpressionOperator item;
        log.trace("Entering EvalArgs");
    try {
      if (jj_2_33(1)) {
        item = EvalArgsItem(over,specs,lp,input);
                                                 specList.add(item);
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[86] = jj_gen;
            break label_21;
          }
          jj_consume_token(83);
          item = EvalArgsItem(over,specs,lp,input);
                                                     specList.add(item);
        }
      } else {

      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting EvalArgs");
                {if (true) return specList;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator EvalArgsItem(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator input) throws ParseException {
 /*@bgen(jjtree) EvalArgsItem */
        SimpleNode jjtn000 = new SimpleNode(JJTEVALARGSITEM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator item;
        log.trace("Entering EvalArgsItem");
    try {
      if (jj_2_34(1)) {
        item = InfixExpr(over,specs,lp,input);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STAR:
          jj_consume_token(STAR);
                LOProject project = new LOProject(lp, new OperatorKey(scope, getNextId()), input, -1);
                project.setStar(true);
                item = project;
                lp.add(project);
        if(input instanceof ExpressionOperator) {
                    lp.add(input);
                    lp.connect(input, project);
        }
                log.debug("EvalArgsItem: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
          break;
        default:
          jj_la1[87] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting EvalArgsItem");{if (true) return item;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public byte Type() throws ParseException {
 /*@bgen(jjtree) Type */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);log.trace("Entering Type");
        byte type;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case LONG:
      case FLOAT:
      case DOUBLE:
      case CHARARRAY:
      case BYTEARRAY:
        type = BasicType();
        break;
      case BAG:
      case TUPLE:
      case MAP:
        type = CompositeType();
        break;
      default:
        jj_la1[88] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
        log.trace("Exiting Type");
        {if (true) return type;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public byte CompositeType() throws ParseException {
 /*@bgen(jjtree) CompositeType */
        SimpleNode jjtn000 = new SimpleNode(JJTCOMPOSITETYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);log.trace("Entering CompositeType");
        Token t = null;
        byte type;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MAP:
        t = jj_consume_token(MAP);
        break;
      case BAG:
        t = jj_consume_token(BAG);
        break;
      case TUPLE:
        t = jj_consume_token(TUPLE);
        break;
      default:
        jj_la1[89] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
        log.debug("t: " + t + " type: " + nameToTypeMap.get(t.image.toUpperCase()));
        type = nameToTypeMap.get(t.image.toUpperCase());
        log.trace("Exiting CompositeType");
        {if (true) return type;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public byte BasicType() throws ParseException {
 /*@bgen(jjtree) BasicType */
        SimpleNode jjtn000 = new SimpleNode(JJTBASICTYPE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);log.trace("Entering BasicType");
        Token t = null;
        byte type;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
        t = jj_consume_token(INT);
        break;
      case LONG:
        t = jj_consume_token(LONG);
        break;
      case FLOAT:
        t = jj_consume_token(FLOAT);
        break;
      case DOUBLE:
        t = jj_consume_token(DOUBLE);
        break;
      case CHARARRAY:
        t = jj_consume_token(CHARARRAY);
        break;
      case BYTEARRAY:
        t = jj_consume_token(BYTEARRAY);
        break;
      default:
        jj_la1[90] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
    String typeName = t.image;
        log.debug(" nameToTypeMap: " + nameToTypeMap);
        log.debug("t: " + t + " type: " + nameToTypeMap.get(typeName.toUpperCase()));
    if(typeName.equalsIgnoreCase("int")) {
        typeName = "integer";
    }
        type = nameToTypeMap.get(typeName.toUpperCase());
        log.trace("Exiting BasicType");
        {if (true) return type;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema FieldSchema() throws ParseException {
 /*@bgen(jjtree) FieldSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTFIELDSCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        Schema item = null;
        Schema.FieldSchema fs = null;
        log.trace("Entering FieldSchema");
    try {
      if (jj_2_35(2147483647)) {
        fs = SchemaTuple();
      } else if (jj_2_36(2147483647)) {
        fs = SchemaBag();
      } else if (jj_2_37(2147483647)) {
        fs = SchemaMap();
      } else if (jj_2_38(2147483647)) {
        fs = AtomSchema();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting FieldSchema");{if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema AtomSchema() throws ParseException {
 /*@bgen(jjtree) AtomSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTATOMSCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        byte type = DataType.NULL;
        Schema.FieldSchema fs;
        log.trace("Entering AtomSchema");
    try {
      t1 = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 95:
        jj_consume_token(95);
        type = BasicType();
        break;
      default:
        jj_la1[91] = jj_gen;
        ;
      }
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                        if(null != t1) {
                                log.debug("AtomSchema: " + t1.image);
                                fs = new Schema.FieldSchema(t1.image, type);
                        } else {
                                fs = new Schema.FieldSchema(null, type);
                        }

                        log.trace("Exiting AtomSchema");
                        {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema SchemaMap() throws ParseException {
 /*@bgen(jjtree) SchemaMap */
        SimpleNode jjtn000 = new SimpleNode(JJTSCHEMAMAP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema.FieldSchema fs;
        log.trace("Entering SchemaMap");
    try {
      t1 = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 95:
        if (jj_2_39(2)) {
          jj_consume_token(95);
          jj_consume_token(MAP);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 95:
            jj_consume_token(95);
            break;
          default:
            jj_la1[92] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
      jj_consume_token(96);
      jj_consume_token(97);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if (null != t1) {
                        log.debug("MAP alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, DataType.MAP);
                } else {
                        fs = new Schema.FieldSchema(null, DataType.MAP);
                }
                log.trace("Exiting SchemaMap");
                {if (true) return fs;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema SchemaTuple() throws ParseException {
 /*@bgen(jjtree) SchemaTuple */
        SimpleNode jjtn000 = new SimpleNode(JJTSCHEMATUPLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema s;
        Schema.FieldSchema fs;
        log.trace("Entering SchemaTuple");
    try {
      t1 = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 95:
        if (jj_2_40(2)) {
          jj_consume_token(95);
          jj_consume_token(TUPLE);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 95:
            jj_consume_token(95);
            break;
          default:
            jj_la1[94] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[95] = jj_gen;
        ;
      }
      jj_consume_token(80);
      s = TupleSchema();
      jj_consume_token(81);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if (null != t1) {
                        log.debug("TUPLE alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, s, DataType.TUPLE);
                } else {
                        fs = new Schema.FieldSchema(null, s, DataType.TUPLE);
                }
                log.trace("Exiting SchemaTuple");
                {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema SchemaBag() throws ParseException {
 /*@bgen(jjtree) SchemaBag */
        SimpleNode jjtn000 = new SimpleNode(JJTSCHEMABAG);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema s;
        Schema.FieldSchema fs;
        log.trace("Entering SchemaBag");
    try {
      t1 = jj_consume_token(IDENTIFIER);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 95:
        if (jj_2_41(2)) {
          jj_consume_token(95);
          jj_consume_token(BAG);
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 95:
            jj_consume_token(95);
            break;
          default:
            jj_la1[96] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        break;
      default:
        jj_la1[97] = jj_gen;
        ;
      }
      jj_consume_token(86);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        fs = SchemaTuple();
        break;
      default:
        jj_la1[98] = jj_gen;

                                                                                           fs = new Schema.FieldSchema(null, new Schema());
      }
      jj_consume_token(87);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        s = new Schema(fs);
        // since this schema has tuple field schema which internally
        // has a list of field schemas for the actual items in the bag
        // an access to any field in the bag is a  two level access
        s.setTwoLevelAccessRequired(true);
                if (null != t1) {
                        log.debug("BAG alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, s, DataType.BAG);
                } else {
                        fs = new Schema.FieldSchema(null, s, DataType.BAG);
                }
                log.trace("Exiting SchemaBag");
                {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema TupleSchema() throws ParseException {
 /*@bgen(jjtree) TupleSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTTUPLESCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Schema item = null;
        Schema list = new Schema();
        Schema.FieldSchema fs = null;
        log.trace("Entering TupleSchema");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        fs = FieldSchema();
                                    log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);
        label_22:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[99] = jj_gen;
            break label_22;
          }
          jj_consume_token(83);
          fs = FieldSchema();
                                          log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);
        }
        break;
      default:
        jj_la1[100] = jj_gen;

                    list = null;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.debug("Printing list in TupleSchema" + list); log.trace("Exiting TupleSchema");{if (true) return list;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema TypeFieldSchema() throws ParseException {
 /*@bgen(jjtree) TypeFieldSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPEFIELDSCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        Schema item = null;
        Schema.FieldSchema fs = null;
        log.trace("Entering TypeFieldSchema");
    try {
      if (jj_2_42(2147483647)) {
        fs = TypeSchemaTuple();
      } else if (jj_2_43(2147483647)) {
        fs = TypeSchemaBag();
      } else if (jj_2_44(2147483647)) {
        fs = TypeSchemaMap();
      } else if (jj_2_45(2147483647)) {
        fs = TypeAtomSchema();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting TypeFieldSchema");{if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema TypeAtomSchema() throws ParseException {
 /*@bgen(jjtree) TypeAtomSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPEATOMSCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);byte type = DataType.BYTEARRAY;
        Schema.FieldSchema fs;
        log.trace("Entering TypeAtomSchema");
    try {
      type = BasicType();
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
            if(type == DataType.BYTEARRAY) {
                int errCode = 1051;
                String msg = "Cannot cast to bytearray";
                FrontendException fee = new FrontendException(msg, errCode, PigException.INPUT);
                ParseException pe = new ParseException(msg);
                pe.initCause(fee);
                {if (true) throw pe;}
            }
                        fs = new Schema.FieldSchema(null, type);

                        log.trace("Exiting TypeAtomSchema");
                        {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema TypeSchemaMap() throws ParseException {
 /*@bgen(jjtree) TypeSchemaMap */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPESCHEMAMAP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema.FieldSchema fs;
        log.trace("Entering TypeSchemaMap");
    try {
      jj_consume_token(MAP);
      jj_consume_token(96);
      jj_consume_token(97);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if (null != t1) {
                        log.debug("MAP alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, DataType.MAP);
                } else {
                        fs = new Schema.FieldSchema(null, DataType.MAP);
                }
                log.trace("Exiting TypeSchemaMap");
                {if (true) return fs;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema TypeSchemaTuple() throws ParseException {
 /*@bgen(jjtree) TypeSchemaTuple */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPESCHEMATUPLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema s;
        Schema.FieldSchema fs;
        log.trace("Entering TypeSchemaTuple");
    try {
      jj_consume_token(TUPLE);
      jj_consume_token(80);
      s = TypeTupleSchema();
      jj_consume_token(81);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if (null != t1) {
                        log.debug("TUPLE alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, s, DataType.TUPLE);
                } else {
                        fs = new Schema.FieldSchema(null, s, DataType.TUPLE);
                }
                log.trace("Exiting TypeSchemaTuple");
                {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema.FieldSchema TypeSchemaBag() throws ParseException {
 /*@bgen(jjtree) TypeSchemaBag */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPESCHEMABAG);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1 = null;
        Schema s;
        Schema.FieldSchema fs;
        log.trace("Entering TypeSchemaBag");
    try {
      jj_consume_token(BAG);
      jj_consume_token(86);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TUPLE:
        fs = TypeSchemaTuple();
        break;
      default:
        jj_la1[101] = jj_gen;

                                                  fs = new Schema.FieldSchema(null, new Schema());
      }
      jj_consume_token(87);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        s = new Schema(fs);
        // since this schema has tuple field schema which internally
        // has a list of field schemas for the actual items in the bag
        // an access to any field in the bag is a  two level access
        s.setTwoLevelAccessRequired(true);
                if (null != t1) {
                        log.debug("BAG alias " + t1.image);
                        fs = new Schema.FieldSchema(t1.image, s, DataType.BAG);
                } else {
                        fs = new Schema.FieldSchema(null, s, DataType.BAG);
                }
                log.trace("Exiting TypeSchemaBag");
                {if (true) return fs;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Schema TypeTupleSchema() throws ParseException {
 /*@bgen(jjtree) TypeTupleSchema */
        SimpleNode jjtn000 = new SimpleNode(JJTTYPETUPLESCHEMA);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Schema item = null;
        Schema list = new Schema();
        Schema.FieldSchema fs = null;
        log.trace("Entering TypeTupleSchema");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INT:
      case LONG:
      case FLOAT:
      case DOUBLE:
      case CHARARRAY:
      case BYTEARRAY:
      case BAG:
      case TUPLE:
      case MAP:
        fs = TypeFieldSchema();
                                        log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);
        label_23:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 83:
            ;
            break;
          default:
            jj_la1[102] = jj_gen;
            break label_23;
          }
          jj_consume_token(83);
          fs = TypeFieldSchema();
                                              log.debug("Adding " + fs.alias + " to the list: " + list);list.add(fs);
        }
        break;
      default:
        jj_la1[103] = jj_gen;

                    list = null;
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.debug("Printing list in TypeTupleSchema: " + list); log.trace("Exiting TypeTupleSchema");{if (true) return list;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

// These the simple non-terminals that are shared across many
  final public Object EvalFunction(byte funcType) throws ParseException {
 /*@bgen(jjtree) EvalFunction */
        SimpleNode jjtn000 = new SimpleNode(JJTEVALFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);String funcName;
    Object func = null;
        log.trace("Entering EvalFunction");
    try {
      funcName = QualifiedFunction();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        func = pigContext.instantiateFuncFromAlias(funcName);
                try{
            FunctionType.tryCasting(func, funcType);
                }catch (Exception e){
                        ParseException pe = new ParseException(e.getMessage());
                        pe.initCause(e);
                        {if (true) throw pe;}
                }
                log.trace("Exiting EvalFunction");

                {if (true) return func;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

/**
 * Bug 831620 - '$' support
 */
  final public void ClassName() throws ParseException {
    jj_consume_token(IDENTIFIER);
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 88:
      case 98:
        ;
        break;
      default:
        jj_la1[104] = jj_gen;
        break label_24;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 88:
        jj_consume_token(88);
        jj_consume_token(IDENTIFIER);
        break;
      case 98:
        jj_consume_token(98);
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

/**
 * Bug 831620 - '$' support
 */
  final public String QualifiedFunction() throws ParseException {
                                    Token t1;StringBuffer s=new StringBuffer(); log.trace("Entering QualifiedFunction");
    t1 = jj_consume_token(IDENTIFIER);
                            s.append(t1.image);
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 88:
      case 98:
        ;
        break;
      default:
        jj_la1[106] = jj_gen;
        break label_25;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 88:
        jj_consume_token(88);
        t1 = IdentifierOrReserved();
                                          s.append("." + t1.image);
        break;
      case 98:
        jj_consume_token(98);
        t1 = IdentifierOrReserved();
                                          s.append("$" + t1.image);
        break;
      default:
        jj_la1[107] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
                log.debug("QualifiedFunction: " + s.toString());
                log.trace("Exiting QualifiedFunction");
                {if (true) return s.toString();}
    throw new Error("Missing return statement in function");
  }

// If there is one time it may not be bracketed, but if multiple, they must be bracketed
  final public ExpressionOperator BracketedSimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp) throws ParseException {
 /*@bgen(jjtree) BracketedSimpleProj */
        SimpleNode jjtn000 = new SimpleNode(JJTBRACKETEDSIMPLEPROJ);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator es;
        int i;
        ExpressionOperator spec = null;
        log.trace("Entering BracketedSimpleProj");
        log.debug("eOp: " + eOp);
        bracketed = true;
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP:
      case IDENTIFIER:
      case DOLLARVAR:
        spec = ColOrSpec(over,null,lp,eOp);
        break;
      case 80:
        jj_consume_token(80);
        spec = SimpleProj(over,lp,eOp);
        jj_consume_token(81);
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
         log.trace("Exiting BracketedSimpleProj");bracketed=false; {if (true) return spec;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator SimpleProj(Schema over, LogicalPlan lp, LogicalOperator eOp) throws ParseException {
 /*@bgen(jjtree) SimpleProj */
        SimpleNode jjtn000 = new SimpleNode(JJTSIMPLEPROJ);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);int i;
        ArrayList<Integer> colList = new ArrayList<Integer>();
        log.trace("Entering SimpleProj");
    try {
      i = ColNameOrNum(over);
                                colList.add(i);
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[109] = jj_gen;
          break label_26;
        }
        jj_consume_token(83);
        i = ColNameOrNum(over);
                                             colList.add(i);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, colList);
                lp.add(project);
                log.debug("SimpleProj: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
        if(eOp instanceof ExpressionOperator) {
                    lp.add(eOp);
                    lp.connect(eOp, project);
        }
                log.trace("Exiting SimpleProj");
                {if (true) return project;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public DataBag Bag() throws ParseException {
 /*@bgen(jjtree) Bag */
        SimpleNode jjtn000 = new SimpleNode(JJTBAG);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);byte type = DataType.BYTEARRAY;
        BagFactory bagFactory = BagFactory.getInstance();
    DataBag bag = bagFactory.newDefaultBag();
    Tuple t = null;
    log.trace("Entering bag");
    try {
      jj_consume_token(80);
      t = Tuple();
                   bag.add(t);
      jj_consume_token(81);
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[110] = jj_gen;
          break label_27;
        }
        jj_consume_token(83);
        jj_consume_token(80);
        t = Tuple();
                                                          bag.add(t);
        jj_consume_token(81);
      }
   jjtree.closeNodeScope(jjtn000, true);
   jjtc000 = false;
    log.trace("Exiting bag");
    {if (true) return bag;}
    } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     {if (true) throw (RuntimeException)jjte000;}
   }
   if (jjte000 instanceof ParseException) {
     {if (true) throw (ParseException)jjte000;}
   }
   {if (true) throw (Error)jjte000;}
    } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
    }
    throw new Error("Missing return statement in function");
  }

  final public Tuple Tuple() throws ParseException {
 /*@bgen(jjtree) Tuple */
        SimpleNode jjtn000 = new SimpleNode(JJTTUPLE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);byte type = DataType.BYTEARRAY;
        Object obj = null;
        TupleFactory tupleFactory = TupleFactory.getInstance();
        ArrayList<Object> objList = new ArrayList<Object>();
        log.trace("Entering Tuple");
    try {
      obj = Datum();
                               log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);
      label_28:
      while (true) {
        if (jj_2_46(2)) {
          ;
        } else {
          break label_28;
        }
        jj_consume_token(83);
        obj = Datum();
                                                          log.debug("Adding " + obj + " to the list: " + objList); objList.add(obj);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                Tuple tuple = tupleFactory.newTuple(objList);
                log.trace("Exiting Tuple");
                {if (true) return tuple;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Map<Object, Object> Map() throws ParseException {
 /*@bgen(jjtree) Map */
        SimpleNode jjtn000 = new SimpleNode(JJTMAP);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Map<Object, Object> keyValues = new HashMap<Object, Object>();
        log.trace("Entering Map");
    try {
      KeyValuePair(keyValues);
      label_29:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 83:
          ;
          break;
        default:
          jj_la1[111] = jj_gen;
          break label_29;
        }
        jj_consume_token(83);
        KeyValuePair(keyValues);
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting Map");
                {if (true) return keyValues;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public void KeyValuePair(Map<Object, Object> keyValues) throws ParseException {
 /*@bgen(jjtree) KeyValuePair */
        SimpleNode jjtn000 = new SimpleNode(JJTKEYVALUEPAIR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Object key = null;
        Object value = null;
        log.trace("Entering KeyValuePair");
    try {
      key = AtomDatum();
      jj_consume_token(93);
      value = Datum();
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                if(key == null)
                    {if (true) throw new ParseException("key in a map cannot be null (provided input has '"+ key + "#" + value + "')");}
                keyValues.put(key, value);
                log.trace("Exiting KeyValuePair");
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
  }

  final public Object AtomDatum() throws ParseException {
 /*@bgen(jjtree) AtomDatum */
    SimpleNode jjtn000 = new SimpleNode(JJTATOMDATUM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Object obj = null;
        Token t;
        log.trace("Entering AtomDatum");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        t = jj_consume_token(INTEGER);
                       obj = new Integer(Integer.parseInt(t.image));
        break;
      case LONGINTEGER:
        t = jj_consume_token(LONGINTEGER);
        String num = t.image.substring(0, t.image.length() - 1);
        obj = new Long(Long.parseLong(num));
        break;
      case FLOATNUMBER:
        t = jj_consume_token(FLOATNUMBER);
                           obj = new Float(Float.parseFloat(t.image));
        break;
      case DOUBLENUMBER:
        t = jj_consume_token(DOUBLENUMBER);
                            obj = new Double(Double.parseDouble(t.image));
        break;
      case QUOTEDSTRING:
        t = jj_consume_token(QUOTEDSTRING);
                            obj = unquote(t.image);
        break;
      case NULL:
        t = jj_consume_token(NULL);
                obj = null;
        break;
      default:
        jj_la1[112] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        log.debug("Number: " + t.image + " obj type: " + DataType.findTypeName(DataType.findType(obj)));
                log.trace("Exiting AtomDatum");
                {if (true) return obj;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public Object Datum() throws ParseException {
 /*@bgen(jjtree) Datum */
    SimpleNode jjtn000 = new SimpleNode(JJTDATUM);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);Object obj = null;
        log.trace("Entering Datum");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 96:
        jj_consume_token(96);
        obj = Map();
        jj_consume_token(97);
        break;
      case 86:
        jj_consume_token(86);
        obj = Bag();
        jj_consume_token(87);
        break;
      case 80:
        jj_consume_token(80);
        obj = Tuple();
        jj_consume_token(81);
        break;
      case NULL:
      case INTEGER:
      case LONGINTEGER:
      case DOUBLENUMBER:
      case FLOATNUMBER:
      case QUOTEDSTRING:
        obj = AtomDatum();
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting Datum");
                {if (true) return obj;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator Const(LogicalPlan lp) throws ParseException {
 /*@bgen(jjtree) Const */
        SimpleNode jjtn000 = new SimpleNode(JJTCONST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        String s;
        Object obj = null;
        byte type = DataType.BYTEARRAY;
        log.trace("Entering Const");
    try {
      if (jj_2_47(2147483647)) {
        obj = AtomDatum();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case NULL:
        case INTEGER:
        case LONGINTEGER:
        case DOUBLENUMBER:
        case FLOATNUMBER:
        case QUOTEDSTRING:
        case 80:
        case 86:
        case 96:
          obj = Datum();
          break;
        default:
          jj_la1[114] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                ExpressionOperator lConst = new LOConst(lp, new OperatorKey(scope, getNextId()), obj);
        type = DataType.findType(obj);
        log.debug("type: " + DataType.findTypeName(type));
                lConst.setType(type);
                lp.add(lConst);
                log.debug("Const: Added operator " + lConst.getClass().getName() + " " + lConst + " to logical plan " + lp);
                log.trace("Exiting Const");
                {if (true) return lConst;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator ColOrSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) throws ParseException {
 /*@bgen(jjtree) ColOrSpec */
        SimpleNode jjtn000 = new SimpleNode(JJTCOLORSPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);ExpressionOperator spec;
        log.trace("Entering ColOrSpec");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOLLARVAR:
        spec = DollarVar(over, specs, lp, eOp);
        break;
      case GROUP:
      case IDENTIFIER:
        spec = AliasFieldOrSpec(over, specs, lp, eOp);
        break;
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.trace("Exiting ColOrSpec");
                {if (true) return spec;}
    } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            {if (true) throw (RuntimeException)jjte000;}
          }
          if (jjte000 instanceof ParseException) {
            {if (true) throw (ParseException)jjte000;}
          }
          {if (true) throw (Error)jjte000;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator DollarVar(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) throws ParseException {
 /*@bgen(jjtree) DollarVar */
        SimpleNode jjtn000 = new SimpleNode(JJTDOLLARVAR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        log.trace("Entering DollarVar");
    try {
      t1 = jj_consume_token(DOLLARVAR);
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        int colNum = undollar(t1.image);
                log.debug("Token: " + t1.image);
        if(null != over) {
            if(colNum >= over.size()) {
                {if (true) throw new ParseException("Out of bound access. Trying to access non-existent column: " + colNum + ". Schema " + over + " has " + over.size() + " column(s).");}
            }
        }
                ExpressionOperator project = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, undollar(t1.image));
                try {
                        log.debug("eOp: " + eOp.getClass().getName() + " " + eOp);
                        lp.add(project);
                        log.debug("DollarVar: Added operator " + project.getClass().getName() + " " + project + " to logical plan " + lp);
            if((eOp instanceof ExpressionOperator) && (bracketed)) {
                            lp.add(eOp);
                            lp.connect(eOp, project);
            }
                } catch (Exception planException) {
                        ParseException pe = new ParseException(planException.getMessage());
                        pe.initCause(planException);
                        {if (true) throw pe;}
                }
                log.trace("Exiting DollarVar");
                {if (true) return project;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  final public ExpressionOperator AliasFieldOrSpec(Schema over, Map<String, LogicalOperator> specs, LogicalPlan lp, LogicalOperator eOp) throws ParseException {
 /*@bgen(jjtree) AliasFieldOrSpec */
        SimpleNode jjtn000 = new SimpleNode(JJTALIASFIELDORSPEC);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);Token t1;
        LogicalPlan projectInputPlan = new LogicalPlan();
        log.trace("Entering AliasFieldOrSpec");
    try {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case GROUP:
        t1 = jj_consume_token(GROUP);
        break;
      case IDENTIFIER:
        t1 = jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[116] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
                log.debug("Token: " + t1.image);
                if(null != eOp) log.debug("eOp: " + eOp.getClass().getName());
                int i;
                ExpressionOperator item = null;
                if (specs!=null) {
                        log.debug("specs != null");
                        LogicalOperator op = specs.get(t1.image);
                        if(null != op) {
                                log.debug("Alias: " + op.getAlias());

                if((op instanceof ExpressionOperator) && insideGenerate()) {
                    item = (ExpressionOperator)op;
                } else {
                    item = new LOProject(lp, new OperatorKey(scope, getNextId()), op, -1);
                    ((LOProject)item).setStar(true);
                    // This project is Project(*) introduced after a relational operator
                    // to supply a bag as output (as an expression). This project is either
                    // providing the bag as input to a successor expression operator or is 
                    // itself the leaf in a inner plan
                    // If the predecessor relational operator sends an EOP
                    // then send an empty bag first to signal "empty" output
                    // and then send an EOP

                    // A query like:
                    // a = load 'baginp.txt' as (b:bag{t:tuple()}); b = foreach a generate $0; dump b;
                    /// will go through a regular project (without the following flag)
                    ((LOProject)item).setSendEmptyBagOnEOP(true);
                    log.debug("Set star to true");
                    item.setAlias(t1.image);
                }

                                if(insideGenerate()) {
                                        log.debug("AliasFieldOrSpec: Inside generate");
                                        addGenerateInput(op);
                                }
                                try {
                                        lp.add(item);
                                        log.debug("AliasFieldOrSpec: Added operator " + item.getClass().getName() + " " + item + " to logical plan " + lp);
                    if((op instanceof ExpressionOperator) && !insideGenerate()) {
                                            lp.add(op);
                                            lp.connect(op, item);
                    }
                                } catch (Exception planException) {
                                        ParseException pe = new ParseException(planException.getMessage());
                                        pe.initCause(planException);
                                        {if (true) throw pe;}
                                }
                        }
                }

                if (item == null){
                        log.debug("item == null");
                        if (null == over) log.debug("over is null");
            try {
                            if ( over == null ||  (i = over.getPosition(t1.image)) == -1) {
                                    log.debug("Invalid alias: " + t1.image + " in " + over);
                                    if(null != over) {
                                            log.debug("Printing out the aliases in the schema");
                                            over.printAliases();
                                    }
                                    {if (true) throw new ParseException("Invalid alias: " + t1.image + " in " + over);}
                            }
            } catch (FrontendException fee) {
                ParseException pe = new ParseException(fee.getMessage());
                pe.initCause(fee);
                {if (true) throw pe;}
            }
                        log.debug("Position of " + t1.image + " = " + i);
                        if(null != over) {
                                log.debug("Printing out the aliases in the schema");
                                over.printAliases();
                        }
                        item = new LOProject(lp, new OperatorKey(scope, getNextId()), eOp, i);
                        item.setAlias(t1.image);
                        try {
                                lp.add(item);
                                log.debug("AliasFieldOrSpec: Added operator " + item.getClass().getName() + " " + item + " to logical plan " + lp);
                if((eOp instanceof ExpressionOperator) && (bracketed)) {
                                    lp.add(eOp);
                                    lp.connect(eOp, item);
                }
                        } catch (Exception planException) {
                                ParseException parseException = new ParseException(planException.getMessage());
                                parseException.initCause(planException);
                                {if (true) throw parseException;}
                        }
                }

                log.trace("Exiting AliasFieldOrSpec");
                {if (true) return item;}
    } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_28(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(27, xla); }
  }

  private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_29(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(28, xla); }
  }

  private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_30(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(29, xla); }
  }

  private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_31(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(30, xla); }
  }

  private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_32(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(31, xla); }
  }

  private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_33(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(32, xla); }
  }

  private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_34(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(33, xla); }
  }

  private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_35(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(34, xla); }
  }

  private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_36(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(35, xla); }
  }

  private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_37(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(36, xla); }
  }

  private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_38(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(37, xla); }
  }

  private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_39(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(38, xla); }
  }

  private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_40(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(39, xla); }
  }

  private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_41(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(40, xla); }
  }

  private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_42(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(41, xla); }
  }

  private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_43(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(42, xla); }
  }

  private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_44(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(43, xla); }
  }

  private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_45(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(44, xla); }
  }

  private boolean jj_2_46(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_46(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(45, xla); }
  }

  private boolean jj_2_47(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_47(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(46, xla); }
  }

  private boolean jj_3R_38() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    if (jj_scan_token(88)) return true;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    }
    return false;
  }

  private boolean jj_3R_151() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_152()) return true;
    if (jj_scan_token(81)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_162()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_109() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(89)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    if (jj_3R_108()) return true;
    return false;
  }

  private boolean jj_3R_166() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_65() {
    if (jj_3R_108()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_109()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_165() {
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_166()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_14() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_104() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3_15() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3_13() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_148() {
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_33() {
    if (jj_3R_65()) return true;
    return false;
  }

  private boolean jj_3R_83() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3_34() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_159() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_165()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_49() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_34()) {
    jj_scanpos = xsp;
    if (jj_3R_83()) return true;
    }
    return false;
  }

  private boolean jj_3R_158() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_149() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) return true;
    }
    return false;
  }

  private boolean jj_3R_130() {
    if (jj_scan_token(AS)) return true;
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_111() {
    return false;
  }

  private boolean jj_3_7() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(FILTEROP)) return true;
    return false;
  }

  private boolean jj_3R_128() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_49()) return true;
    return false;
  }

  private boolean jj_3_6() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3_33() {
    if (jj_3R_49()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_128()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_33()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) return true;
    }
    return false;
  }

  private boolean jj_3R_146() {
    if (jj_scan_token(98)) return true;
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_145() {
    if (jj_scan_token(88)) return true;
    if (jj_3R_157()) return true;
    return false;
  }

  private boolean jj_3R_127() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) return true;
    }
    return false;
  }

  private boolean jj_3R_140() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(FILTEROP)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3R_47() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_127()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_147() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_31()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_139() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_40() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  private boolean jj_3R_129() {
    if (jj_scan_token(AS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    return false;
  }

  private boolean jj_3_24() {
    if (jj_3R_33()) return true;
    return false;
  }

  private boolean jj_3_25() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_24()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_130()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_69() {
    if (jj_scan_token(FLATTEN)) return true;
    if (jj_scan_token(80)) return true;
    if (jj_3R_33()) return true;
    if (jj_scan_token(81)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_129()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3R_37() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3_25()) return true;
    }
    return false;
  }

  private boolean jj_3R_124() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3R_110() {
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_138() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_41()) return true;
    return false;
  }

  private boolean jj_3R_118() {
    return false;
  }

  private boolean jj_3R_92() {
    return false;
  }

  private boolean jj_3R_132() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_106() {
    if (jj_3R_123()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_124()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_131() {
    if (jj_scan_token(DOLLARVAR)) return true;
    return false;
  }

  private boolean jj_3R_112() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) return true;
    }
    return false;
  }

  private boolean jj_3R_157() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(10)) {
    jj_scanpos = xsp;
    if (jj_scan_token(11)) {
    jj_scanpos = xsp;
    if (jj_scan_token(12)) {
    jj_scanpos = xsp;
    if (jj_scan_token(13)) {
    jj_scanpos = xsp;
    if (jj_scan_token(14)) {
    jj_scanpos = xsp;
    if (jj_scan_token(15)) {
    jj_scanpos = xsp;
    if (jj_scan_token(16)) {
    jj_scanpos = xsp;
    if (jj_scan_token(17)) {
    jj_scanpos = xsp;
    if (jj_scan_token(18)) {
    jj_scanpos = xsp;
    if (jj_scan_token(19)) {
    jj_scanpos = xsp;
    if (jj_scan_token(20)) {
    jj_scanpos = xsp;
    if (jj_scan_token(21)) {
    jj_scanpos = xsp;
    if (jj_scan_token(22)) {
    jj_scanpos = xsp;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) {
    jj_scanpos = xsp;
    if (jj_scan_token(25)) {
    jj_scanpos = xsp;
    if (jj_scan_token(26)) {
    jj_scanpos = xsp;
    if (jj_scan_token(27)) {
    jj_scanpos = xsp;
    if (jj_scan_token(28)) {
    jj_scanpos = xsp;
    if (jj_scan_token(29)) {
    jj_scanpos = xsp;
    if (jj_scan_token(30)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) {
    jj_scanpos = xsp;
    if (jj_scan_token(33)) {
    jj_scanpos = xsp;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(35)) {
    jj_scanpos = xsp;
    if (jj_scan_token(36)) {
    jj_scanpos = xsp;
    if (jj_scan_token(37)) {
    jj_scanpos = xsp;
    if (jj_scan_token(38)) {
    jj_scanpos = xsp;
    if (jj_scan_token(39)) {
    jj_scanpos = xsp;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) {
    jj_scanpos = xsp;
    if (jj_scan_token(42)) {
    jj_scanpos = xsp;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) {
    jj_scanpos = xsp;
    if (jj_scan_token(49)) {
    jj_scanpos = xsp;
    if (jj_scan_token(50)) {
    jj_scanpos = xsp;
    if (jj_scan_token(51)) {
    jj_scanpos = xsp;
    if (jj_scan_token(52)) {
    jj_scanpos = xsp;
    if (jj_scan_token(53)) {
    jj_scanpos = xsp;
    if (jj_scan_token(54)) {
    jj_scanpos = xsp;
    if (jj_scan_token(55)) {
    jj_scanpos = xsp;
    if (jj_scan_token(56)) {
    jj_scanpos = xsp;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) {
    jj_scanpos = xsp;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(60)) {
    jj_scanpos = xsp;
    if (jj_scan_token(61)) {
    jj_scanpos = xsp;
    if (jj_scan_token(62)) {
    jj_scanpos = xsp;
    if (jj_scan_token(63)) {
    jj_scanpos = xsp;
    if (jj_scan_token(64)) {
    jj_scanpos = xsp;
    if (jj_scan_token(65)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_68() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_48() {
    return false;
  }

  private boolean jj_3R_117() {
    if (jj_3R_41()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_138()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_90() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    return false;
  }

  private boolean jj_3R_61() {
    if (jj_scan_token(80)) return true;
    return false;
  }

  private boolean jj_3R_36() {
    if (jj_3R_37()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_68()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_3() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  private boolean jj_3R_60() {
    if (jj_3R_104()) return true;
    return false;
  }

  private boolean jj_3R_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) return true;
    }
    }
    return false;
  }

  private boolean jj_3R_107() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_106()) return true;
    return false;
  }

  private boolean jj_3_32() {
    jj_lookingAhead = true;
    jj_semLA = null != pigContext.getFuncSpecFromAlias(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_48()) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_91() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_64() {
    if (jj_3R_106()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_107()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_55() {
    if (jj_scan_token(BAG)) return true;
    if (jj_scan_token(86)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    if (jj_scan_token(87)) return true;
    return false;
  }

  private boolean jj_3R_32() {
    if (jj_3R_64()) return true;
    return false;
  }

  private boolean jj_3R_54() {
    if (jj_scan_token(TUPLE)) return true;
    if (jj_scan_token(80)) return true;
    if (jj_3R_90()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3_22() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_66() {
    if (jj_3R_110()) return true;
    return false;
  }

  private boolean jj_3R_46() {
    return false;
  }

  private boolean jj_3_23() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_31()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    }
    if (jj_scan_token(80)) return true;
    if (jj_3R_67()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_56() {
    if (jj_scan_token(MAP)) return true;
    if (jj_scan_token(96)) return true;
    if (jj_scan_token(97)) return true;
    return false;
  }

  private boolean jj_3_31() {
    jj_lookingAhead = true;
    jj_semLA = null != pigContext.getFuncSpecFromAlias(getToken(1).image);
    jj_lookingAhead = false;
    if (!jj_semLA || jj_3R_46()) return true;
    if (jj_3R_47()) return true;
    return false;
  }

  private boolean jj_3R_87() {
    return false;
  }

  private boolean jj_3_20() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3R_136() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(34)) {
    jj_scanpos = xsp;
    if (jj_scan_token(70)) return true;
    }
    return false;
  }

  private boolean jj_3_21() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_57() {
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3_45() {
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3_44() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_82() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_32()) return true;
    if (jj_scan_token(94)) return true;
    if (jj_3R_33()) return true;
    if (jj_scan_token(95)) return true;
    if (jj_3R_33()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3_43() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3R_86() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3_42() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3_11() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_36()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_78() {
    if (jj_3R_57()) return true;
    return false;
  }

  private boolean jj_3R_77() {
    if (jj_3R_56()) return true;
    return false;
  }

  private boolean jj_3R_76() {
    if (jj_3R_55()) return true;
    return false;
  }

  private boolean jj_3_12() {
    if (jj_3R_37()) return true;
    return false;
  }

  private boolean jj_3R_75() {
    if (jj_3R_54()) return true;
    return false;
  }

  private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_137() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_105()) return true;
    return false;
  }

  private boolean jj_3R_63() {
    return false;
  }

  private boolean jj_3R_134() {
    if (jj_scan_token(93)) return true;
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3_2() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(79)) return true;
    return false;
  }

  private boolean jj_3R_135() {
    if (jj_scan_token(DOLLARVAR)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_scan_token(79)) return true;
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  private boolean jj_3R_62() {
    if (jj_3R_105()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_137()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_28() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) return true;
    }
    return false;
  }

  private boolean jj_3R_133() {
    if (jj_scan_token(88)) return true;
    if (jj_3R_149()) return true;
    return false;
  }

  private boolean jj_3R_114() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) return true;
    }
    return false;
  }

  private boolean jj_3_41() {
    if (jj_scan_token(95)) return true;
    if (jj_scan_token(BAG)) return true;
    return false;
  }

  private boolean jj_3R_85() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_41()) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    return false;
  }

  private boolean jj_3R_45() {
    if (jj_3R_82()) return true;
    return false;
  }

  private boolean jj_3R_44() {
    if (jj_3R_81()) return true;
    return false;
  }

  private boolean jj_3R_116() {
    if (jj_3R_136()) return true;
    return false;
  }

  private boolean jj_3R_43() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_115() {
    if (jj_3R_135()) return true;
    return false;
  }

  private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    }
    return false;
  }

  private boolean jj_3_29() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3_18() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_30() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    }
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_114()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3_30()) return true;
    }
    return false;
  }

  private boolean jj_3_47() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3_40() {
    if (jj_scan_token(95)) return true;
    if (jj_scan_token(TUPLE)) return true;
    return false;
  }

  private boolean jj_3R_84() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_40()) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    return false;
  }

  private boolean jj_3R_74() {
    if (jj_3R_42()) return true;
    return false;
  }

  private boolean jj_3_19() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_51() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) return true;
    }
    if (jj_scan_token(87)) return true;
    return false;
  }

  private boolean jj_3R_80() {
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3R_79() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    }
    return false;
  }

  private boolean jj_3R_163() {
    if (jj_scan_token(NOT)) return true;
    return false;
  }

  private boolean jj_3R_164() {
    if (jj_scan_token(90)) return true;
    if (jj_3R_125()) return true;
    return false;
  }

  private boolean jj_3_39() {
    if (jj_scan_token(95)) return true;
    if (jj_scan_token(MAP)) return true;
    return false;
  }

  private boolean jj_3R_88() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_39()) {
    jj_scanpos = xsp;
    if (jj_scan_token(95)) return true;
    }
    return false;
  }

  private boolean jj_3_27() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_50() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_84()) jj_scanpos = xsp;
    if (jj_scan_token(80)) return true;
    if (jj_3R_31()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_97() {
    if (jj_3R_59()) return true;
    return false;
  }

  private boolean jj_3R_113() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_96() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_152()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_95() {
    if (jj_scan_token(86)) return true;
    if (jj_3R_151()) return true;
    if (jj_scan_token(87)) return true;
    return false;
  }

  private boolean jj_3R_94() {
    if (jj_scan_token(96)) return true;
    if (jj_3R_150()) return true;
    if (jj_scan_token(97)) return true;
    return false;
  }

  private boolean jj_3R_58() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_156() {
    if (jj_3R_164()) return true;
    return false;
  }

  private boolean jj_3R_155() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_33()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_154() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) return true;
    }
    }
    return false;
  }

  private boolean jj_3_16() {
    if (jj_3R_38()) return true;
    return false;
  }

  private boolean jj_3_17() {
    if (jj_3R_39()) return true;
    return false;
  }

  private boolean jj_3R_89() {
    if (jj_scan_token(95)) return true;
    if (jj_3R_93()) return true;
    return false;
  }

  private boolean jj_3R_52() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_88()) jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    if (jj_scan_token(97)) return true;
    return false;
  }

  private boolean jj_3R_102() {
    if (jj_scan_token(QUOTEDSTRING)) return true;
    return false;
  }

  private boolean jj_3R_101() {
    if (jj_scan_token(DOUBLENUMBER)) return true;
    return false;
  }

  private boolean jj_3R_100() {
    if (jj_scan_token(FLOATNUMBER)) return true;
    return false;
  }

  private boolean jj_3R_103() {
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_99() {
    if (jj_scan_token(LONGINTEGER)) return true;
    return false;
  }

  private boolean jj_3R_98() {
    if (jj_scan_token(INTEGER)) return true;
    return false;
  }

  private boolean jj_3R_35() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(IS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_163()) jj_scanpos = xsp;
    if (jj_scan_token(NULL)) return true;
    return false;
  }

  private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_161() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_160()) return true;
    return false;
  }

  private boolean jj_3R_53() {
    if (jj_scan_token(IDENTIFIER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_89()) jj_scanpos = xsp;
    return false;
  }

  private boolean jj_3_26() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_41()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_125() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_26()) jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    return false;
  }

  private boolean jj_3_38() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_160() {
    if (jj_3R_59()) return true;
    if (jj_scan_token(93)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3_37() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3_36() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_153() {
    if (jj_scan_token(NOT)) return true;
    if (jj_3R_123()) return true;
    return false;
  }

  private boolean jj_3_35() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3_5() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3_9() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3R_73() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_112()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_113()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_72() {
    if (jj_3R_112()) return true;
    return false;
  }

  private boolean jj_3R_122() {
    if (jj_3R_53()) return true;
    return false;
  }

  private boolean jj_3R_121() {
    if (jj_3R_52()) return true;
    return false;
  }

  private boolean jj_3R_120() {
    if (jj_3R_51()) return true;
    return false;
  }

  private boolean jj_3R_119() {
    if (jj_3R_50()) return true;
    return false;
  }

  private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) return true;
    }
    }
    }
    return false;
  }

  private boolean jj_3R_150() {
    if (jj_3R_160()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_161()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_143() {
    if (jj_3R_153()) return true;
    return false;
  }

  private boolean jj_3_46() {
    if (jj_scan_token(83)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  private boolean jj_3_10() {
    if (jj_3R_35()) return true;
    return false;
  }

  private boolean jj_3R_142() {
    if (jj_3R_34()) return true;
    return false;
  }

  private boolean jj_3_8() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(MATCHES)) return true;
    return false;
  }

  private boolean jj_3R_71() {
    if (jj_scan_token(DOLLARVAR)) return true;
    return false;
  }

  private boolean jj_3R_162() {
    if (jj_scan_token(83)) return true;
    if (jj_scan_token(80)) return true;
    if (jj_3R_152()) return true;
    if (jj_scan_token(81)) return true;
    return false;
  }

  private boolean jj_3R_126() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(32)) {
    jj_scanpos = xsp;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(92)) return true;
    }
    }
    if (jj_3R_125()) return true;
    return false;
  }

  private boolean jj_3R_108() {
    if (jj_3R_125()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_126()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3R_141() {
    if (jj_3R_33()) return true;
    if (jj_scan_token(MATCHES)) return true;
    if (jj_scan_token(QUOTEDSTRING)) return true;
    return false;
  }

  private boolean jj_3R_152() {
    if (jj_3R_58()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_46()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  private boolean jj_3_4() {
    if (jj_scan_token(80)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  private boolean jj_3R_93() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(43)) {
    jj_scanpos = xsp;
    if (jj_scan_token(44)) {
    jj_scanpos = xsp;
    if (jj_scan_token(45)) {
    jj_scanpos = xsp;
    if (jj_scan_token(46)) {
    jj_scanpos = xsp;
    if (jj_scan_token(47)) {
    jj_scanpos = xsp;
    if (jj_scan_token(48)) return true;
    }
    }
    }
    }
    }
    return false;
  }

  private boolean jj_3R_70() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public QueryParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  /** Whether we are looking ahead. */
  private boolean jj_lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[117];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
      jj_la1_init_3();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8000000,0x7ebc00,0x0,0x8000000,0x3ebc00,0x0,0x0,0xfffffc00,0x0,0x8000000,0x40000,0x0,0x8000000,0x3ebc00,0x0,0x20000000,0x400000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x16000000,0xc0000000,0xc0000000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x20000000,0x0,0x20000000,0x0,0x0,0x0,0x20000000,0x0,0x0,0x39000,0x0,0x0,0x0,0x18000,0x0,0x0,0x0,0x0,0x20000000,0x0,0x0,0x8000000,0x0,0x8000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x1400004,0x0,0x0,0x1400004,0x0,0x0,0xfffffffe,0x0,0x0,0x4,0x0,0x0,0x1400004,0x2,0x0,0x0,0x0,0x0,0x10,0x8,0x20,0x20,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x600,0x1,0x0,0x600,0x600,0x600,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3e000000,0x3e000000,0x0,0x0,0x0,0x0,0x0,0x0,0xc0000000,0x0,0x0,0x0,0x0,0x40,0x0,0x0,0x0,0x0,0x0,0x0,0x600,0x600,0x1,0x0,0x0,0x0,0x0,0x1,0x0,0x80,0x0,0x0,0x1,0x1,0x0,0x4,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0xff800,0xe0000,0x1f800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000,0x0,0xff800,0x0,0x0,0x0,0x0,0x4,0x0,0x0,0x0,0x200000,0x200000,0x200000,0x4,0x4,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x10043,0x80000,0x0,0x10043,0x40,0x10000,0x43,0x40,0x0,0x0,0x40,0x0,0x3,0x0,0x0,0x0,0x80000,0x1000,0x0,0x0,0x0,0x0,0x80000,0x80000,0x0,0x0,0x0,0x80000,0x0,0x0,0x14040,0x0,0x0,0x0,0x0,0x0,0x14040,0x4040,0x80000,0x80000,0x300000,0x0,0x80000,0x2040,0x0,0x0,0x2040,0x80000,0x1000,0x0,0x80000,0x0,0x1000,0x1,0x1000,0x0,0x40,0x400000,0x1,0x4040,0x80000,0x14040,0x0,0x80000,0x0,0x0,0x14040,0x0,0x80000,0x10040,0x0,0x0,0x0,0x0,0x6000000,0x6000000,0x18000000,0x18000000,0x4010000,0x14040,0x21000000,0x21000000,0x40,0x10000,0x40,0x80000,0x0,0x0,0x0,0x0,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x80000000,0x40,0x80000,0x40,0x0,0x80000,0x0,0x1000000,0x1000000,0x1000000,0x1000000,0x14040,0x80000,0x80000,0x80000,0x1f00,0x411f00,0x411f00,0x4040,0x40,};
   }
   private static void jj_la1_init_3() {
      jj_la1_3 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x4,0x4,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[47];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  /** Constructor with InputStream. */
  public QueryParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public QueryParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public QueryParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new QueryParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public QueryParser(QueryParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(QueryParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
    jj_gen = 0;
    for (int i = 0; i < 117; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = jj_lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List jj_expentries = new java.util.ArrayList();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[99];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 117; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 99; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

  private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 47; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
            case 45: jj_3_46(); break;
            case 46: jj_3_47(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}


class StringUtils {

       public static String unescapeInputString(String input)  {

            if (input == null) {
                return new String() ;
            }

            // Needed variables
            // preset the size so our StringBuilders don't have to grow
            int inputlength = input.length();
            StringBuilder unicode = new StringBuilder(4);
            StringBuilder output = new StringBuilder(inputlength) ;
            boolean hadSlash = false;
            boolean inUnicode = false;

            // The main loop
            for (int i = 0; i < inputlength; i++) {
                char ch = input.charAt(i);
                // currently doing unicode mode
                if (inUnicode) {
                    unicode.append(ch);
                    if (unicode.length() == 4) {
                        // unicode now contains the four hex digits
                        try {
                            int value = Integer.parseInt(unicode.toString(), 0x10);
                            output.append((char) value) ;
                            // reuse the StringBuilder
                            unicode.setLength(0);
                            inUnicode = false;
                            hadSlash = false;
                        } catch (NumberFormatException nfe) {
                            throw new RuntimeException("Unable to parse unicode value: " + unicode, nfe);
                        }
                    }
                    continue;
                }
                if (hadSlash) {
                    // handle an escaped value
                    hadSlash = false;
                    switch (ch) {
                        case '\u005c\u005c':
                            output.append('\u005c\u005c');
                            break;
                        case '\u005c'':
                            output.append('\u005c'');
                            break;
                        case 'r':
                            output.append('\u005cr');
                            break;
                        case 'f':
                            output.append('\u005cf');
                            break;
                        case 't':
                            output.append('\u005ct');
                            break;
                        case 'n':
                            output.append('\u005cn');
                            break;
                        case 'b':
                            output.append('\u005cb');
                            break;
                        case 'u':
                            {
                                // switch to unicode mode
                                inUnicode = true;
                                break;
                            }
                        default :
                            output.append(ch);
                            break;
                    }
                    continue;
                } else if (ch == '\u005c\u005c') {
                    hadSlash = true;
                    continue;
                }
                output.append(ch);
            }

            return output.toString() ;
        }
}

class FunctionType {
    public static final byte UNKNOWNFUNC = 0;
    public static final byte EVALFUNC = 2;
    public static final byte COMPARISONFUNC = 4;
    public static final byte LOADFUNC = 8;
    public static final byte STOREFUNC = 16;

    public static void tryCasting(Object func, byte funcType) throws Exception {
        switch(funcType) {
        case FunctionType.EVALFUNC:
                        EvalFunc evalFunc = (EvalFunc) func;
            break;
        case FunctionType.COMPARISONFUNC:
                        ComparisonFunc comparisonFunc = (ComparisonFunc) func;
            break;
        case FunctionType.LOADFUNC:
                        LoadFunc loadFunc = (LoadFunc) func;
            break;
        case FunctionType.STOREFUNC:
                        StoreFunc storeFunc = (StoreFunc) func;
            break;
        default:
            throw new Exception("Received an unknown function type: " + funcType);
        }
    }
}
