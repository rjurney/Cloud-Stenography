<?xml version="1.0" encoding="UTF-8"?>

<!--  Copyright 2002-2004 The Apache Software Foundation
  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!DOCTYPE article PUBLIC "-//OASIS//DTD Simplified DocBook XML V1.0//EN" 
"http://www.oasis-open.org/docbook/xml/simple/1.0/sdocbook.dtd">
  
  <!-- BEGIN ARTICLE -->
  
<article>
<title>Pig Latin Manual</title>
   
   <!-- ABOUT PIG LATIN -->
   <section>
   <title>About Pig Latin </title>
   
   <section>
	<title>Pig Latin Statements</title>	
   <para>A Pig Latin statement is an operator that takes a relation as input and produces another relation as output. 
   (This definition applies to all Pig Latin operators except LOAD and STORE which read data from and write data to the file system.) 
   Pig Latin statements can span multiple lines and must end with a semi-colon ( ; ). Pig Latin statements are generally organized in the following manner: </para>
   <itemizedlist>
      <listitem>
         <para>A LOAD statement reads data from the file system. </para>
      </listitem>
      <listitem>
         <para>A series of "transformation" statements process the data. </para>
      </listitem>
      <listitem>
         <para>A STORE statement writes output to the file system; or, a DUMP statement displays output to the screen.</para>
      </listitem>
   </itemizedlist>
  
   <section>
   <title>Running Pig Latin </title>
   <para>You can execute Pig Latin statements interactively or in batch mode using Pig scripts (see the EXEC and RUN operators).</para>
   
   <para>Grunt Shell, Interactive or Batch Mode</para>
   <programlisting>
$ pig 
... - Connecting to ...
grunt> A = load 'data';
grunt> B = ... ;
or
grunt> exec myscript.pig;
or
grunt> run myscript.pig;
</programlisting> 

<para>Command Line, Batch Mode</para>
   <programlisting>
$ pig myscript.pig
</programlisting> 

<para></para>
   <para><emphasis>In general</emphasis>, Pig processes Pig Latin statements as follows:</para>
   <itemizedlist>
      <listitem>
         <para>First, Pig validates the syntax and semantics of all statements.</para>
      </listitem>
      <listitem>
         <para>Next, if Pig encounters a DUMP or STORE, Pig will execute the statements.</para>
      </listitem>
   </itemizedlist>  
   <para></para>
   <para>In this example Pig will validate, but not execute, the LOAD and FOREACH statements.</para>

<programlisting>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE name;
</programlisting>   

   <para>In this example, Pig will validate and then execute the LOAD, FOREACH, and DUMP statements.</para>
   
<programlisting>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE name;
DUMP B;
(John)
(Mary)
(Bill)
(Joe)
</programlisting>   
   
   <para> </para>
   <para>Note: See Multi-Query Execution for more information on how Pig Latin statements are processed.</para> 
   </section>
   
   <section>
   <title>Retrieving Pig Latin Results</title>
   <para>Pig Latin includes operators you can use to retrieve the results of your Pig Latin statements: </para>
   <itemizedlist>
      <listitem>
         <para>Use the DUMP operator to display results to a screen. </para>
      </listitem>
      <listitem>
         <para>Use the STORE operator to write results to a file on the file system.</para>
      </listitem>
   </itemizedlist>
   </section>   
   
   
   <section>
   <title>Debugging Pig Latin</title>
   <para>Pig Latin includes operators that can help you debug your Pig Latin statements:</para>
   <itemizedlist>
      <listitem>
         <para>Use the DESCRIBE operator to review the schema of a relation.</para>
      </listitem>
      <listitem>
         <para>Use the EXPLAIN operator to view the logical, physical, or map reduce execution plans to compute a relation.</para>
      </listitem>
      <listitem>
         <para>Use the ILLUSTRATE operator to view the step-by-step execution of a series of statements.</para>
      </listitem>
   </itemizedlist>
   </section>
      
   
   <section>
   <title>Working with Data</title>
   <para>Pig Latin allows you to work with data in many ways. In general, and as a starting point:</para>
   <itemizedlist>
      <listitem>
         <para>Use the FILTER operator to work with tuples or rows of data. Use the FOREACH operator to work with columns of data.</para>
      </listitem>
      <listitem>
         <para>Use the GROUP operator to group data in a single relation. Use the COGROUP and JOIN operators to group or join data in two or more relations.</para>
      </listitem>
      <listitem>
         <para>Use the UNION operator to merge the contents of two or more relations. Use the SPLIT operator to partition the contents of a relation into multiple relations.</para>
      </listitem>
   </itemizedlist>
   </section>
   
   <section>
   <title>Increasing Parallelism</title>
   <para>To increase the parallelism of a job, include the PARALLEL clause with the COGROUP, CROSS, DISTINCT, GROUP, JOIN and ORDER operators. PARALLEL controls the number of reducers only; the number of maps is determined by the input data (see the <ulink url="http://wiki.apache.org/pig/PigUserCookbook">Pig User Cookbook</ulink>).</para>
   </section>
   
   <section><title>Increasing Performance</title>
   <para>You can increase or optimize the performance of your Pig Latin scripts by following a few simple rules (see the <ulink url="http://wiki.apache.org/pig/PigUserCookbook">Pig User Cookbook</ulink>).</para>
   </section>
   
   <section>
   <title>Using Comments in Scripts</title>
   <para>If you place Pig Latin statements in a script, the script can include comments. </para>
   <itemizedlist>
      <listitem>
         <para>For multi-line comments use /* …. */</para>
      </listitem>
      <listitem>
         <para>For single line comments use --</para>
      </listitem>
   </itemizedlist>
<programlisting>
/* myscript.pig
My script includes three simple Pig Latin Statements.
*/

A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float); -- load statement
B = FOREACH A GENERATE name;  -- foreach statement
DUMP B;  --dump statement
</programlisting>   
</section>

 <section>
   <title>Case Sensitivity</title>
   <para>The names (aliases) of relations and fields are case sensitive. The names of Pig Latin functions are case sensitive. The names of parameters (see Parameter Substitution) and all other Pig Latin keywords are case insensitive.</para>
   <para>In the example below, note the following:</para>
   <itemizedlist>
      <listitem>
         <para>The names (aliases) of relations A, B, and C are case sensitive.</para>
      </listitem>
      <listitem>
         <para>The names (aliases) of fields f1, f2, and f3 are case sensitive.</para>
      </listitem>
      <listitem>
         <para>Function names PigStorage and COUNT are case sensitive.</para>
      </listitem>
      <listitem>
         <para>Keywords LOAD, USING, AS, GROUP, BY, FOREACH, GENERATE, and DUMP are case insensitive. They can also be written as load, using, as, group, by, etc.</para>
      </listitem>
      <listitem>
         <para>In the FOREACH statement, the field in relation B is referred to by positional notation ($0).</para>
      </listitem>
   </itemizedlist>
   <para/>

<programlisting>
grunt> A = LOAD 'data' USING PigStorage() AS (f1:int, f2:int, f3:int);
grunt> B = GROUP A BY f1;
grunt> C = FOREACH B GENERATE COUNT ($0);
grunt> DUMP C;
</programlisting>
</section>      
</section>

<!-- MULTI-QUERY EXECUTION-->
<section>
<title>Multi-Query Execution</title>
<para>With multi-query execution Pig processes an entire script or a batch of statements at once 
(as opposed to processing statements when a DUMP or STORE is encountered). </para>


<section>
	<title>Turning Multi-Query Execution On or Off</title>	
	<para>Multi-query execution is turned on by default. 
	To turn it off and revert to Pi'gs "execute-on-dump/store" behavior, use the "-M" or "-no_multiquery" options. </para>
	<para>To run script "myscript.pig" without the optimization, execute Pig as follows: </para>
<programlisting>
$ pig -M myscript.pig
or
$ pig -no_multiquery myscript.pig
</programlisting>
</section>

<section>
<title>How it Works</title>
<para>Multi-query execution introduces some changes:</para>

<itemizedlist>
<listitem>
<para>For batch mode execution, the entire script is first parsed to determine if intermediate tasks 
can be combined to reduce the overall amount of work that needs to be done; execution starts only after the parsing is completed 
(see the EXPLAIN operator and the EXEC and RUN commands). </para>
</listitem>
<listitem>
<para>Two run scenarios are optimized, as explained below: explicit and implicit splits, and storing intermediate results.</para>
</listitem>
</itemizedlist>

<section>
	<title> </title>
<section>
	<title>Explicit and Implicit Splits</title>
<para>There might be cases in which you want different processing on separate parts of the same data stream.</para>
<para>Example 1:</para>
<programlisting>
A = LOAD ...
...
SPLIT A' INTO B IF ..., C IF ...
...
STORE B' ...
STORE C' ...
</programlisting>
<para>Example 2:</para>
<programlisting>
A = LOAD ...
...
B = FILTER A' ...
C = FILTER A' ...
...
STORE B' ...
STORE C' ...
</programlisting>
<para>In prior Pig releases, Example 1 will dump A' to disk and then start jobs for B' and C'. 
Example 2 will execute all the dependencies of B' and store it and then execute all the dependencies of C' and store it. 
Both are equivalent, but the performance will be different. </para>
<para>Here's what the multi-query execution does to increase the performance: </para>
	<itemizedlist>
		<listitem><para>For Example 2, adds an implicit split to transform the query to Example 1. This eliminates the processing of A' multiple times.</para></listitem>
		<listitem><para>Makes the split non-blocking and allows processing to continue. This helps reduce the amount of data that has to be stored right at the split.  </para></listitem>
		<listitem><para>Allows multiple outputs from a job. This way some results can be stored as a side-effect of the main job. This is also necessary to make the previous item work.  </para></listitem>
		<listitem><para>Allows multiple split branches to be carried on to the combiner/reducer. This reduces the amount of IO again in the case where multiple branches in the split can benefit from a combiner run. </para></listitem>
	</itemizedlist>
</section>

<section>
	<title>Storing Intermediate Results</title>
<para>Sometimes it is necessary to store intermediate results. </para>

<programlisting>
A = LOAD ...
...
STORE A'
...
STORE A''
</programlisting>

<para>If the script doesn't re-load A' for the processing of A the steps above A' will be duplicated. 
This is a special case of Example 2 above, so the same steps are recommended. 
With multi-query execution, the script will process A and dump A' as a side-effect.</para>
</section>
</section>
</section>


<section>
	<title>Error Handling</title>
	<para>With multi-query execution Pig processes an entire script or a batch of statements at once. 
	By default Pig tries to run all the jobs that result from that, regardless of whether some jobs fail during execution. 
	To check which jobs have succeeded or failed use one of these options. </para>
	
	<para>First, Pig logs all successful and failed store commands. Store commands are identified by output path. 
	At the end of execution a summary line indicates success, partial failure or failure of all store commands. </para>	
	
	<para>Second, Pig returns different code upon completion for these scenarios:</para>
	<itemizedlist>
		<listitem><para>Return code 0: All jobs succeeded</para></listitem>
		<listitem><para>Return code 1: <emphasis>Used for retrievable errors</emphasis> </para></listitem>
		<listitem><para>Return code 2: All jobs have failed </para></listitem>
		<listitem><para>Return code 3: Some jobs have failed  </para></listitem>
	</itemizedlist>
	<para></para>
	<para>In some cases it might be desirable to fail the entire script upon detecting the first failed job. 
	This can be achieved with the "-F" or "-stop_on_failure" command line flag. 
	If used, Pig will stop execution when the first failed job is detected and discontinue further processing. 
	This also means that file commands that come after a failed store in the script will not be executed (this can be used to create "done" files). </para>
	
	<para>This is how the flag is used: </para>
<programlisting>
$ pig -F myscript.pig
or
$ pig -stop_on_failure myscript.pig
</programlisting>

</section>

<section>
	<title>Backward Compatibility</title>
	
	<para>Most existing Pig scripts will produce the same result with or without the multi-query execution. 
	There are cases though were this is not true. Path names and schemes are discussed here.</para>
	
	<para>Any script is parsed in it's entirety before it is sent to execution. Since the current directory can change 
	throughout the script any path used in load or store is translated to a fully qualified and absolute path.</para>
		
	<para>In map-reduce mode, the following script will load from "hdfs://&lt;host&gt;:&lt;port&gt;/data1" and store into "hdfs://&lt;host&gt;:&lt;port&gt;/tmp/out1". </para>
<programlisting>
cd /;
A = LOAD 'data1';
cd tmp;
STORE A INTO 'out1';
</programlisting>

	<para>These expanded paths will be passed to any LoadFunc or Slicer implementation. 
	In some cases this can cause problems, especially when a LoadFunc/Slicer is not used to read from a dfs file or path 
	(for example, loading from an SQL database). </para>
	
	<para>Solutions are to either: </para>
	<itemizedlist>
		<listitem><para>Specify "-M" or "-no_multiquery" to revert to the old names</para></listitem>
		<listitem><para>Specify a custom scheme for the LoadFunc/Slicer </para></listitem>
	</itemizedlist>	
	
	<para>Arguments used in a load statement that have a scheme other than "hdfs" or "file" will not be expanded and passed to the LoadFunc/Slicer unchanged.</para>
	<para>In the SQL case, the SQLLoader function is invoked with "sql://mytable". </para>

<programlisting>
A = LOAD "sql://mytable" USING SQLLoader();
</programlisting>
</section>

<section>
	<title>Implicit Dependencies</title>
<para>If a script has dependencies on the execution order outside of what Pig knows about, execution may fail. For instance, in this script
MYUDF might try to read from out1, a file that A was just stored into. 
However, Pig does not know that MYUDF depends on the out1 file and might submit the jobs 
producing the out2 and out1 files at the same time.
</para>
<programlisting>
...
STORE A INTO 'out1';
B = LOAD 'data2';
C = FOREACH B GENERATE MYUDF($0,'out1');
STORE C INTO 'out2';
</programlisting>

<para>To make the script work (to ensure that the right execution order is enforced) add the exec statement. 
The exec statement will trigger the execution of the statements that produce the out1 file. </para>

<programlisting>
...
STORE A INTO 'out1';
EXEC;
B = LOAD 'data2';
C = FOREACH B GENERATE MYUDF($0,'out1');
STORE C INTO 'out2';
</programlisting>

</section>

</section>
 <!-- KEYWORDS -->

   <section>
   <title>Keywords</title>
   <para>Pig keywords are listed here.</para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody>  
    
         <row>
            <entry> <para>-- A </para> </entry>
            <entry> <para>and, any, all, arrange, as, asc, AVG</para> </entry>
         </row>      
      
         <row>
            <entry> <para>-- B </para> </entry>
            <entry> <para>bag, BinaryDeserializer, BinarySerializer, BinStorage, by, bytearray </para> </entry>
         </row>   

         <row>
            <entry> <para>-- C </para> </entry>
            <entry> <para>cache, cat, cd, chararray, cogroup, CONCAT, copyFromLocal, copyToLocal, COUNT, cp, cross</para> </entry>
         </row>
         
         <row>
            <entry> <para>-- D </para> </entry>
            <entry> <para>%declare, %default, define, desc, describe, DIFF, distinct, double, du, dump</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- E </para> </entry>
            <entry> <para>e, E, eval, exec, explain</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- F </para> </entry>
            <entry> <para>f, F, filter, flatten, float, foreach</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- G </para> </entry>
            <entry> <para>generate, group</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- H </para> </entry>
            <entry> <para>help</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- I </para> </entry>
            <entry> <para>if, illustrate, inner, input, int, into, is</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- J </para> </entry>
            <entry> <para>join</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- K </para> </entry>
            <entry> <para>kill</para> </entry>
         </row>   
         
         <row>
            <entry> <para>-- L </para> </entry>
            <entry> <para>l, L, limit, load, long, ls</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- M </para> </entry>
            <entry> <para>map, matches, MAX, MIN, mkdir, mv </para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- N </para> </entry>
            <entry> <para>not, null</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- O </para> </entry>
            <entry> <para>or, order, outer, output</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- P </para> </entry>
            <entry> <para>parallel, pig, PigDump, PigStorage, pwd</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- Q </para> </entry>
            <entry> <para>quit</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- R </para> </entry>
            <entry> <para>register, rm, rmf, run</para> </entry>
         </row>  

         <row>
            <entry> <para>-- S </para> </entry>
            <entry> <para>sample, set, ship, SIZE, split, stderr, stdin, stdout, store, stream, SUM</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- T </para> </entry>
            <entry> <para>TextLoader, TOKENIZE, through, tuple</para> </entry>
         </row>  
         
         <row>
            <entry> <para>-- U </para> </entry>
            <entry> <para>union, using</para> </entry>
         </row>  

         <row>
            <entry> <para>-- V, W, X, Y, Z </para> </entry>
            <entry> <para> </para> </entry>
         </row>  
                    
        <row>
            <entry> <para>-- Symbols</para> </entry>
            <entry> <para>= =   !=   &lt;  &gt;   &lt;=   &gt;=   +   -   *   /   %   ?   $   .   #   ( )   [ ]   { } </para> </entry>
         </row> 
            
      </tbody></tgroup>
   </informaltable>
   </section>
</section>
   
<!-- DATA TYPES AND MORE-->

<section>
	<title>Data Types and More</title>

<!-- RELATIONS, BAGS, TUPLES, FIELDS-->
   
   <section>
   <title>Relations, Bags, Tuples, Fields</title>
      <para>Pig Latin statements work with relations. A relation can be defined as follows:</para>
   <itemizedlist>
      <listitem>
         <para>A relation is a bag (more specifically, an outer bag).</para>
      </listitem>
      <listitem>
         <para>A bag is a collection of tuples. </para>
      </listitem>
      <listitem>
         <para>A tuple is an ordered set of fields.</para>
      </listitem>
      <listitem>
         <para>A field is a piece of data.</para>
      </listitem>
   </itemizedlist>
   <para/>
   <para>A Pig relation is a bag of tuples. A Pig relation is similar to a table in a relational database, where the tuples in the bag correspond to the rows in a table. Unlike a relational table, however, Pig relations don't require that every tuple contain the same number of fields or that the fields in the same position (column) have the same type.</para>
   <para>Also note that relations are unordered which means there is no guarantee that tuples are processed in any particular order. Furthermore, processing may be parallelized in which case tuples are not processed according to any total ordering.</para>
   
   <section><title>Referencing Relations</title>
   <para>Relations are referred to by name (or alias). Names are assigned by you as part of the Pig Latin statement. In this example the name (alias) of the relation is A.</para>
   
   <programlisting>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</programlisting>
   </section>
   
   <section>
   <title>Referencing Fields</title>
   <para>Fields are referred to by positional notation or by name (alias). </para>
   <itemizedlist>
      <listitem>
         <para>Positional notation is generated by the system. Positional notation is indicated with the dollar sign ($) and begins with zero (0); for example, $0, $1, $2. </para>
      </listitem>
      <listitem>
         <para>Names are assigned by you using schemas (or, in the case of the GROUP operator and some functions, by the system). You can use any name that is not a Pig keyword; for example, f1, f2, f3 or a, b, c or name, age, gpa.</para>
      </listitem>
   </itemizedlist>
   <para>Given relation A above, the three fields are separated out in this table. </para>
   <informaltable frame="all">
      <tgroup cols="4"><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>First Field</para>
            </entry>
            <entry>
               <para>Second Field</para>
            </entry>
            <entry>
               <para>Third Field </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Data type</para>
            </entry>
            <entry>
               <para>chararray</para>
            </entry>
            <entry>
               <para>int</para>
            </entry>
            <entry>
               <para>float</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Positional notation (generated by system) </para>
            </entry>
            <entry>
               <para>$0</para>
            </entry>
            <entry>
               <para>$1</para>
            </entry>
            <entry>
               <para>$2</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Possible name (assigned by you using a schema)</para>
            </entry>
            <entry>
               <para>name</para>
            </entry>
            <entry>
               <para>age</para>
            </entry>
            <entry>
               <para>gpa</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Field value (for the first tuple)</para>
            </entry>
            <entry>
               <para>John</para>
            </entry>
            <entry>
               <para>18</para>
            </entry>
            <entry>
               <para>4.0</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>As shown in this example when you assign names to fields you can still refer to the fields using positional notation. However, for debugging purposes and ease of comprehension, it is better to use names.</para>
<programlisting>
A = LOAD 'student' USING PigStorage() AS (name:chararray, age:int, gpa:float);
X = FOREACH A GENERATE name,$2;
DUMP X;
(John,4.0F)
(Mary,3.8F)
(Bill,3.9F)
(Joe,3.8F)
</programlisting>   
   
   <para>In this example an error is generated because the requested column ($3) is outside of the declared schema (positional notation begins with $0). Note that the error is caught before the statements are executed.</para>
   
   <programlisting>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);
B = FOREACH A GENERATE $3;
DUMP B;
2009-01-21 23:03:46,715 [main] ERROR org.apache.pig.tools.grunt.GruntParser - java.io.IOException: 
Out of bound access. Trying to access non-existent  : 3. Schema {f1: bytearray,f2: bytearray,f3: bytearray} has 3 column(s). 
<emphasis>etc ...</emphasis></programlisting>
   </section>
   
   <section><title>Referencing Fields that are Complex Data Types</title>
   <para>As noted, the fields in a tuple can be any data type, including the complex data types: bags, tuples, and maps. </para>
   <itemizedlist>
      <listitem>
         <para>Use the schemas for complex data types to name fields that are complex data types. </para>
      </listitem>
      <listitem>
         <para>Use the dereference operators to reference and work with fields that are complex data types.</para>
      </listitem>
   </itemizedlist>
   <para>In this example the data file contains tuples. A schema for complex data types (in this case, tuples) is used to load the data. Then, dereference operators (the dot in t1.t1a and t2.$0) are used to access the fields in the tuples. Note that when you assign names to fields you can still refer to these fields using positional notation.</para>

   
   <programlisting>
cat data;
(3,8,9) (4,5,6)
(1,4,7) (3,7,5)
(2,5,8) (9,5,8)

A = LOAD 'data' AS (t1:tuple(t1a:int, t1b:int,t1c:int),t2:tuple(t2a:int,t2b:int,t2c:int));

DUMP A;
((3,8,9),(4,5,6))
((1,4,7),(3,7,5))
((2,5,8),(9,5,8))

X = FOREACH A GENERATE t1.t1a,t2.$0;

DUMP X;
(3,4)
(1,3)
(2,9)
</programlisting>
</section>
</section>   

<section>
<title>Data Types</title>

<section>
<title>Simple and Complex</title>
<para></para>

   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Simple Data Types</para>
            </entry>
            <entry>
               <para>Description</para>
            </entry>
            <entry>
               <para>Example </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Scalars</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>int</para>
            </entry>
            <entry>
               <para>Signed 32-bit integer</para>
            </entry>
            <entry>
               <para>10</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long</para>
            </entry>
            <entry>
               <para>Signed 64-bit integer</para>
            </entry>
            <entry>
               <para>Data:     10L or 10l </para>
               <para>Display: 10L </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float</para>
            </entry>
            <entry>
               <para>32-bit floating point</para>
            </entry>
            <entry>
               <para>Data:     10.5F or 10.5f or 10.5e2f or 10.5E2F</para>
               <para>Display: 10.5F or 1050.0F</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double</para>
            </entry>
            <entry>
               <para>64-bit floating point</para>
            </entry>
            <entry>
               <para>Data:     10.5 or 10.5e2 or 10.5E2</para>
               <para>Display: 10.5 or 1050.0</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Arrays</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray</para>
            </entry>
            <entry>
               <para>Character array (string) in Unicode UTF-8 format</para>
            </entry>
            <entry>
               <para>hello world</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray</para>
            </entry>
            <entry>
               <para>Byte array (blob)</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>Complex Data Types</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple</para>
            </entry>
            <entry>
               <para>An ordered set of fields.</para>
            </entry>
            <entry>
               <para>(19,2)</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag</para>
            </entry>
            <entry>
               <para>An collection of tuples.</para>
            </entry>
            <entry>
               <para>{(19,2), (18,1)}</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map</para>
            </entry>
            <entry>
               <para>A set of key value pairs.</para>
            </entry>
            <entry>
               <para>[open#apache]</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Note the following general observations about data types:</para>
   <itemizedlist>
      <listitem>
         <para>Use schemas to assign types to fields.  If you don't assign types, fields default to type bytearray and implicit conversions are applied to the data depending on the context in which that data is used. For example, in relation B, f1 is converted to integer because 5 is integer. In relation C, f1 and f2 are converted to double because we don't know the type of either f1 or f2.</para>
      <programlisting>
A = LOAD 'data' AS (f1,f2,f3);
B = FOREACH A GENERATE f1 + 5;
C = FOREACH A generate f1 + f2;
</programlisting>
      </listitem>
   </itemizedlist>

   <itemizedlist>
      <listitem>
         <para>If a schema is defined as part of a load statement, the load function will attempt to enforce the schema. If the data does not conform to the schema, the loader will generate a null value or an error.</para>
      <programlisting>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
</programlisting>
      </listitem>
   </itemizedlist>
   <para/>
   <itemizedlist>
      <listitem>
         <para>If an explicit cast is not supported, an error will occur. For example, you cannot cast a chararray to int.</para>
         <programlisting>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE (int)name;

<emphasis>This will cause an error …</emphasis></programlisting>
      </listitem>
   </itemizedlist>

   <para/>
   <itemizedlist>
      <listitem>
         <para>If Pig cannot resolve incompatible types through implicit casts, an error will occur. For example, you cannot add chararray and float (see the Types Table for addition and subtraction).</para>
      <programlisting>
A = LOAD 'data' AS (name:chararray, age:int, gpa:float);
B = FOREACH A GENERATE name + gpa;

<emphasis>This will cause an error …</emphasis></programlisting>
      </listitem>
   </itemizedlist>
   </section>
   
   <section>
   <title>Tuple</title>
   <para>A tuple is an ordered set of fields.</para>
   
   <section>
   <title>Syntax </title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>( field [, field …] )  </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>(  )</para>
            </entry>
            <entry>
               <para>A tuple is enclosed in parentheses ( ).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field</para>
            </entry>
            <entry>
               <para>A piece of data. A field can be any data type (including tuple and bag).</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>You can think of a tuple as a row with one or more fields, where each field can be any data type and any field may or may not have data. If a field has no data, then the following happens:</para>
   <itemizedlist>
      <listitem>
         <para>In a load statement, the loader will inject null into the tuple. The actual value that is substituted for null is loader specific; for example, PigStorage substitutes an empty field for null.</para>
      </listitem>
      <listitem>
         <para>In a non-load statement, if a requested field is missing from a tuple, Pig will inject null.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Example</title>
   <para>In this example the tuple contains three fields.</para>
   <programlisting>(John,18,4.0F)</programlisting>
   </section></section>
   
   <section>
   <title>Bag</title>
   <para>A bag is a collection of tuples.</para>
   
   <section>
   <title>Syntax: Inner bag</title><informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>{ tuple [, tuple …] }</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>{  }</para>
            </entry>
            <entry>
               <para>An inner bag is enclosed in curly brackets { }.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple</para>
            </entry>
            <entry>
               <para>A tuple.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage </title>
   <para>Note the following about bags:</para>
   <itemizedlist>
      <listitem>
         <para>A bag can have duplicate tuples.</para>
      </listitem>
      <listitem>
         <para>A bag can have tuples with differing numbers of fields. However, if Pig tries to access a field that does not exist, a null value is substituted.</para>
      </listitem>
      <listitem>
         <para>A bag can have tuples with fields that have different data types. However, for Pig to effectively process bags, the schemas of the tuples within those bags should be the same. For example, if half of the tuples include chararray fields and while the other half include float fields, only half of the tuples will participate in any kind of computation because the chararray fields will be converted to null.</para>
         <para/>
         <para>Bags have two forms: outer bag (or relation) and inner bag.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Example: Outer Bag</title>
   <para>In this example A is a relation or bag of tuples. You can think of this bag as an outer bag.</para>
<programlisting>
A = LOAD 'data' as (f1:int, f2:int, f3;int);
DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
</programlisting>
   </section>
   
   <section>
   <title>Example: Inner Bag</title>
   <para>Now, suppose we group relation A by the first field to form relation X. </para>
   <para>In this example X is a relation or bag of tuples. The tuples in relation X have two fields. The first field is type int. The second field is type bag; you can think of this bag as an inner bag.</para>
<programlisting>
X = GROUP A BY f1;
DUMP X;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(8,{(8,3,4)})
</programlisting>
   </section></section>
   
   <section>
   <title>Map</title>
   <para>A map is a set of key value pairs.</para>
   
   <section>
   <title>Syntax (&lt;&gt; denotes optional)</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>[ key#value &lt;, key#value …&gt; ]</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>[ ]</para>
            </entry>
            <entry>
               <para>Maps are enclosed in straight brackets [ ].</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>#</para>
            </entry>
            <entry>
               <para>Key value pairs are separated by the pound sign #.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>key</para>
            </entry>
            <entry>
               <para>Must be a scalar data type. Must be a unique value.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>value</para>
            </entry>
            <entry>
               <para>Any data type.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Key values within a relation must be unique.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the map includes two key value pairs.</para>
<programlisting>[name#John,phone#5551212]</programlisting>
   
   </section></section></section>
   
   <section>
   <title>Nulls</title>
   <para>In Pig Latin, nulls are implemented using the SQL definition of null as unknown or non-existent. Nulls can occur naturally in data or can be the result of an operation. </para>
   
   <section>
   <title>Nulls and Operators</title>
   <para>Pig Latin operators interact with nulls as shown in this table.</para>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>Operator </para>
            </entry>
            <entry>
               <para>Interaction </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Comparison operators:</para>
               <para>==, !=</para>
               <para>&gt;, &lt;</para>
               <para>&gt;=, &lt;=</para>
            </entry>
            <entry>
               <para>If either sub-expression is null, the result is null.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Comparison operator:</para>
               <para>matches </para>
            </entry>
            <entry>
               <para>If either the string being matched against or the string defining the match is null, the result is null.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Arithmetic operators:</para>
               <para> + , -, *, /</para>
               <para>% modulo</para>
               <para>? bincond</para>
            </entry>
            <entry>
               <para>If either sub-expression is null, the resulting expression is null.</para>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>Null operator:</para>
               <para>is null </para>
            </entry>
            <entry>
               <para>If the tested value is null, returns true; otherwise, returns false.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Null operator:</para>
               <para>is not null</para>
            </entry>
            <entry>
               <para>If the tested value is not null, returns true; otherwise, returns false.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Dereference operators:</para>
               <para>tuple (.) or map (#)</para>
            </entry>
            <entry>
               <para>If the de-referenced tuple or map is null, returns null.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Cast operator</para>
            </entry>
            <entry>
               <para>Casting a null from one type to another type results in a null.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Functions:</para>
               <para>AVG, MIN, MAX, SUM</para>
            </entry>
            <entry>
               <para>These functions ignore nulls. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Function:</para>
               <para>COUNT</para>
            </entry>
            <entry>
               <para>This function counts all values, including nulls.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Function:</para>
               <para>CONCAT</para>
            </entry>
            <entry>
               <para>If either sub-expression is null, the resulting expression is null.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Function:</para>
               <para>SIZE</para>
            </entry>
            <entry>
               <para>If the tested object is null, returns null.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>For Boolean sub-expressions, note the results when nulls are used with these operators:</para>
   <itemizedlist>
      <listitem>
         <para>FILTER operator – If a filter expression results in null value, the filter does not pass them through (if X is null, !X is also null, and the filter will reject both).</para>
      </listitem>
      <listitem>
         <para>Bincond operator – If a Boolean sub-expression results in null value, the resulting expression is null (see the interactions above for Arithmetic operators)</para>
      </listitem>
   </itemizedlist>
   
   <section>
   <title>Example: COUNT function</title>
   <para>As noted, the COUNT function counts all values, including nulls. If you don't want the function to count null values, you can use one of the methods shown here.</para>
   <para>In this example the is not null operator is used to filter (remove) all null values before subsequent operations, including the COUNT function, are applied.</para>
<programlisting>
A = LOAD 'data';
B = FILTER A BY $1 is not null;
C = GROUP A BY $0;
D = FOREACH B GENERATE GROUP, COUNT(B.$1);
</programlisting>
   <para>Suppose you have written a function, RemoveNulls, to filter null values. In this example RemoveNulls is used to filter nulls values for the COUNT function only. </para>
<programlisting>
A = LOAD 'data';
B = GROUP A BY $0;
D = FOREACH B GENERATE GROUP, COUNT(RemoveNulls($1));
</programlisting>
   </section></section>
   
   <section>
   <title>Nulls and Constants</title>
   <para>Nulls can be used as constant expressions in place of expressions of any type.</para>
   <para>In this example a and null are projected.</para>
<programlisting>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a, null;
</programlisting>
  
   <para>In this example of an outer join, if the join key is missing from a table it is replaced by null.</para>
<programlisting>
A = LOAD 'student' AS (name: chararray, age: int, gpa: float);
B = LOAD 'votertab10k' AS (name: chararray, age: int, registration: chararray, donation: float);
C = COGROUP A BY name, B BY name;
D = FOREACH C GENERATE FLATTEN((IsEmpty(A) ? null : A)), FLATTEN((IsEmpty(B) ? null : B));
</programlisting>
   
   <para>Like any other expression, null constants can be implicitly or explicitly cast. </para>
   <para>In this example both a and null will be implicitly cast to double.</para>
<programlisting>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + null;
</programlisting>
   
   <para>In this example  both a and null will be cast to int, a implicitly, and null explicitly.</para>
<programlisting>
A = LOAD 'data' AS (a, b, c).
B = FOREACH A GENERATE a + (int)null;
</programlisting>
   </section>
   
   <section>
   <title>Operations That Produce Nulls</title>
   <para>As noted, nulls can be the result of an operation. These operations can produce null values: </para>
   <itemizedlist>
      <listitem>
         <para>Division by zero</para>
      </listitem>
      <listitem>
         <para>Returns from user defined functions (UDFs) </para>
      </listitem>
      <listitem>
         <para>Dereferencing a field that does not exist.</para>
      </listitem>
      <listitem>
         <para>Dereferencing a key that does not exist in a map. For example, given a map, info, containing [name#john, phone#5551212] if a user tries to use info#address a null is returned.</para>
      </listitem>
      <listitem>
         <para>Accessing a field that does not exist in a tuple. As a further explanation, see the examples below.</para>
      </listitem>
   </itemizedlist>
   
   <section>
   <title>Example: Accessing a field that does not exist in a tuple</title>
   <para>In this example nulls are injected if fields do not have data.</para>
<programlisting>
cat data;
    2   3
4   
7   8   9

A = LOAD 'data' AS (f1:int,f2:int,f3:int)

DUMP A;
(,2,3)
(4,,)
(7,8,9)

B = FOREACH A GENERATE f1,f2;

DUMP B;
(,2)
(4,)
(7,8)
</programlisting>
   
   </section></section>
   
   <section>
   <title>Nulls and Load Functions</title>
   <para>
As noted, nulls can occur naturally in the data. If nulls are part of the data, it is the responsibility of the load function to handle them correctly. Keep in mind that what is considered a null value is loader-specific; however, the load function should always communicate null values to Pig by producing Java nulls.</para>
   <para>The Pig Latin load functions (for example, PigStorage and TextLoader) produce null values wherever data is missing. For example, empty strings (chararrays) are not loaded; instead, they are replaced by nulls.</para>
   <para>PigStorage is the default load function for the LOAD operator. In this example the is not null operator is used to filter names with null values.</para>

 <programlisting>
A = LOAD 'student' AS (name, age, gpa); 
B = FILTER A BY name is not null;
</programlisting>  
   </section></section>
   
   <section>
   <title>Constants</title>
   <para>Pig provides constant representations for all data types except bytearrays.</para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>Constant Example</para>
            </entry>
            <entry>
               <para>Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Simple Data Types</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>Scalars</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>int</para>
            </entry>
            <entry>
               <para>19</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>long</para>
            </entry>
            <entry>
               <para>19L</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>float</para>
            </entry>
            <entry>
               <para>19.2F or 1.92e2f</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>double</para>
            </entry>
            <entry>
               <para>19.2 or 1.92e2</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>Arrays </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray</para>
            </entry>
            <entry>
               <para>'hello world'</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>Not applicable.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>Complex Data Types</para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple</para>
            </entry>
            <entry>
               <para>(19, 2, 1)</para>
            </entry>
            <entry>
               <para>A constant in this form creates a tuple.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag</para>
            </entry>
            <entry>
               <para>{ (19, 2), (1, 2) }</para>
            </entry>
            <entry>
               <para>A constant in this form creates a bag.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map</para>
            </entry>
            <entry>
               <para>[ 'name' # 'John', 'ext' # 5555 ]</para>
            </entry>
            <entry>
               <para>A constant in this form creates a map.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Please note the following:</para>
   <itemizedlist>
      <listitem>
         <para>On UTF-8 systems you can specify string constants consisting of printable ASCII characters such as 'abc'; you can specify control characters such as '\t'; and, you can specify a character in Unicode by starting it with '\u', for instance, '\u0001' represents Ctrl-A in hexadecimal (see Wikipedia <ulink url="http://en.wikipedia.org/wiki/ASCII">ASCII</ulink>, <ulink url="http://en.wikipedia.org/wiki/Unicode">Unicode</ulink>, and <ulink url="http://en.wikipedia.org/wiki/UTF-8">UTF-8</ulink>). In theory, you should be able to specify non-UTF-8 constants on non-UTF-8 systems but as far as we know this has not been tested.</para>
      </listitem>
      <listitem>
         <para>To specify a long constant, l or L must be appended to the number (for example, 12345678L). If the l or L is not specified, but the number is too large to fit into an int, the problem will be detected at parse time and the processing is terminated. </para>
      </listitem>
      <listitem>
         <para>Any numeric constant with decimal point (for example, 1.5) and/or exponent (for example, 5e+1) is treated as double unless it ends with f or F in which case it is assigned type float (for example,  1.5f). </para>
      </listitem>
   </itemizedlist>
   <para>The data type definitions for tuples, bags, and maps apply to constants:</para>
   <itemizedlist>
      <listitem>
         <para>A tuple can contain fields of any data type</para>
      </listitem>
      <listitem>
         <para>A bag is a collection of tuples</para>
      </listitem>
      <listitem>
         <para>A map key must be a scalar; a map value can be any data type</para>
      </listitem>
   </itemizedlist>
   <para>Complex constants can be used in the same places scalar constants can be used, that is, in FILTER and GENERATE statements.</para>

<programlisting>
A = LOAD 'data' USING MyStorage() AS (T: tuple(name:chararray, age: int));
B = FILTER A BY T == ('john', 25);
D = FOREACH B GENERATE T.name, [25#5.6], {(1, 5, 18)};
</programlisting>
   
   </section>
   
   <section>
   <title>Expressions</title>
   <para>In Pig Latin, expressions are language constructs used with the FILTER, FOREACH, GROUP, and SPLIT operators as well as the eval functions.</para>
   <para>Expressions are written in conventional mathematical infix notation and are adapted to the UTF-8 character set. Depending on the context, expressions can include:</para>
   <itemizedlist>
      <listitem>
         <para>Any Pig data type (simple data types, complex data types)</para>
      </listitem>
      <listitem>
         <para>Any Pig operator (arithmetic, comparison, null, boolean, dereference, sign, and cast)</para>
      </listitem>
      <listitem>
         <para>Any Pig built-in function.</para>
      </listitem>
      <listitem>
         <para>Any user-defined function (UDF) written in Java. </para>
       </listitem>
        </itemizedlist>
        <para></para>
       <para>In Pig Latin,</para>
        <itemizedlist>
       <listitem>
         <para>An arithmetic expression could look like this:</para>
         <programlisting>
X = GROUP A BY f2*f3;
</programlisting>
      </listitem>

      <listitem>
         <para/>
         <para>A string expression could look like this, where a and b are both chararrays:</para>
         <programlisting>
X = FOREACH A GENERATE CONCAT(a,b);
</programlisting>
      </listitem>

      <listitem>
         <para/>
         <para>A boolean expression could look like this:</para>
         <programlisting>
X = FILTER A BY (f1==8) OR (NOT (f2+f3 &gt; f1));
</programlisting>
      </listitem>
   </itemizedlist>

   </section>
   
   <section>
   <title>Schemas</title>
   <para>Schemas enable you to assign names to and declare types for fields. Schemas are optional but we encourage you to use them whenever possible; type declarations result in better parse-time error checking and more efficient code execution. </para>
   <para>Schemas are defined using the AS keyword with the LOAD, STREAM, and FOREACH operators. If you define a schema using the LOAD operator, then it is the load function that enforces the schema (see the LOAD operator and the <ulink url="http://wiki.apache.org/pig/UDFManual">User-Defined Function Manual</ulink> for more information).</para>
   <para>Note the following:</para>
   <itemizedlist>
      <listitem>
         <para>You can define a schema that includes both the field name and field type.</para>
      </listitem>
      <listitem>
         <para>You can define a schema that includes the field name only; in this case, the field type defaults to bytearray.</para>
      </listitem>
      <listitem>
         <para>You can choose not to define a schema; in this case, the field is un-named and the field type defaults to bytearray.</para>
      </listitem>
   </itemizedlist>
   <para>If you assign a name to a field, you can refer to that field using the name or by positional notation. If you don't assign a name to a field (the field is un-named) you can only refer to the field using positional notation.</para>
   <para>If you assign a type to a field, you can subsequently change the type using the cast operators. If you don't assign a type to a field, the field defaults to bytearray; you can change the default type using the cast operators.</para>
   
   <section>
   <title>Schemas with LOAD and STREAM Statements</title>
   <para>With LOAD and STREAM statements, the schema following the AS keyword must be enclosed in parentheses.</para>
   <para>In this example the LOAD statement includes a schema definition for simple data types.</para>
<programlisting>
A = LOAD 'data' AS (f1:int, f2:int);
</programlisting>   
   </section>
   
   <section>
   <title>Schemas with FOREACH Statements</title>
   <para>With FOREACH statements, the schema following the AS keyword must be enclosed in parentheses when the FLATTEN keyword is used. Otherwise, the schema should not be enclosed in parentheses.</para>
   <para>In this example the FOREACH statement includes the FLATTEN keyword and a schema for simple data types.</para>
<programlisting>
X = FOREACH C GENERATE FLATTEN(B) AS (f1:int, f2:int, f3:int);
</programlisting>  
   <para>In this example the FOREACH statement includes a schema for simple data types.</para>
<programlisting>
X = FOREACH A GENERATE f1+f2 AS x1:int;
</programlisting>   
   </section>
   
   <section>
   <title>Schemas for Simple Data Types</title>
   <para>Simple data types include int, long, float, double, chararray, and bytearray.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>(alias[:type]) [, (alias[:type]) …] )</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name assigned to the field.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>type</para>
            </entry>
            <entry>
               <para>(Optional) The simple data type assigned to the field.</para>
               <para>The alias and type are separated by a colon ( : ).</para>
               <para>If the type is omitted, the field defaults to type bytearray.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>( , )</para>
            </entry>
            <entry>
               <para>Multiple fields are enclosed in parentheses and separated by commas.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Examples</title>
   <para>In this example the schema defines multiple types.</para>
<programlisting>
cat student;
John	18	4.0
Mary	19   	3.8
Bill	20   	3.9
Joe	18   	3.8

A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</programlisting>
   
   <para>In this example field "gpa" will default to bytearray because no type is declared. </para>
<programlisting>
cat student;
John	18	4.0
Mary	19	3.8
Bill	20	3.9
Joe	18	3.8

A = LOAD 'data' AS (name:chararray, age:int, gpa);

DESCRIBE A;
A: {name: chararray,age: int,gpa: bytearray}

DUMP A;
(John,18,4.0)
(Mary,19,3.8)
(Bill,20,3.9)
(Joe,18,3.8)
</programlisting>
   
   </section></section>
   
   <section>
   <title>Schemas for Complex Data Types</title>
   <para>Complex data types include tuples, bags, and maps.</para></section>
   
   <section>
   <title>Tuple Schema</title>
   <para>A tuple is an ordered set of fields.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias[:tuple] (alias[:type]) [, (alias[:type]) …] )</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name assigned to the tuple.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>:tuple</para>
            </entry>
            <entry>
               <para>(Optional) The data type, tuple (case insensitive).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>( )</para>
            </entry>
            <entry>
               <para>The designation for a tuple, a set of parentheses.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>alias[:type]</para>
            </entry>
            <entry>
               <para>The constituents of the tuple, where the schema definition rules for the corresponding type applies to the constituents of the tuple:</para>
               <itemizedlist>
                  <listitem>
                     <para>alias – the name assigned to the field</para>
                  </listitem>
                  <listitem>
                     <para>type (optional) – the simple or complex data type assigned to the field</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section><title>Examples</title>
   <para>In this example the schema defines one tuple. The load statements are equivalent.</para>

 <programlisting>
cat data;
(3,8,9)
(1,4,7)
(2,5,8)

A = LOAD 'data' AS (T: tuple (f1:int, f2:int, f3:int));
A = LOAD 'data' AS (T: (f1:int, f2:int, f3:int));

DESCRIBE A;
A: {T: (f1: int,f2: int,f3: int)}

DUMP A;
((3,8,9))
((1,4,7))
((2,5,8))
</programlisting>
   
   <para>In this example the schema defines two tuples.</para>
<programlisting>
cat data;
(3,8,9) (mary,19)
(1,4,7) (john,18)
(2,5,8) (joe,18)

A = LOAD data AS (F:tuple(f1:int,f2:int,f3:int),T:tuple(t1:chararray,t2:int));

DESCRIBE A;
A: {F: (f1: int,f2: int,f3: int),T: (t1: chararray,t2: int)}

DUMP A;
((3,8,9),(mary,19))
((1,4,7),(john,18))
((2,5,8),(joe,18))
</programlisting>
   </section></section>
   
   <section>
   <title>Bag Schema</title>
   <para>A bag is a collection of tuples.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias[:bag] {tuple} </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name assigned to the bag.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>:bag</para>
            </entry>
            <entry>
               <para>(Optional) The data type, bag (case insensitive).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>{ }</para>
            </entry>
            <entry>
               <para>The designation for a bag, a set of curly brackets.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple</para>
            </entry>
            <entry>
               <para>A tuple (see Tuple Schema).</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Examples</title>
   <para>In this example the schema defines a bag. The two load statements are equivalent.</para>
<programlisting>
cat data;
{(3,8,9)}
{(1,4,7)}
{(2,5,8)}

A = LOAD 'data' AS (B: bag {T: tuple(t1:int, t2:int, t3:int)});
A = LOAD 'data' AS (B: {T: (t1:int, t2:int, t3:int)});

DESCRIBE A:
A: {B: {T: (t1: int,t2: int,t3: int)}}

DUMP A;
({(3,8,9)})
({(1,4,7)})
({(2,5,8)})
</programlisting>
   </section></section>
   
   <section>
   <title>Map Schema</title>
   <para>A map is a set of key value pairs.</para>
   
   <section>
   <title>Syntax (where &lt;&gt; means optional)</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias&lt;:map&gt; [ ] </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name assigned to the map.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>:map</para>
            </entry>
            <entry>
               <para>(Optional) The data type, map (case insensitive).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>[ ]   </para>
            </entry>
            <entry>
               <para>The designation for a map, a set of straight brackets [ ].</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section><title>Example</title>
   <para>In this example the schema defines a map. The load statements are equivalent.</para>
<programlisting>
cat data;
[open#apache]
[apache#hadoop]

A = LOAD 'data' AS (M:map []);
A = LOAD 'data' AS (M:[]);

DESCRIBE A;
a: {M: map[ ]}

DUMP A;
([open#apache])
([apache#hadoop])
</programlisting>
    </section></section>
   
   <section>
   <title>Schemas for Multiple Types</title>
   <para>You can define schemas for data that includes multiple types.</para>
   
   <section>
   <title>Example</title>
   <para>In this example the schema defines a tuple, bag, and map.</para>
<programlisting>
A = LOAD 'mydata' AS (T1:tuple(f1:int, f2:int), B:bag{T2:tuple(t1:float,t2:float)}, M:map[] );

A = LOAD 'mydata' AS (T1:(f1:int, f2:int), B:{T2:(t1:float,t2:float)}, M:[] );
</programlisting>
   
   </section></section></section>
   
   <section>
   <title>Parameter Substitution</title>
   
   <section>
   <title>Description</title>
   <para>Substitute values for parameters at run time.</para>
   
   <section>
   <title>Syntax: Specifying parameters using the Pig command line</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>pig {–param param_name = param_value | –param_file file_name} [-debug | -dryrun] script</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Syntax: Specifying parameters using preprocessor statements in a Pig script</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>{%declare | %default} param_name param_value</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>pig</para>
            </entry>
            <entry>
               <para>Keyword</para>
               <para>Note: exec, run, and explain also support parameter substitution.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>–param</para>
            </entry>
            <entry>
               <para>Flag. Use this option when the parameter is included in the command line.</para>
               <para>Multiple parameters can be specified. If the same parameter is specified multiple times, the last value will be used and a warning will be generated.</para>
               <para>Command line parameters and parameter files can be combined with command line parameters taking precedence. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>param_name</para>
            </entry>
            <entry>
               <para>The name of the parameter.</para>
               <para>The parameter name has the structure of a standard language identifier: it must start with a letter or underscore followed by any number of letters, digits, and underscores. </para>
               <para>Parameter names are case insensitive. </para>
               <para>If you pass a parameter to a script that the script does not use, this parameter is silently ignored. If the script has a parameter and no value is supplied or substituted, an error will result.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>param_value</para>
            </entry>
            <entry>
               <para>The value of the parameter. </para>
               <para>A parameter value can take two forms:</para>
               <itemizedlist>
                  <listitem>
                     <para>A sequence of characters enclosed in single or double quotes. In this case the unquoted version of the value is used during substitution. Quotes within the value can be escaped with the backslash character ( \ ). Single word values that don't use special characters such as % or = don't have to be quoted. </para>
                  </listitem>
                  <listitem>
                     <para>A command enclosed in back ticks. </para>
                  </listitem>
               </itemizedlist>
               <para>The value of a parameter, in either form, can be expressed in terms of other parameters as long as the values of the dependent parameters are already defined.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>–param_file</para>
            </entry>
            <entry>
               <para>Flag. Use this option when the parameter is included in a file. </para>
               <para>Multiple files can be specified. If the same parameter is present multiple times in the file, the last value will be used and a warning will be generated. If a parameter present in multiple files, the value from the last file will be used and a warning will be generated.</para>
               <para>Command line parameters and parameter files can be combined with command line parameters taking precedence. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>file_name</para>
            </entry>
            <entry>
               <para>The name of a file containing one or more parameters.</para>
               <para>A parameter file will contain one line per parameter. Empty lines are allowed. Perl-style (#) comment lines are also allowed. Comments must take a full line and # must be the first character on the line. Each parameter line will be of the form: param_name = param_value. White spaces around = are allowed but are optional.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>–debug</para>
            </entry>
            <entry>
               <para>Flag. With this option, the script is run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>–dryrun</para>
            </entry>
            <entry>
               <para>Flag. With this option, the script is not run and a fully substituted Pig script produced in the current working directory named original_script_name.substituted</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>script</para>
            </entry>
            <entry>
               <para>A pig script. The pig script must be the last element in the Pig command line.</para>
               <itemizedlist>
                  <listitem>
                     <para>If parameters are specified in the Pig command line or in a parameter file, the script should include a $param_name for each para_name included in the command line or parameter file.</para>
                  </listitem>
                  <listitem>
                     <para>If parameters are specified using the preprocessor statements, the script should include either %declare or %default.</para>
                  </listitem>
                  <listitem>
                     <para>In the script, parameter names can be escaped with the backslash character ( \ ) in which case substitution does not take place.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>%declare</para>
            </entry>
            <entry>
               <para>Preprocessor statement included in a Pig script.</para>
               <para>Use to describe one parameter in terms of other parameters.</para>
               <para>The declare statement is processed prior to running the Pig script. </para>
               <para>The scope of a parameter value defined using declare is all the lines following the declare statement until the next declare statement that defines the same parameter is encountered.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>%default</para>
            </entry>
            <entry>
               <para>Preprocessor statement included in a Pig script.</para>
               <para>Use to provide a default value for a parameter. The default value has the lowest priority and is used if a parameter value has not been defined by other means.</para>
               <para>The default statement is processed prior to running the Pig script. </para>
               <para>The scope is the same as for %declare.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Parameter substitution enables you to write Pig scripts that include parameters and to supply values for these parameters at run time. For instance, suppose you have a job that needs to run every day using the current day's data. You can create a Pig script that includes a parameter for the date. Then, when you run this script you can specify or supply a value for the date parameter using one of the supported methods. </para>
   
   <section>
   <title>Specifying Parameters </title>
   <para>You can specify parameter names and parameter values as follows:</para>
   <itemizedlist>
      <listitem>
         <para>As part of a command line.</para>
      </listitem>
      <listitem>
         <para>In parameter file, as part of a command line.</para>
      </listitem>
      <listitem>
         <para>With the declare statement, as part of Pig script.</para>
      </listitem>
      <listitem>
         <para>With default statement, as part of a Pig script.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Precedence</title>
   <para>Precedence for parameters is as follows:</para>
   <itemizedlist>
      <listitem>
         <para>Highest - parameters defined using the declare statement</para>
      </listitem>
      <listitem>
         <para>Next - parameters defined in the command line</para>
      </listitem>
      <listitem>
         <para>Lowest - parameters defined in a script</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Processing Order and Precedence</title>
   <para>Parameters are processed as follows:</para>
   <itemizedlist>
      <listitem>
         <para>Command line parameters are scanned in the order they are specified on the command line. </para>
      </listitem>
      <listitem>
         <para>Parameter files are scanned in the order they are specified on the command line. Within each file, the parameters are processed in the order they are listed. </para>
      </listitem>
      <listitem>
         <para>Declare and default preprocessors statements are processed in the order they appear in the Pig script. </para>
      </listitem>
   </itemizedlist></section></section>
   
   <section>
   <title>Example: Specifying parameters in the command line</title>
   <para>Suppose we have a data file called 'mydata' and a pig script called 'myscript.pig'.</para>

<para>mydata </para>
<programlisting>
1       2       3
4       2       1
8       3       4
</programlisting>
 
 <para>myscript.pig</para>
<programlisting>
A = LOAD '$data' USING PigStorage() AS (f1:int, f2:int, f3:int);
DUMP A;
</programlisting>

<para>In this example the parameter (data) and the parameter value (mydata) are specified in the command line. If the parameter name in the command line (data) and the parameter name in the script ($data) do not match, the script will not run. If the value for the parameter (mydata) is not found, an error is generated.</para>
<programlisting>
$ pig –param data=mydata myscript.pig

(1,2,3)
(4,2,1)
(8,3,4)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Specifying parameters using a parameter file</title>
   <para>Suppose we have a parameter file called 'myparams.'</para>
<programlisting>
# my parameters
data1 = mydata1
cmd = `generate_name`
</programlisting>

   
   <para>In this example the parameters and values are passed to the script using the parameter file.</para>
<programlisting>
$ pig –param_file myparams script2.pig
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Specifying parameters using the declare statement</title>
   <para>In this example the command is executed and its stdout is used as the parameter value.</para>
<programlisting>
%declare CMD `generate_date`;
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';

<emphasis>etc...</emphasis></programlisting>
   
   </section>
   
   <section>
   <title>Example: Specifying parameters using the default statement</title>
   <para>In this example the parameter (DATE) and value ('20090101') are specified in the Pig script using the default statement. If a value for DATE is not specified elsewhere, the default value 20090101 is used.</para>
<programlisting>
%default DATE '20090101';
A = load '/data/mydata/$DATE';

<emphasis>etc...</emphasis></programlisting>

   </section>
   
   <section>
   <title>Examples: Specifying parameter values as a sequence of characters</title>
   <para>In this example the characters (in this case, Joe's URL) can be enclosed in single or double quotes, and quotes within the sequence of characters can be escaped. </para>
<programlisting>
%declare DES 'Joe\'s URL';
A = LOAD 'data' AS (name, description, url);
B = FILTER A BY description == '$DES';
 
<emphasis>etc...</emphasis></programlisting>
   
   <para>In this example single word values that don't use special characters (in this case, mydata) don't have to be enclosed in quotes.</para>
<programlisting>
$ pig –param data=mydata myscript.pig
</programlisting>   
</section>
   
   <section>
   <title>Example: Specifying parameter values as a command</title>
   <para>In this example the command is enclosed in back ticks. First, the parameters mycmd and date are substituted when the declare statement is encountered. Then the resulting command is executed and its stdout is placed in the path before the load statement is run.</para>
<programlisting>
%declare CMD `$mycmd $date`;
A = LOAD '/data/mydata/$CMD';
B = FILTER A BY $0>'5';
 
<emphasis>etc...</emphasis></programlisting>
   </section>
   </section>
   </section>
   </section>

   
<!-- ARITHMETIC OPERATORS, ETC -->
<section>
	<title>Arithmetic Operators and More</title>

<section>
<title>Arithmetic Operators</title>

<section>
<title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>addition </para>
            </entry>
            <entry>
               <para>+</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>subtraction </para>
            </entry>
            <entry>
               <para>-</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>multiplication  </para>
            </entry>
            <entry>
               <para>*</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>division  </para>
            </entry>
            <entry>
               <para>/</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>modulo  </para>
            </entry>
            <entry>
               <para>%</para>
            </entry>
            <entry>
               <para>Returns the remainder of a divided by b (a%b).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bincond </para>
            </entry>
            <entry>
               <para>? :</para>
            </entry>
            <entry>
               <para>(condition ? value_if_true : value_if_false) </para>
               <para>The bincond should be enclosed in parenthesis. </para>
               <para>The schemas for the two conditional outputs of the bincond should match.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>

   <section>
   <title>Examples </title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' AS (f1:int, f2:int, B:bag{T:tuple(t1:int,t2:int)});

DUMP A;
(10,1,{(2,3),(4,6)})
(10,3,{(2,3),(4,6)})
(10,6,{(2,3),(4,6),(5,7)})
</programlisting>

  <para>In this example the modulo operator is used with fields f1 and f2.</para>
<programlisting>
X = FOREACH A GENERATE f1, f2, f1%f2;

DUMP X;
(10,1,0)
(10,3,1)
(10,6,4)
</programlisting>
   
   <para>In this example the bincond operator is used with fields f2 and B. The condition is "f2 equals 1"; if the condition is true, return 1; if the condition is false, return the count of the number of tuples in B.</para>
<programlisting>
X = FOREACH A GENERATE f2, (f2==1?1:COUNT(B));

DUMP X;
(1,1L)
(3,2L)
(6,3L)
</programlisting>
   </section>
   
   <section>
   <title> Types Table: addition (+) and subtraction (-) operators</title>
   <para>* bytearray cast as this data type</para>
   <informaltable frame="all">
      <tgroup cols="7">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/>
         <colspec colnum="4" colname="c4"/>
         <colspec colnum="5" colname="c5"/>
         <colspec colnum="6" colname="c6"/>
         <colspec colnum="7" colname="c7"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as int </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as long  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as float  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as double   </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>cast as double </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   </section>
   
   <section>
   <title>Types Table: multiplication (*) and division (/) operators</title>
   <para>* bytearray cast as this data type</para>
   <informaltable frame="all">
      <tgroup cols="10">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/>
         <colspec colnum="4" colname="c4"/>
         <colspec colnum="5" colname="c5"/>
         <colspec colnum="6" colname="c6"/>
         <colspec colnum="7" colname="c7"/>
         <colspec colnum="8" colname="c8"/>
         <colspec colnum="9" colname="c9"/>
         <colspec colnum="10" colname="c10"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>not yet </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as int </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as long </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as float </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as double  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>cast as double  </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   </section>
   
   <section>
   <title>Types Table: modulo (%) operator</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>cast as int </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>cast as long </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   </section></section></section>
   
   <section>
   <title>Comparison Operators</title>
      
    <section><title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>equal  </para>
            </entry>
            <entry>
               <para>==</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>not equal </para>
            </entry>
            <entry>
               <para>!=</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>less than  </para>
            </entry>
            <entry>
               <para>&lt;</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>greater than </para>
            </entry>
            <entry>
               <para>&gt;</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>less than or equal to  </para>
            </entry>
            <entry>
               <para>&lt;=</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>greater than or equal to</para>
            </entry>
            <entry>
               <para>&gt;=</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>pattern matching  </para>
            </entry>
            <entry>
               <para>matches</para>
            </entry>
            <entry>
               <para>Regular expression matching.  Use the Java <ulink url="http://java.sun.com/j2se/1.5.0/docs/api/java/util/regex/Pattern.html">format</ulink> for regular expressions.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Use the comparison operators with numeric and string data.</para>
   
   <section>
   <title>Example: numeric</title>
<programlisting>
X = FILTER A BY (f1 == 8);
</programlisting>
   </section>
   
   <section>
   <title>Example: string</title>
<programlisting>
X = FILTER A BY (f2 == 'apache');
</programlisting>
   </section>
   
   <section>
   <title>Example: matches</title>
<programlisting>
X = FILTER A BY (f1 matches '.*apache.*');
</programlisting>
   </section>
   
   <section>
   <title>Types Table: equal (==) and not equal (!=) operators</title>
   <para>* bytearray cast as this data type</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean (see Note 1) </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
               <para>(see Note 2)</para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as boolean </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as boolean </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as boolean  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as boolean  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>cast as boolean </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Note 1: boolean (Tuple A is equal to tuple B if they have the same size s, and for all 0 &lt;= i &lt; s A[i] = = B[i])</para>
   <para>Note 2: boolean (Map A is equal to map B if A and B have the same number of entries, and for every key k1 in A with a value of v1, there is a key k2 in B with a value of v2, such that k1 = = k2 and v1 = = v2)</para>
   </section>
   
   <section>
   <title></title>
   <informaltable frame="all">
      <tgroup cols="5">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/>
         <colspec colnum="4" colname="c4"/>
         <colspec colnum="5" colname="c5"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>boolean (bytearray cast as int) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>boolean (bytearray cast as long) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>boolean (bytearray cast as float) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>boolean (bytearray cast as double) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean (bytearray cast as chararray) </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Types Table: matches operator</title>
   <para>*Cast as chararray (the second argument must be chararray)</para>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray* </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
            <entry>
               <para>boolean  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para>boolean</para>
            </entry>
            <entry>
               <para>boolean </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section></section>
   
   <section>
   <title>Null Operators</title>
     
   <section>
   <title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>is null        </para>
            </entry>
            <entry>
               <para>is null</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>is not null  </para>
            </entry>
            <entry>
               <para>is not null  </para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   
   <section>
   <title>Example</title>
<programlisting>
X = FILTER A BY f1 is not null;
</programlisting>
   </section></section>
   
   <section>
   <title>Types Table</title>
   <para>The null operators can be applied to all data types. For more information, see Nulls.</para></section></section>
   
   <section>
   <title>Boolean Operators</title>
      
      <section>
      <title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>AND       </para>
            </entry>
            <entry>
               <para>and</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>OR  </para>
            </entry>
            <entry>
               <para>or</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>NOT</para>
            </entry>
            <entry>
               <para>not</para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Pig does not support a boolean data type. However, the result of a boolean expression (an expression that includes boolean and comparison operators) is always of type boolean (true or false).</para>
   
   <section>
   <title>Example</title>
<programlisting>
X = FILTER A BY (f1==8) OR (NOT (f2+f3 > f1));
</programlisting>
   
   </section></section></section>
   
   <section>
   <title>Dereference Operators</title>
   
   <section>
   <title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple dereference      </para>
            </entry>
            <entry>
               <para>. (dot)</para>
            </entry>
            <entry>
               <para>Retrieve a field from a tuple. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag dereference</para>
            </entry>
            <entry>
               <para>. (dot)</para>
            </entry>
            <entry>
               <para>Retrieve a column from a bag. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map dereference</para>
            </entry>
            <entry>
               <para># </para>
            </entry>
            <entry>
               <para>For a key#value pair, look up the value for the specified key.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para>Note the following:</para>
   <itemizedlist>
      <listitem>
         <para>Tuple dereferencing can be done by name (tuple.field_name) or position (mytuple.$0). Note that if the dot operator is applied to a bytearray, the bytearray will be assumed to be a tuple.</para>
      </listitem>
      <listitem>
         <para>Bag dereferencing can be done by name (bag.field_name) or position (bag.$0). </para>
      </listitem>
      <listitem>
         <para>Map dereferencing must be done by key (field_name#key or $0#key). If the pound operator is applied to a bytearray, the bytearray is assumed to be a map. If the key does not exist, the empty string is returned.</para>
      </listitem>
   </itemizedlist>
   
   <section>
   <title>Example: Tuple</title>
   <para>Suppose we have relation A.</para>

<programlisting>
LOAD 'data' as (f1:int, f2:tuple(t1:int,t2:int,t3:int));

DUMP A;
(1,(1,2,3))
(2,(4,5,6))
(3,(7,8,9))
(4,(1,4,7))
(5,(2,5,8))
</programlisting>
   
   <para>In this example dereferencing is used to retrieve two fields from tuple f2.</para>
<programlisting>
X = FOREACH A GENERATE f2.t1,f2.t3;

DUMP X;
(1,3)
(4,6)
(7,9)
(1,7)
(2,8)
</programlisting>
   </section>
   
   <section>
   <title>Example: Bag</title>
   <para>Suppose we have relation B, formed by grouping relation A (see the GROUP operator for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'data' AS (f1:int, f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

ILLUSTRATE B;
<emphasis>etc …</emphasis>
----------------------------------------------------------
| b   | group: int | a: bag({f1: int,f2: int,f3: int}) |
----------------------------------------------------------
</programlisting>
   
<para>In this example dereferencing is used with relation X to project the first field (f1) of each tuple in the bag (a).</para>
<programlisting>
X = FOREACH B GENERATE a.f1;

DUMP X;
({(1)})
({(4),(4)})
({(7)})
({(8),(8)})
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Tuple and Bag</title>
    <para>Suppose we have relation B, formed by grouping relation A  (see the GROUP operator for information about the field names in relation B).</para>

   
<programlisting>
A = LOAD 'data' AS (f1:int, f2:int, f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY (f1,f2);

DUMP B;
((1,2),{(1,2,3)})
((4,2),{(4,2,1)})
((4,3),{(4,3,3)})
((7,2),{(7,2,5)})
((8,3),{(8,3,4)})
((8,4),{(8,4,3)})

ILLUSTRATE B;
<emphasis>etc …</emphasis>
-------------------------------------------------------------------------------
| b     | group: tuple({f1: int,f2: int}) | a: bag({f1: int,f2: int,f3: int}) |
-------------------------------------------------------------------------------
|       | (8, 3)                                | {(8, 3, 4), (8, 3, 4)} |
-------------------------------------------------------------------------------
</programlisting>   
   
   <para>In this example dereferencing is used to project a field (f1) from a tuple (group) and a field (f1) from a bag (a).</para>
<programlisting>
X = FOREACH B GENERATE group.f1, a.f1;

DUMP X;
(1,{(1)})
(4,{(4)})
(4,{(4)})
(7,{(7)})
(8,{(8)})
(8,{(8)})
</programlisting>
   </section>
   
   <section>
   <title>Example: Map</title>
   <para>Suppose we have relation A. </para>

<programlisting>
A = LOAD 'data' AS (f1:int, f2:map[]);

DUMP A;
(1,[open#apache])
(2,[apache#hadoop])
(3,[hadoop#pig])
(4,[pig#grunt])
</programlisting>

   <para>In this example dereferencing is used to look up the value of key 'open'.</para>

<programlisting>
X = FOREACH A GENERATE f2#'open';

DUMP X;
(apache)
()
()
()
</programlisting>
  </section></section></section>
   
   <section>
   <title>Sign Operators</title>
   
   <section>
   <title>Description</title>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Operator</para>
            </entry>
            <entry>
               <para>Symbol</para>
            </entry>
            <entry>
               <para> Notes</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>positive       </para>
            </entry>
            <entry>
               <para>+</para>
            </entry>
            <entry>
               <para> Has no effect.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>negative (negation)</para>
            </entry>
            <entry>
               <para> -</para>
            </entry>
            <entry>
               <para> Changes the sign of a positive or negative number.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   
   <section>
   <title>Example</title>
<programlisting>
A = LOAD 'data' as (x, y, z);

B = FOREACH A GENERATE -x, y;
</programlisting>
   
   </section>
   
   <section>
   <title>Types Table: negation ( - ) operator</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para>double (as double) </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section></section>
   
   <section>
   <title>Cast Operators</title>
   
   <section>
   <title>Description</title>
   <para>Pig Latin supports casts as shown in this table. </para>
   <informaltable frame="all">
      <tgroup cols="6">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/>
         <colspec colnum="4" colname="c4"/>
         <colspec colnum="5" colname="c5"/>
         <colspec colnum="6" colname="c6"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>to </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>from </para>
            </entry>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error</para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>error </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para>yes </para>
            </entry>
            <entry>
               <para/>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   
   <section>
   <title>Syntax  </title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>{(data_type) |  (tuple(data_type))  | (bag{tuple(data_type)}) | (map[]) } field</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>(data_type)</para>
            </entry>
            <entry>
               <para>The data type you want to cast to, enclosed in parentheses. You can cast to any data type except bytearray (see the table above).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field</para>
            </entry>
            <entry>
               <para>The field whose type you want to change. </para>
               <para>The field can be represented by positional notation or by name (alias). For example, if f1 is the first field and type int, you can cast to type long using (long)$0 or (long)f1.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Cast operators enable you to cast or convert data from one type to another, as long as conversion is supported (see the table above). For example, suppose you have an integer field, myint, which you want to convert to a string. You can cast this field from int to chararray using (chararray)myint.</para>
   <para>Please note the following:</para>
   <itemizedlist>
      <listitem>
         <para>A field can be explicitly cast. Once cast, the field remains that type (it is not automatically cast back). In this example $0 is explicitly cast to int.</para>
      </listitem>
   </itemizedlist>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>B = FOREACH A GENERATE (int)$0 + 1;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   <itemizedlist>
      <listitem>
         <para>Where possible, Pig performs implicit casts. In this example $0 is cast to int (regardless of underlying data) and $1 is cast to double.</para>
      </listitem>
   </itemizedlist>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>B = FOREACH A GENERATE $0 + 1, $1 + 1.0</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <itemizedlist>
      <listitem>
         <para>When two bytearrays are used in arithmetic expressions or with built-in aggregate functions (such as SUM) they are implicitly cast to double. If the underlying data is really int or long, you’ll get better performance by declaring the type or explicitly casting the data.</para>
      </listitem>
      <listitem>
         <para>Downcasts may cause loss of data. For example casting from long to int may drop bits.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Examples</title>
   <para>In this example an int is cast to type chararray (see relation X).</para>
<programlisting>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

DESCRIBE B;
B: {group: int,A: {f1: int,f2: int,f3: int}}

X = FOREACH B GENERATE group, (chararray)COUNT(A) AS total;
(1,1)
(4,2)
(7,1)
(8,2)

DESCRIBE X;
X: {group: int,total: chararray}
</programlisting>
   
   
<para>In this example a bytearray (fld in relation A) is cast to type tuple.</para>
<programlisting>
cat data;
(1,2,3)
(4,2,1)
(8,3,4)

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
a: {fld: bytearray}

DUMP A;
((1,2,3))
((4,2,1))
((8,3,4))

B = FOREACH A GENERATE (tuple(int,int,float))fld;

DESCRIBE B;
b: {(int,int,float)}

DUMP B;
((1,2,3))
((4,2,1))
((8,3,4))
</programlisting>
   
   <para>In this example a bytearray (fld in relation A) is cast to type bag.</para>
<programlisting>
cat data;
{(4829090493980522200L)}
{(4893298569862837493L)}
{(1297789302897398783L)}

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})

B = FOREACH A GENERATE (bag{tuple(long)})fld; 

DESCRIBE B;
B: {{(long)}}

DUMP B;
({(4829090493980522200L)})
({(4893298569862837493L)})
({(1297789302897398783L)})
</programlisting>


   <para>In this example a bytearray (fld in relation A) is cast to type map.</para>
<programlisting>
cat data;
[open#apache]
[apache#hadoop]
[hadoop#pig]
[pig#grunt]

A = LOAD 'data' AS fld:bytearray;

DESCRIBE A;
A: {fld: bytearray}

DUMP A;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])

B = FOREACH A GENERATE ((map[])fld;

DESCRIBE B;
B: {map[ ]}

DUMP B;
([open#apache])
([apache#hadoop])
([hadoop#pig])
([pig#grunt])
</programlisting>
   
</section></section></section> 
</section>

<!-- RELATIONAL OPERATORS, ETC -->
   
   <section>
   <title>Relational Operators</title>

<section>
<title>COGROUP</title>
   <para>Groups the data in two or more relations.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias =COGROUP alias BY field_alias [INNER | OUTER] , alias  BY field_alias [INNER | OUTER] [PARALLEL n] ;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field_alias</para>
            </entry>
            <entry>
               <para>The name of one or more fields in a relation. </para>
               <para>If multiple fields are specified, separate with commas and enclose in parentheses. For example, X = COGROUP A BY (f1, f2);</para>
               <para>The number of fields specified in each BY clause must match. For example, X = COGROUP A BY (a1,a2,a3), B BY (b1,b2,b3);</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BY</para>
            </entry>
            <entry>
               <para>Keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>INNER</para>
            </entry>
            <entry>
               <para>Keyword. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>OUTER</para>
            </entry>
            <entry>
               <para>Keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The COGOUP operator groups the data in two or more relations based on the common field values. Note that the COGROUP and JOIN operators perform similar functions. COGROUP creates a nested set of output tuples while JOIN creates a flat set of output tuples.</para></section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have two relations, A and B.</para>
<programlisting>
A = LOAD 'data1' AS (owner:chararray,pet:chararray);

DUMP A;
(Alice,turtle)
(Alice,goldfish)
(Alice,cat)
(Bob,dog)
(Bob,cat)

B = LOAD 'data2' AS (friend1:chararray,friend2:chararray);

DUMP B;
(Cindy,Alice)
(Mark,Alice)
(Paul,Bob)
(Paul,Jane)
</programlisting>
   
   <para>In this example tuples are co-grouped using field “owner” from relation A and field “friend2” from relation B as the key fields. The DESCRIBE operator shows the schema for relation X, which has two fields, "group" and "A" (see the GROUP operator for information about the field names).</para>
<programlisting>
X = COGROUP A BY owner, B BY friend2;

DESCRIBE X;
X: {group: chararray,A: {owner: chararray,pet: chararray},b: {firend1: chararray,friend2: chararray}}
</programlisting>
   
   <para>Relation X looks like this. A tuple is created for each unique key field. The tuple includes the key field and two bags. The first bag is the tuples from the first relation with the matching key field. The second bag is the tuples from the second relation with the matching key field. If no tuples match the key field, the bag is empty.</para>
<programlisting>
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
</programlisting>
   
   <para>In this example tuples are co-grouped and the INNER keyword is used to ensure that only bags with at least one tuple are returned. </para>
<programlisting>
X = COGROUP A BY owner INNER, B BY friend2 INNER;

DUMP X;
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
</programlisting>
   
   <para>In this example tuples are co-grouped and the INNER keyword is used asymmetrically on only one of the relations.</para>
<programlisting>
X = COGROUP A BY owner, B BY friend2 INNER;

DUMP X;
(Bob,{(Bob,dog),(Bob,cat)},{(Paul,Bob)})
(Jane,{},{(Paul,Jane)})
(Alice,{(Alice,turtle),(Alice,goldfish),(Alice,cat)},{(Cindy,Alice),(Mark,Alice)})
</programlisting>
   
   </section></section>
   
   <section>
   <title>CROSS</title>
   <para>Computes the cross product of two or more relations.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = CROSS alias, alias [, alias …] [PARALLEL n];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the CROSS operator to compute the cross product (Cartesian product) of two or more relations.</para>
   <para>CROSS is an expensive operation and should be used sparingly. </para></section>
   
   <section>
   <title>Example</title>
   <para>Suppose we have relations A and B.</para>
<programlisting>
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
</programlisting>
   
<para>In this example the cross product of relation A and B is computed.</para>
<programlisting>
X = CROSS A, B;

DUMP X;
(1,2,3,2,4)
(1,2,3,8,9)
(1,2,3,1,3)
(4,2,1,2,4)
(4,2,1,8,9)
(4,2,1,1,3)
</programlisting>
   
   </section></section>
   
   <section>
   <title>DISTINCT </title>
   <para>Removes duplicate tuples in a relation.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = DISTINCT alias [PARALLEL n];        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of the relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the DISTINCT operator to remove duplicate tuples in a relation. DISTINCT does not preserve the original order of the contents (to eliminate duplicates, Pig must first sort the data). You cannot use DISTINCT on a subset of fields. To do this, use FOREACH … GENERATE to select the fields, and then use DISTINCT.</para></section>
   
   <section>
   <title>Example</title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(8,3,4)
(1,2,3)        
(4,3,3)        
(4,3,3)        
(1,2,3) 
</programlisting>
   
   <para>In this example all duplicate tuples are removed.</para>
<programlisting>
X = DISTINCT A;

DUMP X;
(1,2,3)
(4,3,3)
(8,3,4)
</programlisting>

   </section></section>
   
   <section>
   <title>DUMP</title>
   <para>Displays the contents of a relation.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>DUMP alias;        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the DUMP operator to run (execute) a Pig Latin statement and to display the contents of an alias. You can use DUMP as a debugging device to make sure the results you are expecting are being generated.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example a dump is performed after each statement.</para>
<programlisting>
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

DUMP A;
(John,18,4.0F)
(Mary,19,3.7F)
(Bill,20,3.9F)
(Joe,22,3.8F)
(Jill,20,4.0F)

B = FILTER A BY name matches 'J.+';

DUMP B;
(John,18,4.0F)
(Joe,22,3.8F)
(Jill,20,4.0F)
</programlisting>
</section></section>
   
   <section>
   <title>FILTER </title>
   <para>Selects tuples from a relation based on some condition.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = FILTER alias  BY expression;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of the relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BY</para>
            </entry>
            <entry>
               <para>Required keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the FILTER operator to work with tuples or rows of data (if you want to work with columns of data, use the FOREACH …GENERATE operation).</para>
   <para>FILTER is commonly used to select the data that you want; or, conversely, to filter out (remove) the data you don’t want.</para></section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</programlisting>
   
   <para>In this example the condition states that if the third field equals 3, then include the tuple with relation X.</para>
<programlisting>
X = FILTER A BY f3 == 3;

DUMP X;
(1,2,3)
(4,3,3)
(8,4,3)
</programlisting>
   
<para>In this example the condition states that if the first field equals 8 or if the sum of fields f2 and f3 is not greater than first field, then include the tuple relation X.</para>
<programlisting>
X = FILTER A BY (f1 == 8) OR (NOT (f2+f3 > f1));

DUMP X;
(4,2,1)
(8,3,4)
(7,2,5)
(8,4,3)
</programlisting>

   </section></section>
   
   <section>
   <title>FOREACH … GENERATE</title>
   <para>Generates data transformations based on columns of data.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias  = FOREACH { gen_blk | nested_gen_blk } [AS schema];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias </para>
            </entry>
            <entry>
               <para>The name of relation (outer bag).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>gen_blk</para>
            </entry>
            <entry>
               <para>FOREACH … GENERATE used with a relation (outer bag). Use this syntax:</para>
               <para/>
               <para>alias = FOREACH alias GENERATE expression [expression ….]</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>nested_gen_blk</para>
            </entry>
            <entry>
               <para>FOREACH … GENERATE used with a inner bag. Use this syntax:</para>
               <para/>
               <para>alias = FOREACH nested_alias {</para>
               <para>   alias = nested_op; [alias = nested_op; …]</para>
               <para>   GENERATE expression [expression ….]</para>
               <para>};</para>
               <para/>
               <para>Where:</para>
               <para>The nested block is enclosed in opening and closing brackets { … }. </para>
               <para>The GENERATE keyword must be the last statement within the nested block.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>nested_alias</para>
            </entry>
            <entry>
               <para>The name of the inner bag.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>nested_op</para>
            </entry>
            <entry>
               <para>Allowed operations are DISTINCT, FILTER, LIMIT, ORDER and SAMPLE. </para>
               <para>The FOREACH … GENERATE operation itself is not allowed since this could lead to an arbitrary number of nesting levels.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>AS</para>
            </entry>
            <entry>
               <para>Keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>schema</para>
            </entry>
            <entry>
               <para>A schema using the AS keyword (see Schemas).</para>
               <itemizedlist>
                  <listitem>
                     <para>If the FLATTEN keyword is used, enclose the schema in parentheses.</para>
                  </listitem>
                  <listitem>
                     <para>If the FLATTEN keyword is not used, don't enclose the schema in parentheses.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the FOREACH …GENERATE operation to work with columns of data (if you want to work with tuples or rows of data, use the FILTER operation).</para>
  
   <para>FOREACH …GENERATE works with relations (outer bags) as well as inner bags:</para>
   <itemizedlist>
      <listitem>
         <para>If A is a relation (outer bag), a FOREACH statement could look like this.</para>
<programlisting>
X = FOREACH A GENERATE f1;
</programlisting>
      </listitem>
      <listitem>
         <para>If A is an inner bag, a FOREACH statement could look like this.</para>
  <programlisting>
X = FOREACH B {
        S = FILTER A BY 'xyz';
        GENERATE COUNT (S.$0);
}
</programlisting>
      </listitem>
   </itemizedlist>
   </section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have relations A, B, and C (see the GROUP operator for information about the field names in relation C).</para>
<programlisting>
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
(2,7)
(2,9)
(4,6)
(4,9)

C = COGROUP A BY a1 inner, B BY b1 inner;

DUMP C;
(1,{(1,2,3)},{(1,3)})
(4,{(4,2,1),(4,3,3)},{(4,6),(4,9)})
(8,{(8,3,4),(8,4,3)},{(8,9)})

ILLUSTRATE C;
<emphasis>etc …</emphasis>
--------------------------------------------------------------------------------------
| c     | group: int | a: bag({a1: int,a2: int,a3: int}) | B: bag({b1: int,b2: int}) |
--------------------------------------------------------------------------------------
|       | 1          | {(1, 2, 3)}                       | {(1, 3)}                  |
-------------------------------------------------------------------------------------
</programlisting>
</section>
   
   <section>
   <title>Example: Projection</title>
   <para>In this example the asterisk (*) is used to project all tuples from relation A to relation X. Relation A and X are identical.</para>
<programlisting>
X = FOREACH A GENERATE *;

DUMP X;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</programlisting>
   
   <para>In this example two fields from relation A are projected to form relation X. </para>
<programlisting>
X = FOREACH A GENERATE a1, a2;

DUMP X;
(1,2)
(4,2)
(8,3)
(4,3)
(7,2)
(8,4)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Nested Projection</title>
   <para>In this example if one of the fields in the input relation is a tuple, bag or map, we can perform a projection on that field (using a deference operator).</para>
<programlisting>
X = FOREACH C GENERATE group, B.b2;

DUMP X;
(1,{(3)})
(4,{(6),(9)})
(8,{(9)})
</programlisting>
   
   <para>In this example multiple nested columns are retained.</para>
<programlisting>
X = FOREACH C GENERATE group, A.(a1, a2);

DUMP X;
(1,{(1,2)})
(4,{(4,2),(4,3)})
(8,{(8,3),(8,4)})
</programlisting>
   </section>
   
   <section>
   <title>Example: Schema</title>
   <para>In this example two fields in relation A are summed to form relation X. A schema is defined for the projected field.</para>
<programlisting>
X = FOREACH A GENERATE a1+a2 AS f1:int;

DESCRIBE X;
x: {f1: int}

DUMP X;
(3)
(6)
(11)
(7)
(9)
(12)

Y = FILTER X BY f1 > 10;

DUMP Y;
(11)
(12)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Applying Functions</title>
   <para>In this example the built-in function SUM() is used to sum a set of numbers in a bag.</para>
<programlisting>
X = FOREACH C GENERATE group, SUM (A.a1);

DUMP X;
(1,1)
(4,8)
(8,16)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Flattening</title>
   <para>In this example the FLATTEN keyword is used to eliminate nesting. </para>
<programlisting>
X = FOREACH C GENERATE group, FLATTEN(A);

DUMP X;
(1,1,2,3)
(4,4,2,1)
(4,4,3,3)
(8,8,3,4)
(8,8,4,3)
</programlisting>
   
   
   <para>Another FLATTEN example.</para>
<programlisting>
X = FOREACH C GENERATE GROUP, FLATTEN(A.a3);

DUMP X;
(1,3)
(4,1)
(4,3)
(8,4)
(8,3)
</programlisting>
   
   <para>Another FLATTEN example. Note that for the group '4' in C, there are two tuples in each bag. Thus, when both bags are flattened, the cross product of these tuples is returned; that is, tuples (4, 2, 6), (4, 3, 6), (4, 2, 9), and (4, 3, 9).</para>
<programlisting>
X = FOREACH C GENERATE FLATTEN(A.(a1, a2)), FLATTEN(B.$1);

DUMP X;
(1,2,3)
(4,2,6)
(4,2,9)
(4,3,6)
(4,3,9)
(8,3,9)
(8,4,9)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Nested Block</title>
   <para>Suppose we have relations A and B. Note that relation B contains an inner bag.</para>
<programlisting>
A = LOAD 'data' AS (url:chararray,outline:chararray);

DUMP A;
(www.ccc.com,www.hjk.com)
(www.ddd.com,www.xyz.org)
(www.aaa.com,www.cvn.org)
(www.www.com,www.kpt.net)
(www.www.com,www.xyz.org)
(www.ddd.com,www.xyz.org)

B = GROUP A BY url;

DUMP B;
(www.aaa.com,{(www.aaa.com,www.cvn.org)})
(www.ccc.com,{(www.ccc.com,www.hjk.com)})
(www.ddd.com,{(www.ddd.com,www.xyz.org),(www.ddd.com,www.xyz.org)})
(www.www.com,{(www.www.com,www.kpt.net),(www.www.com,www.xyz.org)})
</programlisting>
   
   <para>In this example we perform two of the operations allowed in a nested block, FILTER and DISTINCT. Note that the last statement in the nested block must be GENERATE.</para>
<programlisting>
X = foreach B {
        FA= FILTER A BY outlink == 'www.xyz.org';
        PA = FA.outlink;
        DA = DISTINCT PA;
        GENERATE GROUP, COUNT(DA);
}

DUMP X;
(www.ddd.com,1L)
(www.www.com,1L)
</programlisting>
   
   </section></section>
   
   <section>
   <title>GROUP</title>
   <para>Groups the data in a single relation.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = GROUP alias { [ALL] | [BY {[field_alias [, field_alias]] | * | [expression]] } [PARALLEL n];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias </para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
                  <row>
            <entry>
               <para>ALL</para>
            </entry>
            <entry>
               <para>Keyword. Use ALL if you want all tuples to go to a single group; for example, when doing aggregates across entire relations.</para>
               <para>B = GROUP A ALL;</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BY</para>
            </entry>
            <entry>
               <para>Keyword. Use this clause to group the relation by field, tuple or expression.</para>
               <para>B = GROUP A BY f1;</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field_alias</para>
            </entry>
            <entry>
               <para>The name of a field in a relation. This is the group key or key field. </para>
               <para>A relation can be grouped by a single field (f1) or by the composite value of multiple fields (f1,f2).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>*</para>
            </entry>
            <entry>
               <para>The designator for a tuple.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression.</para>
            </entry>
         </row>

         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The GROUP operator groups together tuples that have the same group key (key field). The result of a GROUP operation is a relation that includes one tuple per group. This tuple contains two fields: </para>
   <itemizedlist>
      <listitem>
         <para>The first field is named "group" (do not confuse this with the GROUP operator) and is the same type of the group key.</para>
      </listitem>
      <listitem>
         <para>The second field takes the name of the original relation and is type bag.</para>
         <para/>
         <para>The names of both fields are generated by the system as shown in the example below.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Example</title>
<para>Suppose we have relation A.</para>

<programlisting>
A = load 'student' AS (name:chararray,age:int,gpa:float);

DESCRIBE A;
A: {name: chararray,age: int,gpa: float}

DUMP A;
(John,18,4.0F)
(Mary,19,3.8F)
(Bill,20,3.9F)
(Joe,18,3.8F)
</programlisting>
   
   <para>Now, suppose we group relation A on field "age" for form relation B. We can use the DESCRIBE and ILLUSTRATE operators to examine the structure of relation B. Relation B has two fields. The first field is named "group" and is type int, the same as field "age" in relation A. The second field is name "A"  after relation A and is type bag.</para>
<programlisting>
B = GROUP A BY age;

DESCRIBE B;
B: {group: int, A: {name: chararray,age: int,gpa: float}}

ILLUSTRATE B;
<emphasis>etc …</emphasis>
----------------------------------------------------------------------
| B     | group: int | A: bag({name: chararray,age: int,gpa: float}) |
----------------------------------------------------------------------
|       | 18         | {(John, 18, 4.0), (Joe, 18, 3.8)}             |
|       | 20         | {(Bill, 20, 3.9)}                             |
----------------------------------------------------------------------

DUMP B;
(18,{(John,18,4.0F),(Joe,18,3.8F)})
(19,{(Mary,19,3.8F)})
(20,{(Bill,20,3.9F)})
</programlisting>
   

   <para>Continuing on, as shown in these FOREACH statements, we can refer to the fields in relation B by names "group" and "A" or by positional notation.</para>

<programlisting>
C = FOREACH B GENERATE group, COUNT(A);

DUMP C;
(18,2L)
(19,1L)
(20,1L)

C = FOREACH B GENERATE $0, $1.name;

DUMP C;
(18,{(John),(Joe)})
(19,{(Mary)})
(20,{(Bill)})
</programlisting>
   
   </section></section>
   
   <section>
   <title>Example</title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' as (f1:chararray, f2:int, f3:int);

DUMP A;
(r1,1,2)
(r2,2,1)
(r3,2,8)
(r4,4,4)
</programlisting>
   
<para>In this example the tuples are grouped using an expression, f2*f3.</para>
<programlisting>
X = GROUP A BY f2*f3;

DUMP X;
(2,{(r1,1,2),(r2,2,1)})
(16,{(r3,2,8),(r4,4,4)})
</programlisting>
   </section>
   
   <section>
   <title>JOIN </title>
   <para>Joins two or more relations based on common field values.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = JOIN alias BY field_alias, alias BY field_alias [, alias BY field_alias …] [USING "replicated"] [PARALLEL n];  </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BY</para>
            </entry>
            <entry>
               <para>Keyword</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field_alias</para>
            </entry>
            <entry>
               <para>The name of a field in a relation. For the BY clause, field_alias must be in alias.</para>
               <para>Example: X = JOIN A BY fieldA, B BY fieldB, C BY fieldC;</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>USING</para>
            </entry>
            <entry>
               <para>Keyword</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>"replicated"</para>
            </entry>
            <entry>
               <para>Use to perform fragment replicate join where one or more relations are small enough to fit into main memory.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the JOIN operator to join two or more relations based on common field values. The JOIN operator always performs an inner join. Note that the JOIN and COGROUP operators perform similar functions. JOIN creates a flat set of output records while COGROUP creates a nested set of output records.</para>
   <para>Fragment replicate join is a special type of join that works well if one relation is small enough to fit into main memory. In such cases, Pig can perform a very efficient join because all of the hadoop work is done on the map side. In this type of join the large relation is followed by one or more small relations. The small relations must be small enough to fit into main memory; if they don't, the process fails and an error is generated.</para>
   <para>Note: Fragment replicate joins are experimental; we don't have a strong sense of how small the small relation must be to fit into memory. In our tests with a simple query that involves just a JOIN, a relation of up to 100 M can be used if the process overall gets 1 GB of memory. Please share your observations and experience with us.</para></section>
   
   <section>
   <title>Example</title>
   <para>Suppose we have relations A and B.</para>
<programlisting>
A = LOAD 'data1' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = LOAD 'data2' AS (b1:int,b2:int);

DUMP B;
(2,4)
(8,9)
(1,3)
(2,7)
(2,9)
(4,6)
(4,9)
</programlisting>
   
   <para>In this example relations A and B are joined by their first fields.</para>
<programlisting>
X = JOIN A BY a1, B BY b1;

DUMP X;
(1,2,3,1,3)
(4,2,1,4,6)
(4,3,3,4,6)
(4,2,1,4,9)
(4,3,3,4,9)
(8,3,4,8,9)
(8,4,3,8,9)
</programlisting>
   
   </section>
   
   <section>
   <title>Example: Fragment Replicate Join</title>
      <para>In this example, a large relation is joined with two smaller relations. Note that the large relation comes first followed by the smaller relations; and, all small relations together must fit into main memory, otherwise an error is generated.</para>
<programlisting>
big = LOAD 'big_data' AS (b1,b2,b3);

tiny = LOAD 'tiny_data' AS (t1,t2,t3);

mini = LOAD 'mini_data' AS (m1,m2,m3);

C = JOIN big BY b1, tiny BY t1, mini BY m1 USING "replicated";
</programlisting>
   </section></section>
   
   <section>
   <title>LIMIT </title>
   <para>Limits the number of output tuples.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = LIMIT alias  n;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>n</para>
            </entry>
            <entry>
               <para>The number of tuples.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the LIMIT operator to limit the number of output tuples. If the specified number of output tuples is equal to or exceeds the number of tuples in the relation, the output will include all tuples in the relation.</para>
   <para>There is no guarantee which tuples will be returned, and the tuples that are returned can change from one run to the next. A particular set of tuples can be requested using the ORDER operator followed by LIMIT.</para>
   <para>Note: The LIMIT operator allows Pig to avoid processing all tuples in a relation. In most cases a query that uses LIMIT will run more efficiently than an identical query that does not use LIMIT. It is always a good idea to use limit if you can.</para>
   </section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</programlisting>
   
   <para>In this example output is limited to 3 tuples. Note that there is no guarantee which three tuples will be output.</para>
<programlisting>
X = LIMIT A 3;

DUMP X;
(1,2,3)
(4,3,3)
(7,2,5)
</programlisting>
   
   <para>In this example the ORDER operator is used to order the tuples and the LIMIT operator is used to output the first three tuples.</para>
<programlisting>
B = ORDER A BY f1 DESC, f2 ASC;

DUMP B;
(8,3,4) 
(8,4,3) 
(7,2,5) 
(4,2,1)
(4,3,3)
(1,2,3)

X = LIMIT B 3;

DUMP X;
(8,3,4)
(8,4,3) 
(7,2,5) 
</programlisting>
   </section></section>
   
   <section>
   <title>LOAD </title>
   <para>Loads data from the file system.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>LOAD 'data' [USING function] [AS schema];        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>'data'</para>
            </entry>
            <entry>
               <para>The name of the file or directory, in single quotes.</para>
               <para>If you specify a directory name, all the files in the directory are loaded. </para>
               <para>You can use hadoop-supported globing to specify files at the file system or directory levels (see 
                  <ulink url="http://lucene.apache.org/hadoop/api/org/apache/hadoop/fs/FileSystem.html#globPaths(org.apache.hadoop.fs.Path)the">hadoop glob documentation</ulink> for details on globing syntax).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>USING</para>
            </entry>
            <entry>
               <para>Keyword. </para>
               <para>If the USING clause is omitted, the default load function PigStorage is used. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>function</para>
            </entry>
            <entry>
               <para>The load function. </para>
               <itemizedlist>
                  <listitem>
                     <para>You can use a built-in function (see the load/store functions). PigStorage is the default load function and does not need to be specified (simply omit the USING clause).</para>
                  </listitem>
                  <listitem>
                     <para>You can write your own load function (see the <ulink url="http://wiki.apache.org/pig/UDFManual">User-Defined Function Manual</ulink>) if your data is in a format that cannot be processed by the built-in functions.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>AS</para>
            </entry>
            <entry>
               <para>Keyword. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>schema</para>
            </entry>
            <entry>
               <para>A schema using the AS keyword, enclosed in parentheses (see Schemas).</para>
               <para>The loader produces the data of the type specified by the schema. If the data does not conform to the schema, depending on the loader, either a null value or an error is generated.</para>
               <para>Note: For performance reasons the loader may not immediately convert the data to the specified format; however, you can still operate on the data assuming the specified type.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the LOAD operator to load data from the file system. </para></section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have a data file called myfile.txt. The fields are tab-delimited. The records are newline-separated.</para>
<programlisting>
1 2 3
4 2 1
8 3 4
</programlisting>
   
   <para>In this example the default load function, PigStorage, loads data from myfile.txt to form relation A. The two LOAD statements are equivalent. Note that, because no schema is specified, the fields are not named and all fields default to type bytearray. </para>
<programlisting>
A = LOAD 'myfile.txt';

A = LOAD 'myfile.txt' USING PigStorage('\t');

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
</programlisting>
   
   <para>In this example a schema is specified using the AS keyword. The two LOAD statements are equivalent. You can use the DESCRIBE and ILLUSTRATE operators to view the schema. </para>
<programlisting>
A = LOAD 'myfile.txt' AS (f1:int, f2:int, f3:int);

A = LOAD 'myfile.txt' USING PigStorage(‘\t’) AS (f1:int, f2:int, f3:int);

DESCRIBE A;
a: {f1: int,f2: int,f3: int}

ILLUSTRATE A;
---------------------------------------------------------
| a     | f1: bytearray | f2: bytearray | f3: bytearray |
---------------------------------------------------------
|       | 4             | 2             | 1             |
---------------------------------------------------------

---------------------------------------
| a     | f1: int | f2: int | f3: int |
---------------------------------------
|       | 4       | 2       | 1       |
---------------------------------------
</programlisting>
   <para>
      For examples of how to specify more complex schemas for use with the LOAD operator, see Schemas for Complex Data Types and Schemas for Multiple Types.
      </para></section></section>
      
      <section>
      <title>ORDER</title>
   <para>Sorts a relation based on one or more fields.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = ORDER alias BY { * [ASC|DESC] | field_alias [ASC|DESC] [, field_alias [ASC|DESC] …] } [PARALLEL n];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>BY</para>
            </entry>
            <entry>
               <para>Required keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>*</para>
            </entry>
            <entry>
               <para>The designator for a tuple.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>ASC</para>
            </entry>
            <entry>
               <para>Sort in ascending order.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>DESC</para>
            </entry>
            <entry>
               <para>Sort in descending order.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>field_alias</para>
            </entry>
            <entry>
               <para>A field in the relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>PARALLEL n</para>
            </entry>
            <entry>
               <para>Increase the parallelism of a job by specifying the number of reduce tasks, n. The optimal number of parallel tasks depends on the amount of memory on each node and the memory required by each of the tasks. To determine n, use the following as a general guideline:</para>
               <para/>
               <para>   n = (nr_nodes - 1) * 0.45 * nr_GB</para>
               <para/>
               <para>where nr_nodes is the number of nodes used and nr_GB is the amount of  physical memory on each node.</para>
               <para>Note the following:</para>
               <itemizedlist>
                  <listitem>
                     <para>Parallel only affects the number of reduce tasks. Map parallelism is determined by the input file, one map for each HDFS block. </para>
                  </listitem>
                  <listitem>
                     <para>If you don’t specify parallel, you still get the same map parallelism but only one reduce task. </para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>In Pig, relations are unordered (see Relations, Bags, Tuples, and Fields):</para>
   <itemizedlist>
      <listitem>
         <para>If you order relation A to produce relation X (X = ORDER A BY * DESC;) relations A and X still contain the same thing. </para>
      </listitem>
      <listitem>
         <para>If you retrieve the contents of relation X (DUMP X;) they are guaranteed to be in the order you specified (descending).</para>
      </listitem>
      <listitem>
         <para>However, if you further process relation X (Y = FILTER X BY $0 &gt; 1;) there is no guarantee that the contents will be processed in the order you originally specified (descending).</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Examples</title>
   <para>Suppose we have relation A.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)
</programlisting>
   
   <para>In this example relation A is sorted by the third field, f3 in descending order. Note that the order of the three tuples ending in 3 can vary.</para>
<programlisting>
X = ORDER A BY a3 DESC;

DUMP X;
(7,2,5)
(8,3,4)
(1,2,3)
(4,3,3)
(8,4,3)
(4,2,1)
</programlisting>
   
   </section></section>
   
   
   <section>
   <title>SAMPLE</title>
   <para>Partitions a relation into two or more relations.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>SAMPLE alias size;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>size</para>
            </entry>
            <entry>
               <para>Sample size, range 0 to 1 (for example, enter 0.1 for 10%).</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
     <title>Usage</title>
     <para>Use the SAMPLE operator to select a random data sample with the stated sample size. 
     SAMPLE is a probabalistic operator; there is no guarantee that the exact same number of tuples will be returned for a particular sample size
     each time the operator is used.</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example relation X will contain 1% of the data in relation A.</para>
<programlisting>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

X = SAMPLE A 0.01;
</programlisting>
   </section></section>  
   
   <section>
   <title>SPLIT</title>
   <para>Partitions a relation into two or more relations.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>SPLIT alias INTO alias IF expression, alias IF expression [, alias IF expression …];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>INTO</para>
            </entry>
            <entry>
               <para>Required keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>IF</para>
            </entry>
            <entry>
               <para>Required keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the SPLIT operator to partition the contents of a relation into two or more relations based on some expression. Depending on the conditions stated in the expression:</para>
   <itemizedlist>
      <listitem>
         <para>A tuple may be assigned to more than one relation.</para>
      </listitem>
      <listitem>
         <para>A tuple may not be assigned to any relation.</para>
         <para/>
         <para/>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Example</title>
   <para>In this example relation A is split into three relations, X, Y, and Z.</para>
<programlisting>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;                
(1,2,3)
(4,5,6)
(7,8,9)        

SPLIT A INTO X IF f1&lt;7, Y IF f2==5, Z IF (f3&lt;6 OR f3&gt;6);

DUMP X;
(1,2,3)
(4,5,6)

DUMP Y;
(4,5,6)

DUMP Z;
(1,2,3)
(7,8,9)
</programlisting>

   </section></section>
   
   <section>
   <title>STORE </title>
   <para>Stores data to the file system.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>STORE alias INTO 'directory' [USING function];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>INTO</para>
            </entry>
            <entry>
               <para>Required keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>'directory'</para>
            </entry>
            <entry>
               <para>The name of the storage directory, in quotes. If the directory already exists, the STORE operation will fail.</para>
               <para/>
               <para>The output data files, named part-nnnnn, are written to this directory. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>USING</para>
            </entry>
            <entry>
               <para>Keyword. Use this clause to name the store function.</para>
               <para>If the USING clause is omitted, the default store function PigStorage is used.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>function</para>
            </entry>
            <entry>
               <para>The store function.</para>
               <itemizedlist>
                  <listitem>
                     <para>You can use a built-in function (see the Load/Store Functions). PigStorage is the default load function and does not need to be specified (simply omit the USING clause).</para>
                  </listitem>
                  <listitem>
                     <para>You can write your own store function (see the User-Defined Function Manual) if your data is in a format that cannot be processed by the built-in functions.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the STORE operator to run (execute) Pig Latin statements and to store data on the file system. </para></section>
   
   <section>
   <title>Examples</title>
   <para>In this example data is stored using PigStorage and the asterisk character (*) as the field delimiter.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

STORE A INTO ‘myoutput’ USING PigStorage (‘*’);

CAT myoutput;
1*2*3
4*2*1
8*3*4
4*3*3
7*2*5
8*4*3
</programlisting>
   
   <para>In this example, the CONCAT function is used to format the data before it is stored.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = FOREACH A GENERATE CONCAT('a:',(chararray)f1), CONCAT('b:',(chararray)f2), CONCAT('c:',(chararray)f3);

DUMP B;
(a:1,b:2,c:3)
(a:4,b:2,c:1)
(a:8,b:3,c:4)
(a:4,b:3,c:3)
(a:7,b:2,c:5)
(a:8,b:4,c:3)

STORE B INTO 'myoutput' using PigStorage(',');

CAT myoutput;
a:1,b:2,c:3
a:4,b:2,c:1
a:8,b:3,c:4
a:4,b:3,c:3
a:7,b:2,c:5
a:8,b:4,c:3
</programlisting>
   
   </section></section>
   
   <section>
   <title>STREAM</title>
   <para>Sends data to an external script or program.</para>
      
      <section>
      <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = STREAM alias [, alias …] THROUGH {`command` | cmd_alias } [AS schema] ;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>THROUGH</para>
            </entry>
            <entry>
               <para>Keyword. </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>`command`</para>
            </entry>
            <entry>
               <para>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>cmd_alias</para>
            </entry>
            <entry>
               <para>The name of a command created using the DEFINE operator.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>AS</para>
            </entry>
            <entry>
               <para>Keyword.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>schema</para>
            </entry>
            <entry>
               <para>A schema using the AS keyword, enclosed in parentheses (see Schemas).</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the STREAM operator to send data through an external script or program. Multiple stream operators can appear in the same Pig script. The stream operators can be adjacent to each other or have other operations in between.</para>
   <para>When used with a command, a stream statement could look like this:</para>
<programlisting>
A = LOAD 'data';

B = STREAM A THROUGH `stream.pl -n 5`;
</programlisting>
   <para>When used with a cmd_alias, a stream statement could look like this, where cmd is the defined alias.</para>
<programlisting>
A = LOAD 'data';

DEFINE cmd `stream.pl –n 5`;

B = STREAM A THROUGH cmd;
</programlisting>
   </section>
   
   <section>
   <title>About Data Guarantees</title>
   <para>Data guarantees are determined based on the position of the streaming operator in the Pig script. </para>
   <itemizedlist>
      <listitem>
         <para>Unordered data – No guarantee for the order in which the data is delivered to the streaming application. </para>
      </listitem>
      <listitem>
         <para>Grouped data – The data for the same grouped key is guaranteed to be provided to the streaming application contiguously</para>
      </listitem>
      <listitem>
         <para>Grouped and ordered data – The data for the same grouped key is guaranteed to be provided to the streaming application contiguously. Additionally, the data within the group is guaranteed to be sorted by the provided secondary key.</para>
      </listitem>
   </itemizedlist>
   <para>In addition to position, data grouping and ordering can be determined by the data itself. However, you need to know the property of the data to be able to take advantage of its structure.</para>
   </section>
   
   <section>
   <title>Example: Data Guarantees</title>
   <para>In this example the data is unordered.</para>
<programlisting>
A = LOAD 'data';

B = STREAM A THROUGH `stream.pl`;
</programlisting>
   
   <para>In this example the data is grouped.</para>
<programlisting>
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B FLATTEN(A);

D = STREAM C THROUGH `stream.pl`
</programlisting>
   
   <para>In this example the data is grouped and ordered.</para>
<programlisting>
A = LOAD 'data';

B = GROUP A BY $1;

C = FOREACH B {
      D = ORDER A BY ($3, $4);
      GENERATE D;
}

E = STREAM C THROUGH `stream.pl`;
</programlisting>
   </section>
   
   <section>
   <title>Example: Schemas</title>
   <para>In this example a schema is specified as part of the STREAM statement.</para>
<programlisting>
X = STREAM A THROUGH `stream.pl` as (f1:int, f2;int, f3:int);
</programlisting>
   </section>
   
   <section>
   <title>Additional Examples</title>
   <para>See the UDF statement DEFINE for additional examples.</para></section></section>
   
   <section>
   <title>UNION</title>
   <para>Computes the union of two or more relations.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>alias = UNION alias, alias [, alias …];</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the UNION operator to merge the contents of two or more relations. The UNION operator:</para>
   <itemizedlist>
      <listitem>
         <para>Does not preserve the order of tuples. Both the input and output relations are interpreted as unordered bags of tuples.</para>
      </listitem>
      <listitem>
         <para>Does not ensure (as databases do) that all tuples adhere to the same schema or that they have the same number of fields. In a typical scenario, however, this should be the case; therefore, it is the user's responsibility to either (1) ensure that the tuples in the input relations have the same schema or (2) be able to process varying tuples in the output relation.</para>
      </listitem>
      <listitem>
         <para>Does not eliminate duplicate tuples.</para>
      </listitem>
   </itemizedlist></section>
   
   <section>
   <title>Example</title>
   <para>In this example the union of relation A and B is computed.</para>
<programlisting>
A = LOAD 'data' AS (a1:int,a2:int,a3:int);

DUMP A;
(1,2,3)
(4,2,1)

B = LOAD 'data' AS (b1:int,b2:int);

DUMP A;
(2,4)
(8,9)
(1,3)

X = UNION A, B;

DUMP X;
(1,2,3)
(4,2,1)
(2,4)
(8,9)
(1,3)
</programlisting>
   </section></section></section>


 <!-- DIAGNOSTIC OPERATORS -->    
<section>
	<title>Diagnostic Operators</title>
  
   <section>
   <title>DESCRIBE</title>
   <para>Returns the schema of an alias.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>DESCRIBE alias;        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the DESCRIBE operator to review the schema of a particular alias.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example a schema is specified using the AS clause. If all data conforms to the schema, Pig will use the assigned types.</para>
<programlisting>
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

B = FILTER A BY name matches 'J.+';

C = GROUP B BY name;

D = FOREACH B GENERATE COUNT(B.age);

DESCRIBE A;
A: {group, B: (name: chararray,age: int,gpa: float}

DESCRIBE B;
B: {group, B: (name: chararray,age: int,gpa: float}

DESCRIBE C;
C: {group, chararry,B: (name: chararray,age: int,gpa: float}

DESCRIBE D;
D: {long}
</programlisting>
   
   <para>In this example no schema is specified. All fields default to type bytearray or long (see Data Types).</para>
<programlisting>
a = LOAD 'student';

b = FILTER a BY $0 matches 'J.+';

c = GROUP b BY $0;

d = FOREACH c GENERATE COUNT(b.$1);

DESCRIBE a;
Schema for a unknown.

DESCRIBE b;
2008-12-05 01:17:15,316 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly cast to chararray under LORegexp Operator
Schema for b unknown.

DESCRIBE c;
2008-12-05 01:17:23,343 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly caste to chararray under LORegexp Operator
c: {group: bytearray,b: {null}}

DESCRIBE d;
2008-12-05 03:04:30,076 [main] WARN  org.apache.pig.PigServer - bytearray is implicitly caste to chararray under LORegexp Operator
d: {long}
</programlisting>
   
   </section></section>
   
   <section>
   <title>EXPLAIN</title>
   <para>Displays execution plans.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>EXPLAIN [–out path] [-brief] [-dot] [–param param_name = param_value] [–param_file file_name] alias; </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
   <tgroup cols="2"><tbody>
      
         <row>
            <entry>
               <para>–out path</para>
            </entry>
            <entry>
               <para>Will generate logical_plan.[txt||dot], physical_plan.[text||dot], exec_plan.[text||dot] in the specified directory (path).</para>
               <para>Default (no path given): Stdout </para>
            </entry>
         </row>

         <row>
            <entry>
               <para>–brief</para>
            </entry>
            <entry>
               <para>Does not expand nested plans (presenting a smaller graph for overview). </para>
            </entry>
         </row>
         
         <row>
            <entry>
               <para>–dot</para>
            </entry>
            <entry>
               <para>Dot mode: outputs a format that can be passed to dot for graphical display.</para>
               <para>Text mode: multiple output (split) will be broken out in sections.  </para>
               <para>Default: Text </para>
            </entry>
         </row>

         <row>
            <entry>
               <para>–param param_name = param_value</para>
            </entry>
            <entry>
               <para>See Parameter Substitution.</para>
            </entry>
         </row>

         <row>
            <entry>
               <para>–param_file file_name</para>
            </entry>
            <entry>
               <para>See Parameter Substitution. </para>
            </entry>
         </row>
      
      <row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row>
         
   </tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the EXPLAIN operator to review the logical, physical, and map reduce execution plans that are used to compute the specified relationship. </para>
   <para>If no script is given:</para>

   <itemizedlist>	
      <listitem>
         <para>The logical plan shows a pipeline of operators to be executed to build the relation. Type checking and backend-independent optimizations (such as applying filters early on) also apply.</para>
      </listitem>
      <listitem>
         <para>The physical plan shows how the logical operators are translated to backend-specific physical operators. Some backend optimizations also apply.</para>
      </listitem>
      <listitem>
         <para>The map reduce plan shows how the physical operators are grouped into map reduce jobs.</para>
      </listitem>
  </itemizedlist> 
  <para></para>
   <para>If a script without an alias is specified, it will output the entire execution graph (logical, physical, or map reduce). </para>
   <para>If a script with a alias is specified, it will output the plan for the given alias. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the EXPLAIN operator produces all three plans. (Note that only a portion of the output is shown in this example.)</para>

 <programlisting>
A = LOAD 'student' AS (name:chararray, age:int, gpa:float);

B = GROUP A BY name;

C = FOREACH B GENERATE COUNT(A.age);

EXPLAIN C;
-----------------------------------------------
Logical Plan:
-----------------------------------------------
Store xxx-Fri Dec 05 19:42:29 UTC 2008-23 Schema: {long} Type: Unknown
|
|---ForEach xxx-Fri Dec 05 19:42:29 UTC 2008-15 Schema: {long} Type: bag
<emphasis>etc …</emphasis>

-----------------------------------------------
Physical Plan:
-----------------------------------------------
Store(fakefile:org.apache.pig.builtin.PigStorage) - xxx-Fri Dec 05 19:42:29 UTC 2008-40
|
|---New For Each(false)[bag] - xxx-Fri Dec 05 19:42:29 UTC 2008-39
    |   |
    |   POUserFunc(org.apache.pig.builtin.COUNT)[long] - xxx-Fri Dec 05 
<emphasis>etc …</emphasis>

--------------------------------------------------
| Map Reduce Plan                               
-------------------------------------------------
MapReduce node xxx-Fri Dec 05 19:42:29 UTC 2008-41
Map Plan
Local Rearrange[tuple]{chararray}(false) - xxx-Fri Dec 05 19:42:29 UTC 2008-34
|   |
|   Project[chararray][0] - xxx-Fri Dec 05 19:42:29 UTC 2008-35
<emphasis>etc …</emphasis></programlisting> 
 </section></section>
   
   <section>
   <title>ILLUSTRATE</title>
   <para>Displays a step-by-step execution of a sequence of statements.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>ILLUSTRATE alias; </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name of a relation.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the ILLUSTRATE operator to review how data is transformed through a sequence of Pig Latin statements:</para>
   <itemizedlist>
      <listitem>
         <para>The data load statement must include a schema.</para>
      </listitem>
      <listitem>
         <para>The Pig Latin statement used to form the relation that is used with the ILLUSTRATE command cannot include the map data type, the LIMIT and SPLIT operators, or nested FOREACH statements. </para>
      </listitem>
   </itemizedlist>
   <para>ILLUSTRATE accesses the ExampleGenerator algorithm which can select an appropriate and concise set of example data automatically. It does a better job than random sampling would do; for example, random sampling suffers from the drawback that selective operations such as filters or joins can eliminate all the sampled data, giving you empty results which will not help with debugging. </para>
   <para>With the ILLUSTRATE operator you can test your programs on small datasets and get faster turnaround times. The ExampleGenerator algorithm uses Pig's Local mode (rather than Hadoop mode) which means that illustrative example data is generated in near real-time.</para>
   <para>Relation X can be used with the ILLUSTRATE operator.</para>
<programlisting>
X = FOREACH A GENERATE f1;

ILLUSTRATE X;
</programlisting>
   
   <para>Relation Y cannot be used with the ILLUSTRATE operator.</para>
<programlisting>
Y = LIMIT A 3;

ILLUSTRATE Y;
</programlisting>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example we count the number of sites a user has visited since 12/1/08. The ILLUSTRATE statement will show how the results for num_user_visits are derived.</para>

 <programlisting>
visits = LOAD 'visits' AS (user:chararray, ulr:chararray, timestamp:chararray);

DUMP visits;
(Amy,cnn.com,20080218)
(Fred,harvard.edu,20081204)
(Amy,bbc.com,20081205)
(Fred,stanford.edu,20081206)

recent_visits = FILTER visits BY timestamp >= '20081201';

user_visits = GROUP recent_visits BY user;

num_user_visits = FOREACH user_visits GENERATE COUNT(recent_visits);

DUMP num_user_visits;
(1L)
(2L)

ILLUSTRATE num_user_visits;
------------------------------------------------------------------------
| visits     | user: bytearray | ulr: bytearray | timestamp: bytearray |
------------------------------------------------------------------------
|            | Amy             | cnn.com        | 20080218             |
|            | Fred            | harvard.edu    | 20081204             |
|            | Amy             | bbc.com        | 20081205             |
|            | Fred            | stanford.edu   | 20081206             |
------------------------------------------------------------------------

------------------------------------------------------------------------
| visits     | user: chararray | ulr: chararray | timestamp: chararray |
------------------------------------------------------------------------
|            | Amy             | cnn.com        | 20080218             |
|            | Fred            | harvard.edu    | 20081204             |
|            | Amy             | bbc.com        | 20081205             |
|            | Fred            | stanford.edu   | 20081206             |
------------------------------------------------------------------------

-------------------------------------------------------------------------------
| recent_visits     | user: chararray | ulr: chararray | timestamp: chararray |
-------------------------------------------------------------------------------
|                   | Fred            | harvard.edu    | 20081204             |
|                   | Amy             | bbc.com        | 20081205             |
|                   | Fred            | stanford.edu   | 20081206             |
-------------------------------------------------------------------------------

------------------------------------------------------------------------------------------------------------------
| user_visits     | group: chararray | recent_visits: bag({user: chararray,ulr: chararray,timestamp: chararray}) |
------------------------------------------------------------------------------------------------------------------
|                 | Amy              | {(Amy, bbc.com, 20081205)}                                                |
|                 | Fred             | {(Fred, harvard.edu, 20081204), (Fred, stanford.edu, 20081206)}           |
------------------------------------------------------------------------------------------------------------------

-------------------------------
| num_user_visits     | long  |
------------------------------
|                     | 1     |
|                     | 2     |
-------------------------------
</programlisting>
  
   </section></section>
   </section>
   
   
    <!-- UDF STATEMENTS --> 
   <section>
   <title>UDF Statements</title>
   
   <section>
   <title>DEFINE</title>
   <para>Assigns an alias to a function or command.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>DEFINE alias {function | [`command` [input] [output] [ship] [cache]] };</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The name for the function or command.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>function</para>
            </entry>
            <entry>
               <para>The name of a function.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>`command `</para>
            </entry>
            <entry>
               <para>A command, including the arguments, enclosed in back tics (where a command is anything that can be executed).</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>input</para>
            </entry>
            <entry>
               <para>INPUT ( {stdin | 'path'} [USING serializer] [, {stdin | 'path'} [USING serializer] …] )</para>
               <para>Where:</para>
               <itemizedlist>
                  <listitem>
                     <para>INPUT – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>'path' – A file path, enclosed in single quotes.</para>
                  </listitem>
                  <listitem>
                     <para>USING – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>serializer – A function that converts data from tuples to stream format. PigStorage is the default serializer. You can also write your own UDF.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>output</para>
            </entry>
            <entry>
               <para>OUTPUT ( {stdout | stderr | 'path'} [USING deserializer] [, {stdout | stderr | 'path'} [USING deserializer] …] )</para>
               <para>Where:</para>
               <itemizedlist>
                  <listitem>
                     <para>OUTPUT – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>'path' – A file path, enclosed in single quotes.</para>
                  </listitem>
                  <listitem>
                     <para>USING – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>deserializer – A function that converts data from stream format to tuples. PigStorage is the default deserializer. You can also write your own UDF.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>ship</para>
            </entry>
            <entry>
               <para>SHIP('path' [, 'path' …])</para>
               <para>Where:</para>
               <itemizedlist>
                  <listitem>
                     <para>SHIP – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>'path' – A file path, enclosed in single quotes.</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>cache</para>
            </entry>
            <entry>
               <para>CACHE('dfs_path#dfs_file' [, 'dfs_path#dfs_file' …])</para>
               <para>Where:</para>
               <itemizedlist>
                  <listitem>
                     <para>CACHE – Keyword.</para>
                  </listitem>
                  <listitem>
                     <para>'dfs_path#dfs_file' – A file path/file name on the distributed file system, enclosed in single quotes. Example: '/mydir/mydata.txt#mydata.txt'</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the DEFINE statement to assign a name (alias) to a function or to a command.</para>
   <para>Use DEFINE to specify a function when:</para>
   <itemizedlist>
      <listitem>
         <para>The function has a log package name that you don't want to include in a script, especially if you call the function several times in that script.</para>
      </listitem>
      <listitem>
         <para>The constructor for the function takes string parameters. If you need to use different constructor parameters for different calls to the function you will need to create multiple defines – one for each parameter set.</para>
      </listitem>
   </itemizedlist>
   <para>Use DEFINE to specify a command when the streaming command specification is complex or requires additional parameters (input, output, and so on).</para>
   
   <section
   ><title>About Input and Output</title>
   <para>Serialization is needed to convert data from tuples to a format that can be processed by the streaming application. Deserialization is needed to convert the output from the streaming application back into tuples.</para>
   <para>PigStorage, the default serialization/deserialization function, converts tuples to tab-delimited lines. Pig's BinarySerializer and BinaryDeserializer functions treat the entire file as a byte stream (no formatting or interpretation takes place). You can also write your own serialization/deserialization functions.</para>
   </section>
   
   <section>
   <title>About Ship </title>
   <para>Use the ship option to send streaming binary and supporting files, if any, from the client node to the compute nodes. Pig does not automatically ship dependencies; it is your responsibility to explicitly specify all the dependencies and to make sure that the software the processing relies on (for instance, perl or python) is installed on the cluster. Supporting files are shipped to the task's current working directory and only relative paths should be specified. Any pre-installed binaries should be specified in the PATH. </para>
   <para>Only files, not directories, can be specified with the ship option. One way to work around this limitation is to tar all the dependencies into a tar file that accurately reflects the structure needed on the compute nodes, then have a wrapper for your script that un-tars the dependencies prior to execution.</para>
   <para>Note that the ship option has two components: the source specification, provided in the ship( ) clause, is the view of your machine; the command specification is the view of the actual cluster. The only guarantee is that the shipped files are available in the current working directory of the launched job and that your current working directory is also on the PATH environment variable. </para>
   <para>Shipping files to relative paths or absolute paths is not supported since you might not have permission to read/write/execute from arbitrary paths on the clusters.</para>
   
    <para>Note the following:</para>
	<orderedlist>
		<listitem>
			<para>It is safe only to ship files to be executed from the current working directory on the task on the cluster.</para>
			<programlisting>
OP = stream IP through `script`;
or
DEFINE CMD `script` ship('/a/b/script');
OP = stream IP through CMD`;
</programlisting>
		</listitem>
	    <listitem>
			<para>Shipping files to relative paths or absolute paths is undefined and mostly will fail since you may not have permissions to read/write/execute from arbitraty paths on the actual clusters. </para>
	    </listitem>
	</orderedlist>   
   </section>
   
   <section>
   <title>About Auto-Ship</title>
   <para>If the ship option is not specified, Pig will attempt to auto-ship the binary in the following way:</para>
   <itemizedlist>
		<listitem>
            <para>If the first word on the streaming command is perl or python, Pig assumes that the binary is the first non-quoted string it encounters that does not start with dash.</para>
		</listitem>
		<listitem>
			<para>Otherwise, Pig will attempt to ship the first string from the command line as long as it does not come from /bin, /usr/bin, /usr/local/bin. Pig will determine this by scanning the path if an absolute path is provided or by executing which. The paths can be made configurable using the set stream.skippath &lt;path&gt; option. (You can use multiple set commands to specify more than one path to skip.) </para>
		</listitem>
	</itemizedlist>
	<para>If you don't supply a DEFINE for a given streaming command, then auto-shipping is turned off.</para>
	<para>Note the following:</para>
	<orderedlist>
		<listitem>
			<para>If Pig determines that it needs to auto-ship an absolute path it will not ship it at all since there is no way to ship files to the necessary location (lack of permissions and so on). </para>
			<programlisting>
OP = stream IP through `/a/b/c/script`;
or 
OP = stream IP through `perl /a/b/c/script.pl`;
</programlisting>
		</listitem>
	    <listitem>
			<para>Pig will not auto-ship files in the following system directories (this is determined by executing 'which &lt;file&gt;' command). </para>
			<programlisting>
/bin /usr/bin /usr/local/bin /sbin /usr/sbin /usr/local/sbin
</programlisting>
		</listitem>
	    <listitem>
			<para>To auto-ship, the file in question should be present in the PATH. So if the file is in the current working directory then the current working directory should be in the PATH. </para>
		</listitem>
	</orderedlist>
	
   </section>
   
   <section>
   <title>About Cache</title>
   <para>The ship option works with binaries, jars, and small datasets. However, loading larger datasets at run time for every execution can severely impact performance. Instead, use the cache option to access large files already moved to and available on the compute nodes. Only files, not directories, can be specified with the cache option.</para>
   </section></section>
   
 <section>
 <title>Example: Input/Output</title>
 <para>In this example PigStorage is the default serialization/deserialization function. The tuples from relation A are converted to tab-delimited lines that are passed to the script.</para>
<programlisting>
X = STREAM A THROUGH `stream.pl`;
</programlisting>
   
   <para>In this example PigStorage is used as the serialization/deserialization function, but a comma is used as the delimiter.</para>
<programlisting>
DEFINE Y `stream.pl` INPUT(stdin USING PigStorage(',')) OUTPUT (stdout USING PigStorage(','));

X = STREAM A THROUGH Y;
</programlisting>
   
   <para>In this example user-defined serialization/deserialization functions are used with the script.</para>
<programlisting>
DEFINE Y `stream.pl` INPUT(stdin USING MySerializer) OUTPUT (stdout USING MyDeserializer);

X = STREAM A THROUGH Y;
</programlisting>
   </section>
   
   <section>
   <title>Example: Ship/Cache</title>
   <para>In this example ship is used to send the script to the cluster compute nodes.</para>
<programlisting>
DEFINE Y `stream.pl` SHIP('/work/stream.pl');

X = STREAM A THROUGH Y;
</programlisting>
   
   <para>In this example cache is used to specify a file located on the cluster compute nodes.</para>
<programlisting>
DEFINE Y `stream.pl data.gz` SHIP('/work/stream.pl') CACHE('/input/data.gz#data.gz');

X = STREAM A THROUGH Y;
</programlisting>
   </section>
   
   <section>
   <title>Example: Logging</title>
   <para>In this example the streaming stderr is stored in the _logs/&lt;dir&gt; directory of the job's output directory. Because the job can have multiple streaming applications associated with it, you need to ensure that different directory names are used to avoid conflicts. Pig stores up to 100 tasks per streaming job.</para>
<programlisting>
DEFINE Y `stream.pl` stderr('&lt;dir&gt;' limit 100);

X = STREAM A THROUGH Y;
</programlisting>

   
<para>In this example a function is defined for use with the FOREACH …GENERATE operator.</para>
<programlisting>
REGISTER /src/myfunc.jar

DEFINE myFunc myfunc.MyEvalfunc('foo');

A = LOAD 'students';

B = FOREACH A GENERATE myFunc($0);
</programlisting>
   
<para>In this example a command is defined for use with the STREAM operator.</para>
<programlisting>
A = LOAD 'data';

DEFINE cmd `stream_cmd –input file.dat`

B = STREAM A through cmd.
</programlisting>
</section>
</section>
   
   <section>
   <title>REGISTER</title>
   <para>Registers a JAR file so that the UDFs in the file can be used.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>REGISTER alias;</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>alias</para>
            </entry>
            <entry>
               <para>The path of a Java JAR file. Do not place the name in quotes.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the REGISTER statement to specify the path of a Java JAR file containing UDFs.</para>
   <para>For more information about UDFs, see the User Defined Function Guide. Note that Pig currently only supports functions written in Java.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example REGISTER states that myfunc.jar is located in the /src directory.</para>
<programlisting>
/src $ java -jar pig.jar –

REGISTER /src/myfunc.jar;

A = LOAD 'students';

B = FOREACH A GENERATE myfunc.MyEvalFunc($0);
</programlisting>
   <para>

   </para></section></section>
   </section>
   
   <!-- BUILT-IN FUNCTIONS --> 
    
    <section><title>Eval Functions</title>

<section>
<title>AVG</title>
   <para>Computes the average of the numeric values in a single-column bag. </para>
   <section><title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>AVG(expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>Any expression whose result is a bag. The elements of the bag should be data type int, long, float, or double.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the AVG function to compute the average of the numeric values in a single-column bag. AVG requires a preceding GROUP ALL statement for global averages and a GROUP BY statement for group averages.</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the average GPA for each student is computed (see the GROUP operators for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'student.txt' AS (name:chararray, term:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

C = FOREACH B GENERATE A.name, AVG(A.gpa);

DUMP C;
({(John),(John),(John),(John)},3.850000023841858)
({(Mary),(Mary),(Mary),(Mary)},3.925000011920929)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>AVG </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as double </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>CONCAT</title>
   <para>Concatenates two fields of type chararray or two fields of type bytearray.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>CONCAT (expression, expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data types chararray or bytearray.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the CONCAT function to concatenate two elements. The data type of the two elements must be the same, either chararray or bytearray.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example fields f2 and f3 are concatenated.</para>
<programlisting>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);

DUMP A;
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE CONCAT(f2,f3);

DUMP X;
(opensource)
(mapreduce)
(piglatin)
</programlisting>
   
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>cast as chararray  </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>COUNT</title>
   <para>Computes the number of elements in a bag. COUNT requires a preceding GROUP ALL statement for global counts and a GROUP BY statement for group counts.</para>
   <para>Note that COUNT works with bags. You cannot use the tuple designator (*) with COUNT; that is, COUNT(*) will not work.</para>
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>COUNT(expression)        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data type bag.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the COUNT function to compute the number of elements in a bag.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the tuples in the bag are counted (see the GROUP operator for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'data' AS (f1:int,f2:int,f3:int);

DUMP A;
(1,2,3)
(4,2,1)
(8,3,4)
(4,3,3)
(7,2,5)
(8,4,3)

B = GROUP A BY f1;

DUMP B;
(1,{(1,2,3)})
(4,{(4,2,1),(4,3,3)})
(7,{(7,2,5)})
(8,{(8,3,4),(8,4,3)})

X = FOREACH B GENERATE COUNT(A);

DUMP X;
(1L)
(2L)
(1L)
(2L)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="4">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/>
         <colspec colnum="4" colname="c4"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>COUNT </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>DIFF</title>
   <para>Compares two fields in a tuple.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>DIFF (expression, expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with any data type.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The DIFF function compares two fields in a tuple. If the field values match, null is returned. If the field values do not match, the non-matching elements are returned.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the two fields are bags. DIFF compares the tuples in each bag.</para>
<programlisting>
A = LOAD 'bag_data' AS (B1:bag{T1:tuple(t1:int,t2:int)},B2:bag{T2:tuple(f1:int,f2:int)});

DUMP A;
({(8,9),(0,1)},{(8,9),(1,1)})
({(2,3),(4,5)},{(2,3),(4,5)})
({(6,7),(3,7)},{(2,2),(3,7)})

DESCRIBE A;
a: {B1: {T1: (t1: int,t2: int)},B2: {T2: (f1: int,f2: int)}}

X = FOREACH A DIFF(B1,B2);

grunt> dump x;
({(0,1),(1,1)})
({})
({(6,7),(2,2)})
</programlisting>
   </section></section>
   
<section>
   <title>IsEmpty</title>
   <para>Checks if a bag or map is empty.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>IsEmpty(expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with any data type.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The IsEmpty function checks if a bag or map is empty (has no data). The function can be used to filter data.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example all students with an SSN but no name are located.</para>
<programlisting>
SSN = load 'ssn.txt' using PigStorage() as (ssn:long);

SSN_NAME = load 'students.txt' using PigStorage() as (ssn:long, name:chararray);

-- do a left out join of SSN with SSN_Name
X = cogroup SSN by ssn inner, SSN_NAME by ssn;

-- only keep those ssn's for which there is no name
Y = filter X by IsEmpty(SSN_NAME);
</programlisting>
   </section></section>    
   
   
   <section>
   <title>MAX</title>
   <para>Computes the maximum of the numeric values or chararrays in a single-column bag. MAX requires a preceding GROUP ALL statement for global maximums and a GROUP BY statement for group maximums.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>MAX(expression)        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data types int, long, float, double, or chararray.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the MAX function to compute the maximum of the numeric values or chararrays in a single-column bag.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the maximum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MAX(A.gpa);

DUMP X;
(John,4.0F)
(Mary,4.0F)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>MAX </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>cast as double</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>MIN</title>
   <para>Computes the minimum of the numeric values or chararrays in a single-column bag. MIN requires a preceding GROUP… ALL statement for global minimums and a GROUP … BY statement for group minimums.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>MIN(expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data types int, long, float, double, or chararray.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   
   <title>Usage</title>
   <para>Use the MIN function to compute the minimum of a set of numeric values or chararrays in a single-column bag.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the minimum GPA for all terms is computed for each student (see the GROUP operator for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'student' AS (name:chararray, session:chararray, gpa:float);

DUMP A;
(John,fl,3.9F)
(John,wt,3.7F)
(John,sp,4.0F)
(John,sm,3.8F)
(Mary,fl,3.8F)
(Mary,wt,3.9F)
(Mary,sp,4.0F)
(Mary,sm,4.0F)

B = GROUP A BY name;

DUMP B;
(John,{(John,fl,3.9F),(John,wt,3.7F),(John,sp,4.0F),(John,sm,3.8F)})
(Mary,{(Mary,fl,3.8F),(Mary,wt,3.9F),(Mary,sp,4.0F),(Mary,sm,4.0F)})

X = FOREACH B GENERATE group, MIN(A.gpa);

DUMP X;
(John,3.7F)
(Mary,3.8F)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>MIN </para>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>cast as double</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>SIZE</title>
   <para>Computes the number of elements based on the data type.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>SIZE(expression)</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with any data type.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the SIZE function to compute the number of elements based on the data type (see the Types Tables below).</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the number of characters in the first field is computed.</para>
<programlisting>
A = LOAD 'data' as (f1:chararray, f2:chararray, f3:chararray);
(apache,open,source)
(hadoop,map,reduce)
(pig,pig,latin)

X = FOREACH A GENERATE SIZE(f1);

DUMP X;
(6L)
(6L)
(3L)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>returns 1 </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>returns 1 </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>returns 1 </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>returns 1 </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>returns number of characters in the array </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bytearray </para>
            </entry>
            <entry>
               <para>returns number of bytes in the array </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>tuple </para>
            </entry>
            <entry>
               <para>returns number of fields in the tuple</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>bag </para>
            </entry>
            <entry>
               <para>returns number of tuples in bag </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>map </para>
            </entry>
            <entry>
               <para>returns number of key/value pairs in map </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>SUM</title>
   <para>Computes the sum of the numeric values in a single-column bag. SUM requires a preceding GROUP ALL statement for global sums and a GROUP BY statement for group sums.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>SUM(expression)        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data types int, long, float, double, or bytearray cast as double.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the SUM function to compute the sum of a set of numeric values in a single-column bag.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the number of pets is computed. (see the GROUP operator for information about the field names in relation B).</para>
<programlisting>
A = LOAD 'data' AS (owner:chararray, pet_type:chararray, pet_num:int);

DUMP A;
(Alice,turtle,1)
(Alice,goldfish,5)
(Alice,cat,2)
(Bob,dog,2)
(Bob,cat,2) 

B = GROUP A BY owner;

DUMP B;
(Alice,{(Alice,turtle,1),(Alice,goldfish,5),(Alice,cat,2)})
(Bob,{(Bob,dog,2),(Bob,cat,2)})

X = FOREACH B GENERATE group, SUM(A.pet_num);
DUMP X;
(Alice,8L)
(Bob,4L)
</programlisting>
   </section>
   
   <section>
   <title>Types Tables</title>
   <informaltable frame="all">
      <tgroup cols="3">
         <colspec colnum="1" colname="c1"/>
         <colspec colnum="2" colname="c2"/>
         <colspec colnum="3" colname="c3"/><tbody><row>
            <entry>
               <para/>
            </entry>
            <entry>
               <para>int </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>float </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>chararray </para>
            </entry>
            <entry>
               <para>bytearray </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>SUM </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>long </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>double </para>
            </entry>
            <entry>
               <para>error </para>
            </entry>
            <entry>
               <para>cast as double </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section></section>
   
   <section>
   <title>TOKENIZE</title>
   <para>Splits a string and outputs a bag of words. </para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>TOKENIZE(expression)        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>expression</para>
            </entry>
            <entry>
               <para>An expression with data type chararray.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the TOKENIZE function to split a string of words (all words in a single tuple) into a bag of words (each word in a single tuple). The following characters are considered to be word separators: space, double quote("), coma(,) parenthesis(()), star(*).</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the strings in each row are split.</para>
<programlisting>
A  = LOAD 'data' AS (f1:chararray);

DUMP A;
(Here is the first string.)
(Here is the second string.)
(Here is the third string.)

X = FOREACH A GENERATE TOKENIZE(f1);

DUMP X;
({(Here),(is),(the),(first),(string.)})
({(Here),(is),(the),(second),(string.)})
({(Here),(is),(the),(third),(string.)})
</programlisting>
   
   </section></section></section>
   
   <section>
   <title>Load/Store Functions</title>
   <para>Load/Store functions determine how data goes into Pig and comes out of Pig. In addition to the Pig built-in load/store functions, you can also write your functions (see the User-Defined Function Manual).</para>
   
   <section>
   <title>BinarySerializer</title>
   <para>Converts a file to a byte stream.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>BinarySerializer()        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the BinarySerializer with the DEFINE operator to convert a file to a byte stream. No Formatting or interpretation takes place.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the BinarySerializer and BinaryDeserializer are use to convert data to and from streaming format.</para>
<programlisting>
DEFINE Y `stream.pl` INPUT(stdin USING BinarySerializer()) OUTPUT (stdout USING BinaryDeserializer());

X = STREAM A THROUGH Y;
</programlisting>
   </section></section>
   
   <section>
   <title>BinaryDeserializer</title>
   <para>Converts a byte stream into a file.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>BinarySerializer()        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the BinaryDeserializer with the DEFINE operator to convert a byte stream into a file. No Formatting or interpretation takes place.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the BinarySerializer and BinaryDeserializer are use to convert data to and from streaming format.</para>
<programlisting>
DEFINE Y `stream.pl` INPUT(stdin USING BinarySerializer()) OUTPUT (stdout USING BinaryDeserializer());

X = STREAM A THROUGH Y;
</programlisting>
   </section></section>
   
   <section>
   <title>BinStorage</title>
   <para>Loads and stores data in machine-readable format.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>BinStorage()        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>BinStorage works with data that is represented on disk in machine-readable format.</para>
   <para>BinStorage is used internally by Pig to store the temporary data that is created between multiple map/reduce jobs.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example BinStorage is used with the LOAD and STORE functions.</para>
<programlisting>
A = LOAD 'data' USING BinStorage();

STORE X into 'output' USING BinStorage(); 
</programlisting>
   </section></section>
   
   <section>
   <title>PigStorage</title>
   <para>Loads and stores data in UTF-8 format.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>PigStorage(field_delimiter)        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>field_delimiter</para>
            </entry>
            <entry>
               <para>Parameter. </para>
               <para>The default field delimiter is tab ('\t'). You can specify other characters as field delimiters.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>PigStorage works with structured text files in human-readable UTF-8 format. PigStorage also works with simple and complex data types and is the default function for the LOAD and STORE operators.</para>
   <itemizedlist>
      <listitem>
         <para>For load statements, PigStorage expects data to be formatted as delimiter-separated fields and newline-separated records ('\n'). </para>
      </listitem>
      <listitem>
         <para>For store statements, PigStorage outputs data as delimiter-separated fields and newline-separated records ('\n'). </para>
      </listitem>
   </itemizedlist>
   <para>For both load and store statements the default field delimiter is the tab character ('\t'). You can use other characters as field delimiters, but separators such as ^A or Ctrl-A should be represented in Unicode (\u0001) using UTF-16 encoding (see Wikipedia <ulink url="http://en.wikipedia.org/wiki/ASCII">ASCII</ulink>, <ulink url="http://en.wikipedia.org/wiki/Unicode">Unicode</ulink>, and <ulink url="http://en.wikipedia.org/wiki/UTF-16">UTF-16</ulink>).</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example PigStorage expects input.txt to contain tab-separated fields and newline-separated records. The statements are equivalent.</para>
<programlisting>
A = LOAD 'student' USING PigStorage('\t') AS (name: chararray, age:int, gpa: float); 

A = LOAD 'student' AS (name: chararray, age:int, gpa: float);
</programlisting>
   
   <para>In this example PigStorage stores the contents of X into files with fields that are delimited with an asterisk ( * ). The STORE function specifies that the files will be located in a directory named output and that the files will be named part-nnnnn (for example, part-00000).</para>
<programlisting>
STORE X INTO  'output' USING PigStorage('*');
</programlisting>
   </section></section>
   
   <section>
   <title>PigDump</title>
   <para>Stores data in UTF-8 format.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>PigDump()        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>PigDump stores data as tuples in human-readable UTF-8 format. </para></section>
   
   <section>
   <title>Example</title>
   <para>In this example PigDump is used with the STORE function.</para>
<programlisting>
STORE X INTO 'output' USING PigDump();
</programlisting>
   </section></section>
   
   <section>
   <title>TextLoader</title>
   <para>Loads unstructured data in UTF-8 format.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>TextLoader()</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   </section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>TextLoader works with unstructured data in UTF8 format. Each resulting tuple contains a single field with one line of input text. TextLoader cannot be used to store data.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example TextLoader is used with the LOAD function.</para>
<programlisting>
A = LOAD 'data' USING TextLoader();
</programlisting>
   </section></section></section>
   
   
   
   <!-- FILE COMMANDS-->
   <section>
   <title>File Commands</title>

   <section>
   <title>cat</title>
   <para>Prints the content of one or more files to the screen.</para>
   
   <section>
   <title>Syntax </title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>cat path [ path …]</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>path</para>
            </entry>
            <entry>
               <para>The location of a file or directory.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The cat command is similar to the Unix cat command. If multiple files are specified, content from all files is concatenated together. If multiple directories are specified, content from all files in all directories is concatenated together.</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the students file in the data directory is printed.</para>
<programlisting>
grunt> cat data/students;
joe smith
john adams
anne white
</programlisting>
   </section></section>
   
   <section>
   <title>cd</title>
   <para>Changes the current directory to another directory.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>cd [dir]</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>dir</para>
            </entry>
            <entry>
               <para>The name of the directory you want to navigate to.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The cd command is similar to the Unix cd command and can be used to navigate the file system. If a directory is specified, this directory is made your current working directory and all other operations happen relatively to this directory. If no directory is specified, your home directory (/user/NAME) becomes the current working directory. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example we move to the /data directory.</para>
<programlisting>
grunt&gt; cd /data
</programlisting>   
   </section></section>
   
   <section>
   <title>copyFromLocal</title>
   <para>Copies a file or directory from the local file system to HDFS.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>copyFromLocal src_path dst_path</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>src_path</para>
            </entry>
            <entry>
               <para>The path on the local file system for a file or directory</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>dst_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The copyFromLocal command enables you to copy a file or a director from the local file system to the Hadoop Distributed File System (HDFS). If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example a file (students) and a directory (/data/tests) are copied from the local file system to HDFS.</para>

<programlisting>
grunt> copyFromLocal /data/students students

grunt> ls students
/data/students &lt;r 3&gt; 8270

grunt>  copyFromLocal  /data/tests new_tests

grunt> ls new_test
/data/new_test/test1.data &lt;r 3&gt; 664
/data/new_test/test2.data &lt;r 3&gt; 344
/data/new_test/more_data   
</programlisting>
</section></section>
   
   <section>
   <title>copyToLocal</title>
   <para>Copies a file or directory from HDFS to a local file system. </para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>copyToLocal src_path dst_path</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>src_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>dst_path</para>
            </entry>
            <entry>
               <para>The path on the local file system for a file or directory.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The copyToLocal command enables you to copy a file or a director from Hadoop Distributed File System (HDFS) to a local file system. If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory (directory from which the script was executed or grunt shell started) and retain the name of the source file/directory. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example two files are copied from HDFS to the local file system.</para>
   <programlisting>
grunt&gt; copyToLocal students /data
grunt&gt; copyToLocal data /data/mydata
</programlisting>
   </section></section>
   
   <section>
   <title>cp</title>
   <para>Copies a file or directory within HDFS.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>cp src_path dst_path        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>src_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>dst_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The cp command is similar to the Unix cp command and enables you to copy files or directories within DFS. If a directory is specified, it is recursively copied over. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example a file (students) is copied to another file (students_save).</para>
 <programlisting>
grunt&gt; cp students students_save
</programlisting>
   </section></section>
   
   <section>
   <title>exec</title>
   <para>Run a Pig script.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>exec [–param param_name = param_value] [–param_file file_name] script  </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
   <tgroup cols="2"><tbody>
        <row>
            <entry>
               <para>–param param_name = param_value</para>
            </entry>
            <entry>
               <para>See Parameter Substitution.</para>
            </entry>
        </row>

        <row>
            <entry>
               <para>–param_file file_name</para>
            </entry>
            <entry>
               <para>See Parameter Substitution. </para>
            </entry>
        </row>
   
      <row>
            <entry>
               <para>script</para>
            </entry>
            <entry>
               <para>The name of a Pig script.</para>
            </entry>
         </row>
         
   </tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the exec command to run a Pig script with no interaction between the script and the Grunt shell (batch mode). Aliases defined in the script are not available to the shell; however, the files produced as the output of the script and stored on the system are visible after the script is run. Aliases defined via the shell are not available to the script. </para>
   <para>With the exec command, store statements will not trigger execution; rather, the entire script is parsed before execution starts. Unlike the run command, exec does not change the command history or remembers the handles used inside the script. Exec without any parameters can be used in scripts to force execution up to the point in the script where the exec occurs. </para>
   <para>For comparison, see the run command. Both the exec and run commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the script is displayed and run.</para>

<programlisting>
grunt&gt; cat myscript.pig
a = LOAD 'student' AS (name, age, gpa);
b = LIMIT a 3;
DUMP b;

grunt&gt; exec myscript.pig
(alice,20,2.47)
(luke,18,4.00)
(holly,24,3.27)
</programlisting>

   <para>In this example parameter substitution is used with the exec command.</para>
<programlisting>
grunt&gt; cat myscript.pig
a = LOAD 'student' AS (name, age, gpa);
b = ORDER a BY name;

STORE b into '$out';

grunt&gt; exec –param out=myoutput myscript.pig
</programlisting>
   </section></section>
   
   <section>
   <title>ls</title>
   <para>Lists the contents of a directory.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>ls [path]        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>path</para>
            </entry>
            <entry>
               <para>The name of the path/directory.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The ls command is similar to the Unix ls command and enables you to list the contents of a directory. If DIR is specified, the command lists the content of the specified directory. Otherwise, the content of the current working directory is listed. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the contents of the data directory are listed.</para>
<programlisting>
grunt&gt; ls /data
/data/DDLs  &lt;dir&gt;
/data/count &lt;dir&gt;
/data/data  &lt;dir&gt;
/data/schema &lt;dir&gt;
</programlisting>
   </section></section>
   
   <section>
   <title>mkdir</title>
   <para>Creates a new directory.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>mkdir path        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>path</para>
            </entry>
            <entry>
               <para>The name of the path/directory.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The mkdir command is similar to the Unix mkdir command and enables you to create a new directory. If you specify a directory or path that does not exist, it will be created.</para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example a directory and subdirectory are created.</para>
<programlisting>
grunt&gt; mkdir data/20070905
</programlisting>
   </section></section>
   
   <section>
   <title>mv</title>
   <para>Moves a file or directory within the Hadoop Distributed File System (HDFS).</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>mv src_path dst_path</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>src_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>dst_path</para>
            </entry>
            <entry>
               <para>The path on HDFS.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The mv command is identical to the Unix mv command (which copies files or directories within DFS) except that it deletes the source file or directory as soon as it is copied.</para>
   <para>If a directory is specified, it is recursively moved. Dot "." can be used to specify that the new file/directory should be created in the current working directory and retain the name of the source file/directory.  </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example the output directory is copied to output2 and then deleted.</para>

 <programlisting>
grunt&gt; mv output output2

grunt&gt; ls output
File or directory output does not exist.

grunt&gt; ls output2
/data/output2/map-000000&lt;r 3&gt;     508844
/data/output2/output3     &lt;dir&gt;
/data/output2/part-00000&lt;r 3&gt;     0
</programlisting>
</section></section>
   
   <section>
   <title>pwd</title>
   <para/>
   <para>Prints the name of the current working directory. </para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>pwd</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The pwd command is identical to Unix pwd command and it prints the name of the current working directory. </para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the name of the current working directory is /data.</para>

<programlisting>
grunt&gt; pwd
/data
</programlisting>
   </section></section>
   
   <section>
   <title>rm</title>
   <para>Removes one or more files or directories. </para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>rm path [path…]        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>path</para>
            </entry>
            <entry>
               <para>The name of the path/directory/file.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The rm command is similar to the Unix rm command and enables you to remove one or more files or directories.</para>
   <para>Note: This command recursively removes a directory even if it is not empty and it does not confirm remove and the removed data is not recoverable. </para></section>
   
   <section>
   <title>Example</title>
   <para>In this example files are removed.</para>

   <programlisting>
grunt&gt; rm /data/students
grunt&gt; rm students students_sav
</programlisting>
   </section></section>
   
   <section>
   <title>rmf</title>
   <para>Forcibly removes one or more files or directories. </para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>rmf path [path …]        </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>path</para>
            </entry>
            <entry>
               <para>The name of the path/directory/file.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The rmf command is similar to the Unix rm -f command and enables you to forcibly remove one or more files or directories.</para>
   <para>Note: This command recursively removes a directory even if it is not empty and it does not confirm remove and the removed data is not recoverable. </para>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example files are forcibly removed.</para>
 <programlisting>
grunt&gt; rmf /data/students
grunt&gt; rmf students students_sav
</programlisting>
   </section></section>
   
   <section>
   <title>run</title>
   <para>Run a Pig script.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>run [–param param_name = param_value] [–param_file file_name] script </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
   <tgroup cols="2"><tbody>
         <row>
            <entry>
               <para>–param param_name = param_value</para>
            </entry>
            <entry>
               <para>See Parameter Substitution.</para>
            </entry>
         </row>

         <row>
            <entry>
               <para>–param_file file_name</para>
            </entry>
            <entry>
               <para>See Parameter Substitution. </para>
            </entry>
         </row>
      <row>
            <entry>
               <para>script</para>
            </entry>
            <entry>
               <para>The name of a Pig script.</para>
            </entry>
         </row>
         
   </tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>Use the run command to run a Pig script that can interact with the Grunt shell (interactive mode). The script has access to aliases defined externally via the Grunt shell. The Grunt shell has access to aliases defined within the script. All commands from the script are visible in the command history. </para>   
	<para>With the run command, every store triggers execution. The statements from the script are put into the command history and all the aliases defined in the script can be referenced in subsequent statements after the run command has completed. Issuing a run command on the grunt command line has basically the same effect as typing the statements manually. </para>   
   <para>For comparison, see the exec command. Both the run and exec commands are useful for debugging because you can modify a Pig script in an editor and then rerun the script in the Grunt shell without leaving the shell. Also, both commands promote Pig script modularity as they allow you to reuse existing components.</para>
  </section>
   
   <section>
   <title>Example</title>
   <para>In this example the script interacts with the results of commands issued via the Grunt shell.</para>
<programlisting>
grunt&gt; cat myscript.pig
b = ORDER a BY name;
c = LIMIT b 10;

grunt&gt; a = LOAD 'student' AS (name, age, gpa);

grunt&gt; run myscript.pig

grunt&gt; d = LIMIT c 3;

grunt&gt; DUMP d;
(alice,20,2.47)
(alice,27,1.95)
(alice,36,2.27)
</programlisting>
   
   
   <para>In this example parameter substitution is used with the run command.</para>
<programlisting>
grunt&gt; a = LOAD 'student' AS (name, age, gpa);

grunt&gt; cat myscript.pig
b = ORDER a BY name;
STORE b into '$out';

grunt&gt; run –param out=myoutput myscript.pig
</programlisting>
   
   </section></section>
   </section>
   
   
   <section>
   <title>Utility Commands</title>
   
   <section>
   <title>help</title>
   <para>Prints a list of Pig commands.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>help         </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The help command prints a list of Pig commands.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the students file in the data directory is printed out.</para>
<programlisting>
grunt&gt; help
Commands:
&lt;pig latin statement&gt;;
store &lt;alias&gt; into &lt;filename&gt; [using &lt;functionSpec&gt;]
dump &lt;alias&gt;
<emphasis>etc …</emphasis></programlisting>
   </section></section>
   
   <section>
   <title>kill</title>
   <para>Kills a job.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>kill jobid</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>jobid</para>
            </entry>
            <entry>
               <para>The job id.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The kill command enables you to kill a job based on a job id.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the job with id job_0001 is killed.</para>
<programlisting>
grunt&gt; kill job_0001
</programlisting>
   </section></section>
   
   <section>
   <title>quit</title>
   <para>Quits from the Pig grunt shell.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>exit</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>none</para>
            </entry>
            <entry>
               <para>no parameters</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The quit command enables you to quit or exit the Pig grunt shell.</para></section>
   
   <section>
   <title>Example</title>
   <para>In this example the quit command exits the Pig grunt shall.</para>
<programlisting>
grunt&gt; quit
</programlisting>
   </section></section>
   
   <section>
   <title>set</title>
   <para>Assigns values to keys used in Pig.</para>
   
   <section>
   <title>Syntax</title>
   <informaltable frame="all">
      <tgroup cols="1"><tbody><row>
            <entry>
               <para>set key 'value'</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Terms</title>
   <informaltable frame="all">
      <tgroup cols="2"><tbody><row>
            <entry>
               <para>key</para>
            </entry>
            <entry>
               <para>Key (see table). Case sensitive.</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>value</para>
            </entry>
            <entry>
               <para>Value for key (see table). Case sensitive.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable></section>
   
   <section>
   <title>Usage</title>
   <para>The set command enables you to assign values to keys, as shown here:</para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Key </para>
            </entry>
            <entry>
               <para>Value </para>
            </entry>
            <entry>
               <para>Description </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>debug </para>
            </entry>
            <entry>
               <para>on/off </para>
            </entry>
            <entry>
               <para>enables/disables debug-level logging </para>
            </entry>
         </row>
         <row>
            <entry>
               <para>job.name </para>
            </entry>
            <entry>
               <para>single quoted string that contains the name </para>
            </entry>
            <entry>
               <para>sets user-specified name for the job </para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   <para/>
   </section>
   
   <section>
   <title>Example</title>
   <para>In this example debug is set on and the job is assigned a name.</para>
<programlisting>
grunt&gt; set debug on
grunt&gt; set job.name 'my job'
</programlisting>
   </section></section>
   
   
   </section>
  <!-- CONVENTIONS -->
<section>
<title>Conventions</title>
   <para>Conventions for the syntax and code examples in the Pig Latin Reference Manual are described here.</para>
   <informaltable frame="all">
      <tgroup cols="3"><tbody><row>
            <entry>
               <para>Convention</para>
            </entry>
            <entry>
               <para>Description</para>
            </entry>
            <entry>
               <para>Example</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>( )</para>
            </entry>
            <entry>
               <para>Parentheses enclose one or more items.</para>
               <para>Parentheses are also used to indicate the tuple data type.</para>
            </entry>
            <entry>
               <para>Multiple items:</para>
               <para>(1, abc, (2,4,6) )</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>[ ]</para>
            </entry>
            <entry>
               <para>Straight brackets enclose one or more optional items.</para>
               <para>Straight brackets are also used to indicate the map data type. In this case &lt;&gt; is used to indicate optional items.</para>
            </entry>
            <entry>
               <para>Optional items:</para>
               <para>[INNER | OUTER]</para>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>{ }</para>
            </entry>
            <entry>
               <para>Curly brackets enclose two or more items, one of which is required. </para>
               <para>Curly brackets also used to indicate the bag data type. In this case &lt;&gt; is used to indicate required items.</para>
            </entry>
            <entry>
               <para>Two items, one required:</para>
               <para>{ gen_blk | nested_gen_blk }</para>
               <para/>
            </entry>
         </row>
         <row>
            <entry>
               <para>…</para>
            </entry>
            <entry>
               <para>Horizontal ellipsis points indicate that you can repeat a portion of the code.</para>
            </entry>
            <entry>
               <para>Pig Latin syntax statement:</para>
               <para>cat path [path …]</para>
            </entry>
         </row>
         <row>
            <entry>
               <para>UPPERCASE</para>
               <para/>
               <para>lowercase</para>
            </entry>
            <entry>
               <para>In general, uppercase type indicates elements the system supplies.</para>
               <para>In general, lowercase type indicates elements that you supply.</para>
               <para>Note: The names (aliases) of relations and fields are case sensitive. The names of Pig Latin functions are case sensitive. All other Pig Latin keywords are case insensitive.</para>
            </entry>
            <entry>
               <para>Pig Latin statement:</para>
               <para>A = LOAD 'data' AS (f1:int);</para>
               <para/>
               <itemizedlist>
                  <listitem>
                     <para>LOAD, AS supplied BY system</para>
                  </listitem>
                  <listitem>
                     <para>A, f1 are names (aliases)</para>
                  </listitem>
                  <listitem>
                     <para>data supplied by you</para>
                  </listitem>
               </itemizedlist>
            </entry>
         </row>
         <row>
            <entry>
               <para>italics</para>
            </entry>
            <entry>
               <para>Italic type indicates placeholders or variables for which you must supply values.</para>
            </entry>
            <entry>
               <para>Pig Latin syntax:</para>
               <para>alias = LIMIT alias  n;</para>
               <para/>
               <para>You supply the values for placeholder alias and variable n.</para>
            </entry>
         </row></tbody></tgroup>
   </informaltable>
   </section>   
   </article>
  
   