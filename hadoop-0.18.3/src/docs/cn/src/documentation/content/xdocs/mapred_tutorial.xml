<?xml version="1.0" encoding="utf-8"?>
<!--
  Copyright 2002-2004 The Apache Software Foundation

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
-->

<!DOCTYPE document PUBLIC "-//APACHE//DTD Documentation V2.0//EN" "http://forrest.apache.org/dtd/document-v20.dtd">

<document>
  <header>
    <title>Hadoop Map/Reduce教程</title>
  </header>
  
  <body>
  
    <section>
      <title>目的</title>
      
      <p>这篇教程从用户的角度出发，全面地介绍了Hadoop Map/Reduce框架的各个方面。</p>
    </section>
    
    <section>
      <title>先决条件</title>
      
      <p>请先确认Hadoop被正确安装、配置和正常运行中。更多信息见：</p> 
      <ul>
        <li>
          <a href="quickstart.html">Hadoop快速入门</a>对初次使用者。
        </li>
        <li>
          <a href="cluster_setup.html">Hadoop集群搭建</a>对大规模分布式集群。
        </li>
      </ul>
    </section>
    
    <section>
      <title>概述</title>
      
      <p>Hadoop Map/Reduce是一个使用简易的软件框架，基于它写出来的应用程序能够运行在由上千个商用机器组成的大型集群上，并以一种可靠容错的方式并行处理上T级别的数据集。</p>
      
      <p>一个Map/Reduce <em>作业（job）</em> 通常会把输入的数据集切分为若干独立的数据块，由
      <em>map任务（task）</em>以完全并行的方式处理它们。框架会对map的输出先进行排序，
      然后把结果输入给<em>reduce任务</em>。通常作业的输入和输出都会被存储在文件系统中。
      整个框架负责任务的调度和监控，以及重新执行已经失败的任务。</p>
      
      <p>通常，Map/Reduce框架和<a href="hdfs_design.html">分布式文件系统</a>是运行在一组相同的节点上的，也就是说，计算节点和存储节点通常在一起。这种配置允许框架在那些已经存好数据的节点上高效地调度任务，这可以使整个集群的网络带宽被非常高效地利用。</p>
      
      <p>Map/Reduce框架由一个单独的master <code>JobTracker</code> 和每个集群节点一个slave <code>TaskTracker</code>共同组成。master负责调度构成一个作业的所有任务，这些任务分布在不同的slave上，master监控它们的执行，重新执行已经失败的任务。而slave仅负责执行由master指派的任务。</p>
      
      <p>应用程序至少应该指明输入/输出的位置（路径），并通过实现合适的接口或抽象类提供map和reduce函数。再加上其他作业的参数，就构成了<em>作业配置（job configuration）</em>。然后，Hadoop的 <em>job client</em>提交作业（jar包/可执行程序等）和配置信息给<code>JobTracker</code>，后者负责分发这些软件和配置信息给slave、调度任务并监控它们的执行，同时提供状态和诊断信息给job-client。</p>
      
      <p>虽然Hadoop框架是用Java<sup>TM</sup>实现的，但Map/Reduce应用程序则不一定要用
      Java来写 。</p>
      <ul>
        <li>
          <a href="ext:api/org/apache/hadoop/streaming/package-summary">
          Hadoop Streaming</a>是一种运行作业的实用工具，它允许用户创建和运行任何可执行程序
          （例如：Shell工具）来做为mapper和reducer。
        </li>
        <li>
          <a href="ext:api/org/apache/hadoop/mapred/pipes/package-summary">
          Hadoop Pipes</a>是一个与<a href="http://www.swig.org/">SWIG</a>兼容的C++ API
          （没有基于JNI<sup>TM</sup>技术），它也可用于实现Map/Reduce应用程序。
        </li>
      </ul>
    </section>
    
    <section>
      <title>输入与输出</title>

      <p>Map/Reduce框架运转在<code>&lt;key, value&gt;</code> 键值对上，也就是说，
      框架把作业的输入看为是一组<code>&lt;key, value&gt;</code> 键值对，同样也产出一组
      <code>&lt;key, value&gt;</code> 键值对做为作业的输出，这两组键值对的类型可能不同。</p> 
      
      <p>框架需要对<code>key</code>和<code>value</code>的类(classes)进行序列化操作，
      因此，这些类需要实现 <a href="ext:api/org/apache/hadoop/io/writable">Writable</a>接口。
      另外，为了方便框架执行排序操作，<code>key</code>类必须实现
      <a href="ext:api/org/apache/hadoop/io/writablecomparable">
      WritableComparable</a>接口。
      </p>

      <p>一个Map/Reduce 作业的输入和输出类型如下所示：</p>
      <p>
        (input) <code>&lt;k1, v1&gt;</code> 
        -&gt; 
        <strong>map</strong> 
        -&gt; 
        <code>&lt;k2, v2&gt;</code> 
        -&gt; 
        <strong>combine</strong> 
        -&gt; 
        <code>&lt;k2, v2&gt;</code> 
        -&gt; 
        <strong>reduce</strong> 
        -&gt; 
        <code>&lt;k3, v3&gt;</code> (output)
      </p>
    </section>

    <section>
      <title>例子：WordCount v1.0</title>
      
      <p>在深入细节之前，让我们先看一个Map/Reduce的应用示例，以便对它们的工作方式有一个初步的认识。</p>      
      <p><code>WordCount</code>是一个简单的应用，它可以计算出指定数据集中每一个单词出现的次数。</p>      
      <p>这个应用适用于
      <a href="quickstart.html#Standalone+Operation">单机模式</a>，
      <a href="quickstart.html#SingleNodeSetup">伪分布式模式</a> 或
      <a href="quickstart.html#Fully-Distributed+Operation">完全分布式模式</a> 
      三种Hadoop安装方式。</p>
      
      <section>
        <title>源代码</title>
        
        <table>
          <tr>
            <th></th>
            <th>WordCount.java</th>
          </tr>
          <tr>
            <td>1.</td>
            <td>
              <code>package org.myorg;</code>
            </td>
          </tr>
          <tr>
            <td>2.</td>
            <td></td>
          </tr>
          <tr>
            <td>3.</td>
            <td>
              <code>import java.io.IOException;</code>
            </td>
          </tr>
          <tr>
            <td>4.</td>
            <td>
              <code>import java.util.*;</code>
            </td>
          </tr>
          <tr>
            <td>5.</td>
            <td></td>
          </tr>
          <tr>
            <td>6.</td>
            <td>
              <code>import org.apache.hadoop.fs.Path;</code>
            </td>
          </tr>
          <tr>
            <td>7.</td>
            <td>
              <code>import org.apache.hadoop.conf.*;</code>
            </td>
          </tr>
          <tr>
            <td>8.</td>
            <td>
              <code>import org.apache.hadoop.io.*;</code>
            </td>
          </tr>
          <tr>
            <td>9.</td>
            <td>
              <code>import org.apache.hadoop.mapred.*;</code>
            </td>
          </tr>
          <tr>
            <td>10.</td>
            <td>
              <code>import org.apache.hadoop.util.*;</code>
            </td>
          </tr>
          <tr>
            <td>11.</td>
            <td></td>
          </tr>
          <tr>
            <td>12.</td>
            <td>
              <code>public class WordCount {</code>
            </td>
          </tr>
          <tr>
            <td>13.</td>
            <td></td>
          </tr>
          <tr>
            <td>14.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static class Map extends MapReduceBase 
                implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {
              </code>
            </td>
          </tr>
          <tr>
            <td>15.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                private final static IntWritable one = new IntWritable(1);
              </code>
            </td>
          </tr>
          <tr>
            <td>16.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private Text word = new Text();</code>
            </td>
          </tr>
          <tr>
            <td>17.</td>
            <td></td>
          </tr>
          <tr>
            <td>18.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                public void map(LongWritable key, Text value, 
                OutputCollector&lt;Text, IntWritable&gt; output, 
                Reporter reporter) throws IOException {
              </code>
            </td>
          </tr>
          <tr>
            <td>19.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>String line = value.toString();</code>
            </td>
          </tr>
          <tr>
            <td>20.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>StringTokenizer tokenizer = new StringTokenizer(line);</code>
            </td>
          </tr>
          <tr>
            <td>21.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>while (tokenizer.hasMoreTokens()) {</code>
            </td>
          </tr>
          <tr>
            <td>22.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>word.set(tokenizer.nextToken());</code>
            </td>
          </tr>
          <tr>
            <td>23.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>output.collect(word, one);</code>
            </td>
          </tr>
          <tr>
            <td>24.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>25.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>26.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>27.</td>
            <td></td>
          </tr>
          <tr>
            <td>28.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static class Reduce extends MapReduceBase implements 
                Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
              </code>
            </td>
          </tr>
          <tr>
            <td>29.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                public void reduce(Text key, Iterator&lt;IntWritable&gt; values,
                OutputCollector&lt;Text, IntWritable&gt; output, 
                Reporter reporter) throws IOException {
              </code>
            </td>
          </tr>
          <tr>
            <td>30.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>int sum = 0;</code>
            </td>
          </tr>
          <tr>
            <td>31.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>while (values.hasNext()) {</code>
            </td>
          </tr>
          <tr>
            <td>32.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>sum += values.next().get();</code>
            </td>
          </tr>
          <tr>
            <td>33.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>34.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>output.collect(key, new IntWritable(sum));</code>
            </td>
          </tr>
          <tr>
            <td>35.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>36.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>37.</td>
            <td></td>
          </tr>
          <tr>
            <td>38.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static void main(String[] args) throws Exception {
              </code>
            </td>
          </tr>
          <tr>
            <td>39.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                JobConf conf = new JobConf(WordCount.class);
              </code>
            </td>
          </tr>
          <tr>
            <td>40.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setJobName("wordcount");</code>
            </td>
          </tr>
          <tr>
            <td>41.</td>
            <td></td>
          </tr>
          <tr>
            <td>42.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputKeyClass(Text.class);</code>
            </td>
          </tr>
          <tr>
            <td>43.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputValueClass(IntWritable.class);</code>
            </td>
          </tr>
          <tr>
            <td>44.</td>
            <td></td>
          </tr>
          <tr>
            <td>45.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setMapperClass(Map.class);</code>
            </td>
          </tr>
          <tr>
            <td>46.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setCombinerClass(Reduce.class);</code>
            </td>
          </tr>
          <tr>
            <td>47.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setReducerClass(Reduce.class);</code>
            </td>
          </tr>
          <tr>
            <td>48.</td>
            <td></td>
          </tr>
          <tr>
            <td>49.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setInputFormat(TextInputFormat.class);</code>
            </td>
          </tr>
          <tr>
            <td>50.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputFormat(TextOutputFormat.class);</code>
            </td>
          </tr>
          <tr>
            <td>51.</td>
            <td></td>
          </tr>
          <tr>
            <td>52.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>FileInputFormat.setInputPaths(conf, new Path(args[0]));</code>
            </td>
          </tr>
          <tr>
            <td>53.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>FileOutputFormat.setOutputPath(conf, new Path(args[1]));</code>
            </td>
          </tr>
          <tr>
            <td>54.</td>
            <td></td>
          </tr>
          <tr>
            <td>55.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>JobClient.runJob(conf);</code>
            </td>
          </tr>
          <tr>
            <td>57.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>58.</td>
            <td>
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>59.</td>
            <td></td>
          </tr>
        </table>
      </section>
      
      <section>
        <title>用法</title>
        
        <p>假设环境变量<code>HADOOP_HOME</code>对应安装时的根目录，<code>HADOOP_VERSION</code>对应Hadoop的当前安装版本，编译<code>WordCount.java</code>来创建jar包，可如下操作：</p>
        <p>
          <code>$ mkdir wordcount_classes</code><br/>
          <code>
            $ javac -classpath ${HADOOP_HOME}/hadoop-${HADOOP_VERSION}-core.jar 
              -d wordcount_classes WordCount.java
          </code><br/>
          <code>$ jar -cvf /usr/joe/wordcount.jar -C wordcount_classes/ .</code> 
        </p>
        
        <p>假设：</p>
        <ul>
          <li>
            <code>/usr/joe/wordcount/input</code>  - 是HDFS中的输入路径
          </li>
          <li>
            <code>/usr/joe/wordcount/output</code> - 是HDFS中的输出路径
          </li>
        </ul>
        
        <p>用示例文本文件做为输入：</p>
        <p>
          <code>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/</code><br/>
          <code>/usr/joe/wordcount/input/file01</code><br/>
          <code>/usr/joe/wordcount/input/file02</code><br/>
          <br/>
          <code>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01</code><br/>
          <code>Hello World Bye World</code><br/>
          <br/>
          <code>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02</code><br/>
          <code>Hello Hadoop Goodbye Hadoop</code>
        </p>

        <p>运行应用程序：</p>
        <p>
          <code>
            $ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount 
              /usr/joe/wordcount/input /usr/joe/wordcount/output 
          </code>
        </p>

        <p>输出是：</p>
        <p>
          <code>
            $ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000
          </code>
          <br/>
          <code>Bye    1</code><br/>
          <code>Goodbye    1</code><br/>
          <code>Hadoop    2</code><br/>
          <code>Hello    2</code><br/>
          <code>World    2</code><br/>
        </p>
          <p> 应用程序能够使用<code>-files</code>选项来指定一个由逗号分隔的路径列表，这些路径是task的当前工作目录。使用选项<code>-libjars</code>可以向map和reduce的classpath中添加jar包。使用<code>-archives</code>选项程序可以传递档案文件做为参数，这些档案文件会被解压并且在task的当前工作目录下会创建一个指向解压生成的目录的符号链接（以压缩包的名字命名）。
        有关命令行选项的更多细节请参考
        <a href="commands_manual.html">Commands manual</a>。</p>

        <p>使用<code>-libjars</code>和<code>-files</code>运行<code>wordcount</code>例子：<br/>
        <code> hadoop jar hadoop-examples.jar wordcount -files cachefile.txt
        -libjars mylib.jar input output </code>
        </p>

      </section>
      
      <section>
        <title>解释</title>
        
        <p><code>WordCount</code>应用程序非常直截了当。</p>
        
        <p><code>Mapper</code>(14-26行)中的<code>map</code>方法(18-25行)通过指定的
        <code>TextInputFormat</code>(49行)一次处理一行。然后，它通过<code>StringTokenizer</code>
        以空格为分隔符将一行切分为若干tokens，之后，输出<code>&lt; &lt;word&gt;, 1&gt;</code>
        形式的键值对。</p>
        
        <p>
        对于示例中的第一个输入，map输出是：<br/>
          <code>&lt; Hello, 1&gt;</code><br/>
          <code>&lt; World, 1&gt;</code><br/>
          <code>&lt; Bye, 1&gt;</code><br/>
          <code>&lt; World, 1&gt;</code><br/>
        </p>
        
        <p>
          第二个输入，map输出是：<br/>
          <code>&lt; Hello, 1&gt;</code><br/>
          <code>&lt; Hadoop, 1&gt;</code><br/>
          <code>&lt; Goodbye, 1&gt;</code><br/>
          <code>&lt; Hadoop, 1&gt;</code><br/>
        </p>
        
        <p>关于组成一个指定作业的map数目的确定，以及如何以更精细的方式去控制这些map，我们将在教程的后续部分学习到更多的内容。</p>
        
        <p><code>WordCount</code>还指定了一个<code>combiner</code> (46行)。因此，每次map运行之后，会对输出按照<em>key</em>进行排序，然后把输出传递给本地的combiner（按照作业的配置与Reducer一样），进行本地聚合。</p>

        <p>
         第一个map的输出是：<br/>
          <code>&lt; Bye, 1&gt;</code><br/>
          <code>&lt; Hello, 1&gt;</code><br/>
          <code>&lt; World, 2&gt;</code><br/>
        </p>
        
        <p>
          第二个map的输出是：<br/>
          <code>&lt; Goodbye, 1&gt;</code><br/>
          <code>&lt; Hadoop, 2&gt;</code><br/>
          <code>&lt; Hello, 1&gt;</code><br/>
        </p>

        <p><code>Reducer</code>(28-36行)中的<code>reduce</code>方法(29-35行)
        仅是将每个key（本例中就是单词）出现的次数求和。
        </p>
        
        <p>
          因此这个作业的输出就是：<br/>
          <code>&lt; Bye, 1&gt;</code><br/>
          <code>&lt; Goodbye, 1&gt;</code><br/>
          <code>&lt; Hadoop, 2&gt;</code><br/>
          <code>&lt; Hello, 2&gt;</code><br/>
          <code>&lt; World, 2&gt;</code><br/>
        </p>
        
        <p>代码中的<code>run</code>方法中指定了作业的几个方面，
        例如：通过命令行传递过来的输入/输出路径、key/value的类型、输入/输出的格式等等<code>JobConf</code>中的配置信息。随后程序调用了<code>JobClient.runJob</code>(55行)来提交作业并且监控它的执行。</p>

        <p>我们将在本教程的后续部分学习更多的关于<code>JobConf</code>， <code>JobClient</code>，
        <code>Tool</code>和其他接口及类(class)。</p>
      </section>
    </section>
    
    <section>
      <title>Map/Reduce - 用户界面</title>
      
      <p>这部分文档为用户将会面临的Map/Reduce框架中的各个环节提供了适当的细节。这应该会帮助用户更细粒度地去实现、配置和调优作业。然而，请注意每个类/接口的javadoc文档提供最全面的文档；本文只是想起到指南的作用。
      </p>
      
      <p>我们会先看看<code>Mapper</code>和<code>Reducer</code>接口。应用程序通常会通过提供<code>map</code>和<code>reduce</code>方法来实现它们。
      </p>
      
      <p>然后，我们会讨论其他的核心接口，其中包括：
      <code>JobConf</code>，<code>JobClient</code>，<code>Partitioner</code>， 
      <code>OutputCollector</code>，<code>Reporter</code>， 
      <code>InputFormat</code>，<code>OutputFormat</code>等等。</p>
      
      <p>最后，我们将通过讨论框架中一些有用的功能点（例如：<code>DistributedCache</code>， 
      <code>IsolationRunner</code>等等）来收尾。</p>

      <section>
        <title>核心功能描述</title>
        
        <p>应用程序通常会通过提供<code>map</code>和<code>reduce</code>来实现
        <code>Mapper</code>和<code>Reducer</code>接口，它们组成作业的核心。</p>
        
        <section>
          <title>Mapper</title>

          <p><a href="ext:api/org/apache/hadoop/mapred/mapper">
          Mapper</a>将输入键值对(key/value pair)映射到一组中间格式的键值对集合。</p>
 
          <p>Map是一类将输入记录集转换为中间格式记录集的独立任务。
          这种转换的中间格式记录集不需要与输入记录集的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。</p> 
 
          <p>Hadoop Map/Reduce框架为每一个<code>InputSplit</code>产生一个map任务，而每个<code>InputSplit</code>是由该作业的<code>InputFormat</code>产生的。</p>
          
          <p>概括地说，对<code>Mapper</code>的实现者需要重写
          <a href="ext:api/org/apache/hadoop/mapred/jobconfigurable/configure">
		  JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个<code>JobConf</code>参数，目的是完成Mapper的初始化工作。然后，框架为这个任务的<code>InputSplit</code>中每个键值对调用一次
	  <a href="ext:api/org/apache/hadoop/mapred/mapper/map">
		  map(WritableComparable, Writable, OutputCollector, Reporter)</a>操作。应用程序可以通过重写<a href="ext:api/org/apache/hadoop/io/closeable/close">Closeable.close()</a>方法来执行相应的清理工作。</p>
 
          <p>输出键值对不需要与输入键值对的类型一致。一个给定的输入键值对可以映射成0个或多个输出键值对。通过调用<a href="ext:api/org/apache/hadoop/mapred/outputcollector/collect">
          OutputCollector.collect(WritableComparable,Writable)</a>可以收集输出的键值对。</p>

          <p>应用程序可以使用<code>Reporter</code>报告进度，设定应用级别的状态消息，更新<code>Counters</code>（计数器），或者仅是表明自己运行正常。</p>
 
          <p>框架随后会把与一个特定key关联的所有中间过程的值（value）分成组，然后把它们传给<code>Reducer</code>以产出最终的结果。用户可以通过
          <a href="ext:api/org/apache/hadoop/mapred/jobconf/setoutputkeycomparatorclass">
          JobConf.setOutputKeyComparatorClass(Class)</a>来指定具体负责分组的
          <code>Comparator</code>。</p>

          <p><code>Mapper</code>的输出被排序后，就被划分给每个<code>Reducer</code>。分块的总数目和一个作业的reduce任务的数目是一样的。用户可以通过实现自定义的          <code>Partitioner</code>来控制哪个key被分配给哪个 <code>Reducer</code>。</p>
 
          <p>用户可选择通过<a href="ext:api/org/apache/hadoop/mapred/jobconf/setcombinerclass">
          JobConf.setCombinerClass(Class)</a>指定一个<code>combiner</code>，它负责对中间过程的输出进行本地的聚集，这会有助于降低从<code>Mapper</code>到
          <code>Reducer</code>数据传输量。
          </p>
          <p>这些被排好序的中间过程的输出结果保存的格式是(key-len, key, value-len, value)，应用程序可以通过<code>JobConf</code>控制对这些中间结果是否进行压缩以及怎么压缩，使用哪种<a href="ext:api/org/apache/hadoop/io/compress/compressioncodec">
          CompressionCodec</a>。
          </p>
          
          <section>
            <title>需要多少个Map？</title>
             
            <p>Map的数目通常是由输入数据的大小决定的，一般就是所有输入文件的总块（block）数。</p>
  
            <p>Map正常的并行规模大致是每个节点（node）大约10到100个map，对于CPU
            消耗较小的map任务可以设到300个左右。由于每个任务初始化需要一定的时间，因此，比较合理的情况是map执行的时间至少超过1分钟。</p>
 
            <p>这样，如果你输入10TB的数据，每个块（block）的大小是128MB，你将需要大约82,000个map来完成任务，除非使用
            <a href="ext:api/org/apache/hadoop/mapred/jobconf/setnummaptasks">
            setNumMapTasks(int)</a>（注意：这里仅仅是对框架进行了一个提示(hint)，实际决定因素见<a href="ext:api/org/apache/hadoop/mapred/jobconf/setnummaptasks">这里</a>）将这个数值设置得更高。</p>
          </section>
        </section>
        
        <section>
          <title>Reducer</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/reducer">
          Reducer</a>将与一个key关联的一组中间数值集归约（reduce）为一个更小的数值集。</p>
          
          <p>用户可以通过<a href="ext:api/org/apache/hadoop/mapred/jobconf/setnumreducetasks">
          JobConf.setNumReduceTasks(int)</a>设定一个作业中reduce任务的数目。</p>
          
          <p>概括地说，对<code>Reducer</code>的实现者需要重写
          <a href="ext:api/org/apache/hadoop/mapred/jobconfigurable/configure">
          JobConfigurable.configure(JobConf)</a>方法，这个方法需要传递一个<code>JobConf</code>参数，目的是完成Reducer的初始化工作。然后，框架为成组的输入数据中的每个<code>&lt;key, (list of values)&gt;</code>对调用一次
          <a href="ext:api/org/apache/hadoop/mapred/reducer/reduce">
          reduce(WritableComparable, Iterator, OutputCollector, Reporter)</a>方法。之后，应用程序可以通过重写<a href="ext:api/org/apache/hadoop/io/closeable/close">Closeable.close()</a>来执行相应的清理工作。</p>

          <p><code>Reducer</code>有3个主要阶段：shuffle、sort和reduce。
          </p>
          
          <section>
            <title>Shuffle</title>
   
            <p><code>Reducer</code>的输入就是Mapper已经排好序的输出。在这个阶段，框架通过HTTP为每个Reducer获得所有Mapper输出中与之相关的分块。</p>
          </section>
   
          <section>
            <title>Sort</title>
   
            <p>这个阶段，框架将按照key的值对<code>Reducer</code>的输入进行分组
            （因为不同mapper的输出中可能会有相同的key）。</p>
   
            <p>Shuffle和Sort两个阶段是同时进行的；map的输出也是一边被取回一边被合并的。</p>
      
            <section>
              <title>Secondary Sort</title>
   
              <p>如果需要中间过程对key的分组规则和reduce前对key的分组规则不同，那么可以通过<a href="ext:api/org/apache/hadoop/mapred/jobconf/setoutputvaluegroupingcomparator">
              JobConf.setOutputValueGroupingComparator(Class)</a>来指定一个<code>Comparator</code>。再加上
              <a href="ext:api/org/apache/hadoop/mapred/jobconf/setoutputkeycomparatorclass">
              JobConf.setOutputKeyComparatorClass(Class)</a>可用于控制中间过程的key如何被分组，所以结合两者可以实现<em>按值的二次排序</em>。
              </p>
            </section>
          </section>
   
          <section>   
            <title>Reduce</title>
   
            <p>在这个阶段，框架为已分组的输入数据中的每个
          <code>&lt;key, (list of values)&gt;</code>对调用一次
          <a href="ext:api/org/apache/hadoop/mapred/reducer/reduce">
          reduce(WritableComparable, Iterator, OutputCollector, Reporter)</a>方法。</p>
            
            <p>Reduce任务的输出通常是通过调用
            <a href="ext:api/org/apache/hadoop/mapred/outputcollector/collect">
            OutputCollector.collect(WritableComparable, Writable)</a>写入
            <a href="ext:api/org/apache/hadoop/fs/filesystem">
            文件系统</a>的。</p>
   
          <p>应用程序可以使用<code>Reporter</code>报告进度，设定应用程序级别的状态消息，更新<code>Counters</code>（计数器），或者仅是表明自己运行正常。</p>

	  <p><code>Reducer</code>的输出是<em>没有排序的</em>。</p>
          </section>
          
          <section>
            <title>需要多少个Reduce？</title>
 
            <p>Reduce的数目建议是<code>0.95</code>或<code>1.75</code>乘以
            (&lt;<em>no. of nodes</em>&gt; * 
            <code>mapred.tasktracker.reduce.tasks.maximum</code>)。
            </p>
 
            <p>用0.95，所有reduce可以在maps一完成时就立刻启动，开始传输map的输出结果。用1.75，速度快的节点可以在完成第一轮reduce任务后，可以开始第二轮，这样可以得到比较好的负载均衡的效果。</p>
 
            <p>增加reduce的数目会增加整个框架的开销，但可以改善负载均衡，降低由于执行失败带来的负面影响。</p>
 
            <p>上述比例因子比整体数目稍小一些是为了给框架中的推测性任务（speculative-tasks）
            或失败的任务预留一些reduce的资源。</p>
          </section>
          
          <section>
            <title>无Reducer</title>
            
	    <p>如果没有归约要进行，那么设置reduce任务的数目为<em>零</em>是合法的。</p>
 
            <p>这种情况下，map任务的输出会直接被写入由
            <a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/setoutputpath">
		    setOutputPath(Path)</a>指定的输出路径。框架在把它们写入<code>FileSystem</code>之前没有对它们进行排序。
            </p>
          </section>
        </section>
        
        <section>
          <title>Partitioner</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/partitioner">
          Partitioner</a>用于划分键值空间（key space）。</p>
          
          <p>Partitioner负责控制map输出结果key的分割。Key（或者一个key子集）被用于产生分区，通常使用的是Hash函数。分区的数目与一个作业的reduce任务的数目是一样的。因此，它控制将中间过程的key（也就是这条记录）应该发送给<code>m</code>个reduce任务中的哪一个来进行reduce操作。
	  </p>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/lib/hashpartitioner">
          HashPartitioner</a>是默认的 <code>Partitioner</code>。  </p>
        </section>
        
        <section>
          <title>Reporter</title>

          <p><a href="ext:api/org/apache/hadoop/mapred/reporter">
          Reporter</a>是用于Map/Reduce应用程序报告进度，设定应用级别的状态消息，
          更新<code>Counters</code>（计数器）的机制。</p>
   
          <p><code>Mapper</code>和<code>Reducer</code>的实现可以利用<code>Reporter</code>
          来报告进度，或者仅是表明自己运行正常。在那种应用程序需要花很长时间处理个别键值对的场景中，这种机制是很关键的，因为框架可能会以为这个任务超时了，从而将它强行杀死。另一个避免这种情况发生的方式是，将配置参数<code>mapred.task.timeout</code>设置为一个足够高的值（或者干脆设置为零，则没有超时限制了）。
          </p>

          <p>应用程序可以用<code>Reporter</code>来更新<code>Counter</code>（计数器）。
          </p>
        </section>
      
        <section>
          <title>OutputCollector</title>
        
          <p><a href="ext:api/org/apache/hadoop/mapred/outputcollector">
          OutputCollector</a>是一个Map/Reduce框架提供的用于收集
          <code>Mapper</code>或<code>Reducer</code>输出数据的通用机制
          （包括中间输出结果和作业的输出结果）。</p>
        </section>
      
        <p>Hadoop Map/Reduce框架附带了一个包含许多实用型的mapper、reducer和partitioner
        的<a href="ext:api/org/apache/hadoop/mapred/lib/package-summary">类库</a>。</p>
      </section>
      
      <section>
        <title>作业配置</title>
        
        <p><a href="ext:api/org/apache/hadoop/mapred/jobconf">
        JobConf</a>代表一个Map/Reduce作业的配置。</p>
 
        <p><code>JobConf</code>是用户向Hadoop框架描述一个Map/Reduce作业如何执行的主要接口。框架会按照<code>JobConf</code>描述的信息忠实地去尝试完成这个作业，然而：</p> 
        <ul>
          <li>
            一些参数可能会被管理者标记为<a href="ext:api/org/apache/hadoop/conf/configuration/final_parameters">
            final</a>，这意味它们不能被更改。
          </li>
          <li>
          一些作业的参数可以被直截了当地进行设置（例如：
          <a href="ext:api/org/apache/hadoop/mapred/jobconf/setnumreducetasks">
            setNumReduceTasks(int)</a>），而另一些参数则与框架或者作业的其他参数之间微妙地相互影响，并且设置起来比较复杂（例如：<a href="ext:api/org/apache/hadoop/mapred/jobconf/setnummaptasks">
            setNumMapTasks(int)</a>）。
          </li>
        </ul>
 
        <p>通常，<code>JobConf</code>会指明<code>Mapper</code>、Combiner(如果有的话)、
        <code>Partitioner</code>、<code>Reducer</code>、<code>InputFormat</code>和 
        <code>OutputFormat</code>的具体实现。<code>JobConf</code>还能指定一组输入文件
        (<a href="ext:api/org/apache/hadoop/mapred/fileinputformat/setinputpaths">setInputPaths(JobConf, Path...)</a>
        /<a href="ext:api/org/apache/hadoop/mapred/fileinputformat/addinputpath">addInputPath(JobConf, Path)</a>)
        和(<a href="ext:api/org/apache/hadoop/mapred/fileinputformat/setinputpathstring">setInputPaths(JobConf, String)</a>
        /<a href="ext:api/org/apache/hadoop/mapred/fileinputformat/addinputpathstring">addInputPaths(JobConf, String)</a>)
        以及输出文件应该写在哪儿
        (<a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/setoutputpath">setOutputPath(Path)</a>)。</p>

        <p><code>JobConf</code>可选择地对作业设置一些高级选项，例如：设置<code>Comparator</code>；
        放到<code>DistributedCache</code>上的文件；中间结果或者作业输出结果是否需要压缩以及怎么压缩；
        利用用户提供的脚本(<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmapdebugscript">setMapDebugScript(String)</a>/<a href="ext:api/org/apache/hadoop/mapred/jobconf/setreducedebugscript">setReduceDebugScript(String)</a>)     
        进行调试；作业是否允许<em>预防性（speculative）</em>任务的执行
        (<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmapspeculativeexecution">setMapSpeculativeExecution(boolean)</a>)/(<a href="ext:api/org/apache/hadoop/mapred/jobconf/setreducespeculativeexecution">setReduceSpeculativeExecution(boolean)</a>)
        ；每个任务最大的尝试次数
        (<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmaxmapattempts">setMaxMapAttempts(int)</a>/<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmaxreduceattempts">setMaxReduceAttempts(int)</a>)
        ；一个作业能容忍的任务失败的百分比
        (<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmaxmaptaskfailurespercent">setMaxMapTaskFailuresPercent(int)</a>/<a href="ext:api/org/apache/hadoop/mapred/jobconf/setmaxreducetaskfailurespercent">setMaxReduceTaskFailuresPercent(int)</a>) 
        ；等等。</p>
        
        <p>当然，用户能使用
        <a href="ext:api/org/apache/hadoop/conf/configuration/set">set(String, String)</a>/<a href="ext:api/org/apache/hadoop/conf/configuration/get">get(String, String)</a>
        来设置或者取得应用程序需要的任意参数。然而，<code>DistributedCache</code>的使用是面向大规模只读数据的。</p>
      </section>

      <section>
        <title>任务的执行和环境</title>

        <p><code>TaskTracker</code>是在一个单独的jvm上以子进程的形式执行
        <code>Mapper</code>/<code>Reducer</code>任务（Task）的。
        </p>
        
        <p>子任务会继承父<code>TaskTracker</code>的环境。用户可以通过JobConf中的
        <code>mapred.child.java.opts</code>配置参数来设定子jvm上的附加选项，例如：
        通过<code>-Djava.library.path=&lt;&gt;</code> 将一个非标准路径设为运行时的链接用以搜索共享库，等等。如果<code>mapred.child.java.opts</code>包含一个符号<em>@taskid@</em>，
        它会被替换成map/reduce的taskid的值。</p>
        
        <p>下面是一个包含多个参数和替换的例子，其中包括：记录jvm GC日志；
        JVM JMX代理程序以无密码的方式启动，这样它就能连接到jconsole上，从而可以查看子进程的内存和线程，得到线程的dump；还把子jvm的最大堆尺寸设置为512MB，
        并为子jvm的<code>java.library.path</code>添加了一个附加路径。</p>

        <p>
          <code>&lt;property&gt;</code><br/>
          &nbsp;&nbsp;<code>&lt;name&gt;mapred.child.java.opts&lt;/name&gt;</code><br/>
          &nbsp;&nbsp;<code>&lt;value&gt;</code><br/>
          &nbsp;&nbsp;&nbsp;&nbsp;<code>
                    -Xmx512M -Djava.library.path=/home/mycompany/lib
                    -verbose:gc -Xloggc:/tmp/@taskid@.gc</code><br/>
          &nbsp;&nbsp;&nbsp;&nbsp;<code>
                    -Dcom.sun.management.jmxremote.authenticate=false 
                    -Dcom.sun.management.jmxremote.ssl=false</code><br/>
          &nbsp;&nbsp;<code>&lt;/value&gt;</code><br/>
          <code>&lt;/property&gt;</code>
        </p>
        <p>用户或管理员也可以使用<code>mapred.child.ulimit</code>设定运行的子任务的最大虚拟内存。<code>mapred.child.ulimit</code>的值以（KB)为单位，并且必须大于或等于-Xmx参数传给JavaVM的值，否则VM会无法启动。</p>
        <p>注意：<code>mapred.child.java.opts</code>只用于设置task tracker启动的子任务。为守护进程设置内存选项请查看
        <a href="cluster_setup.html#配置Hadoop守护进程的运行环境">
        cluster_setup.html </a></p>
        <p><code> ${mapred.local.dir}/taskTracker/</code>是task tracker的本地目录，
        用于创建本地缓存和job。它可以指定多个目录（跨越多个磁盘），文件会半随机的保存到本地路径下的某个目录。当job启动时，task tracker根据配置文档创建本地job目录，目录结构如以下所示：</p>
        <ul>
	<li><code>${mapred.local.dir}/taskTracker/archive/</code> :分布式缓存。这个目录保存本地的分布式缓存。因此本地分布式缓存是在所有task和job间共享的。</li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/</code> :
        本地job目录。
        <ul>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/work/</code>:
        job指定的共享目录。各个任务可以使用这个空间做为暂存空间，用于它们之间共享文件。这个目录通过<code>job.local.dir </code>参数暴露给用户。这个路径可以通过API <a href="ext:api/org/apache/hadoop/mapred/jobconf/getjoblocaldir">
        JobConf.getJobLocalDir()</a>来访问。它也可以被做为系统属性获得。因此，用户（比如运行streaming）可以调用<code>System.getProperty("job.local.dir")</code>获得该目录。
        </li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/jars/</code>:
        存放jar包的路径，用于存放作业的jar文件和展开的jar。<code>job.jar</code>是应用程序的jar文件，它会被自动分发到各台机器，在task启动前会被自动展开。使用api
        <a href="ext:api/org/apache/hadoop/mapred/jobconf/getjar">
        JobConf.getJar() </a>函数可以得到job.jar的位置。使用JobConf.getJar().getParent()可以访问存放展开的jar包的目录。
        </li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/job.xml</code>：
        一个job.xml文件，本地的通用的作业配置文件。
        </li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid</code>：
        每个任务有一个目录<code>task-id</code>，它里面有如下的目录结构：
	<ul>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/job.xml</code>：
       一个job.xml文件，本地化的任务作业配置文件。任务本地化是指为该task设定特定的属性值。这些值会在下面具体说明。
	</li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/output</code>
        一个存放中间过程的输出文件的目录。它保存了由framwork产生的临时map reduce数据，比如map的输出文件等。</li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work</code>：
        task的当前工作目录。</li>
        <li><code>${mapred.local.dir}/taskTracker/jobcache/$jobid/$taskid/work/tmp</code>：
        task的临时目录。（用户可以设定属性<code>mapred.child.tmp</code>
        来为map和reduce task设定临时目录。缺省值是<code>./tmp</code>。如果这个值不是绝对路径，
        它会把task的工作路径加到该路径前面作为task的临时文件路径。如果这个值是绝对路径则直接使用这个值。
        如果指定的目录不存在，会自动创建该目录。之后，按照选项
        <code>-Djava.io.tmpdir='临时文件的绝对路径'</code>执行java子任务。
        pipes和streaming的临时文件路径是通过环境变量<code>TMPDIR='the absolute path of the tmp dir'</code>设定的）。
        如果<code>mapred.child.tmp</code>有<code>./tmp</code>值，这个目录会被创建。</li>
        </ul>
        </li>
        </ul>
        </li>
        </ul>
        <p>下面的属性是为每个task执行时使用的本地参数，它们保存在本地化的任务作业配置文件里：</p>
        <table>
          <tr><th>名称</th><th>类型</th><th>描述</th></tr>
          <tr><td>mapred.job.id</td><td>String</td><td>job id</td></tr>
          <tr><td>mapred.jar</td><td>String</td>
              <td>job目录下job.jar的位置</td></tr>
          <tr><td>job.local.dir</td><td> String</td>
              <td>job指定的共享存储空间</td></tr>
          <tr><td>mapred.tip.id</td><td> String</td>
              <td> task id</td></tr>
          <tr><td>mapred.task.id</td><td> String</td>
              <td> task尝试id</td></tr>
          <tr><td>mapred.task.is.map</td><td> boolean </td>
              <td>是否是map task</td></tr>
          <tr><td>mapred.task.partition</td><td> int </td>
              <td>task在job中的id</td></tr>
          <tr><td>map.input.file</td><td> String</td>
              <td> map读取的文件名</td></tr>
          <tr><td>map.input.start</td><td> long</td>
              <td> map输入的数据块的起始位置偏移</td></tr>
          <tr><td>map.input.length </td><td>long </td>
              <td>map输入的数据块的字节数</td></tr>
          <tr><td>mapred.work.output.dir</td><td> String </td>
              <td>task临时输出目录</td></tr>
        </table>
        <p>task的标准输出和错误输出流会被读到TaskTracker中，并且记录到
        <code>${HADOOP_LOG_DIR}/userlogs</code></p>
        <p><a href="#DistributedCache">DistributedCache</a>
        可用于map或reduce task中分发jar包和本地库。子jvm总是把
        <em>当前工作目录</em> 加到
        <code>java.library.path</code> 和 <code>LD_LIBRARY_PATH</code>。
        因此，可以通过
        <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#loadLibrary(java.lang.String)">
        System.loadLibrary</a>或 
        <a href="http://java.sun.com/j2se/1.5.0/docs/api/java/lang/System.html#load(java.lang.String)">
        System.load</a>装载缓存的库。有关使用分布式缓存加载共享库的细节请参考
        <a href="native_libraries.html#使用DistributedCache+加载本地库">
        native_libraries.html</a></p>
      </section>
      
      <section>
        <title>作业的提交与监控</title>
        
        <p><a href="ext:api/org/apache/hadoop/mapred/jobclient">
        JobClient</a>是用户提交的作业与<code>JobTracker</code>交互的主要接口。
        </p>
 
        <p><code>JobClient</code> 提供提交作业，追踪进程，访问子任务的日志记录，获得Map/Reduce集群状态信息等功能。
        </p>
 
        <p>作业提交过程包括： </p>
        <ol>
          <li>检查作业输入输出样式细节</li>
          <li>为作业计算<code>InputSplit</code>值。</li>
          <li>
           如果需要的话，为作业的<code>DistributedCache</code>建立必须的统计信息。
          </li>
          <li>
            拷贝作业的jar包和配置文件到<code>FileSystem</code>上的Map/Reduce系统目录下。
          </li>
          <li>
            提交作业到<code>JobTracker</code>并且监控它的状态。
          </li>
        </ol>
        <p>作业的历史文件记录到指定目录的"_logs/history/"子目录下。这个指定目录由<code>hadoop.job.history.user.location</code>设定，默认是作业输出的目录。因此默认情况下，文件会存放在mapred.output.dir/_logs/history目录下。用户可以设置<code>hadoop.job.history.user.location</code>为<code>none</code>来停止日志记录。
        </p>

        <p> 用户使用下面的命令可以看到在指定目录下的历史日志记录的摘要。
        <br/>
        <code>$ bin/hadoop job -history output-dir</code><br/> 
        这个命令会打印出作业的细节，以及失败的和被杀死的任务细节。<br/>
        要查看有关作业的更多细节例如成功的任务、每个任务尝试的次数（task attempt）等，可以使用下面的命令
        <br/>
       <code>$ bin/hadoop job -history all output-dir</code><br/></p> 
            
        <p>用户可以使用 
        <a href="ext:api/org/apache/hadoop/mapred/outputlogfilter">OutputLogFilter</a>
        从输出目录列表中筛选日志文件。</p>
        
        <p>一般情况，用户利用<code>JobConf</code>创建应用程序并配置作业属性，
        然后用
        <code>JobClient</code> 提交作业并监视它的进程。</p>

        <section>
          <title>作业的控制</title>
 
          <p>有时候，用一个单独的Map/Reduce作业并不能完成一个复杂的任务，用户也许要链接多个Map/Reduce作业才行。这是容易实现的，因为作业通常输出到分布式文件系统上的，所以可以把这个作业的输出作为下一个作业的输入实现串联。
          </p>
 
          <p>然而，这也意味着，确保每一作业完成(成功或失败)的责任就直接落在了客户身上。在这种情况下，可以用的控制作业的选项有：
          </p>
          <ul>
            <li>
              <a href="ext:api/org/apache/hadoop/mapred/jobclient/runjob">
              runJob(JobConf)</a>：提交作业，仅当作业完成时返回。
            </li>
            <li>
              <a href="ext:api/org/apache/hadoop/mapred/jobclient/submitjob">
              submitJob(JobConf)</a>：只提交作业，之后需要你轮询它返回的
              <a href="ext:api/org/apache/hadoop/mapred/runningjob">
              RunningJob</a>句柄的状态，并根据情况调度。
            </li>
            <li>
              <a href="ext:api/org/apache/hadoop/mapred/jobconf/setjobendnotificationuri">
              JobConf.setJobEndNotificationURI(String)</a>：设置一个作业完成通知，可避免轮询。
           
            </li>
          </ul>
        </section>
      </section>

      <section>
        <title>作业的输入</title>
        
        <p><a href="ext:api/org/apache/hadoop/mapred/inputformat">
        InputFormat</a> 为Map/Reduce作业描述输入的细节规范。
        </p> 
 
        <p>Map/Reduce框架根据作业的<code>InputFormat</code>来： 
        </p>
        <ol>
          <li>检查作业输入的有效性。</li>
          <li>
            把输入文件切分成多个逻辑<code>InputSplit</code>实例，
            并把每一实例分别分发给一个
            <code>Mapper</code>。
          </li>
          <li>
            提供<code>RecordReader</code>的实现，这个RecordReader从逻辑<code>InputSplit</code>中获得输入记录，
		这些记录将由<code>Mapper</code>处理。 
          </li>
        </ol>
 
        <p>基于文件的<code>InputFormat</code>实现（通常是
	<a href="ext:api/org/apache/hadoop/mapred/fileinputformat">
        FileInputFormat</a>的子类）
	默认行为是按照输入文件的字节大小，把输入数据切分成逻辑分块（<em>logical</em> 
        <code>InputSplit</code> ）。	
        其中输入文件所在的<code>FileSystem</code>的数据块尺寸是分块大小的上限。下限可以设置<code>mapred.min.split.size</code>
	的值。</p>
 
        <p>考虑到边界情况，对于很多应用程序来说，很明显按照文件大小进行逻辑分割是不能满足需求的。
        在这种情况下，应用程序需要实现一个<code>RecordReader</code>来处理记录的边界并为每个任务提供一个逻辑分块的面向记录的视图。
        </p>

        <p><a href="ext:api/org/apache/hadoop/mapred/textinputformat">
        TextInputFormat</a> 是默认的<code>InputFormat</code>。</p>
        
        <p>如果一个作业的<code>Inputformat</code>是<code>TextInputFormat</code>，
        并且框架检测到输入文件的后缀是<em>.gz</em>和<em>.lzo</em>，就会使用对应的<code>CompressionCodec</code>自动解压缩这些文件。
        但是需要注意，上述带后缀的压缩文件不会被切分，并且整个压缩文件会分给一个mapper来处理。
        </p>
        
        <section>
          <title>InputSplit</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/inputsplit">
          InputSplit</a> 是一个单独的<code>Mapper</code>要处理的数据块。</p>

          <p>一般的<code>InputSplit</code> 是字节样式输入，然后由<code>RecordReader</code>处理并转化成记录样式。
          </p>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/filesplit">
			  FileSplit</a> 是默认的<code>InputSplit</code>。 它把
          <code>map.input.file</code> 设定为输入文件的路径，输入文件是逻辑分块文件。
          </p>
        </section>
        
        <section>
          <title>RecordReader</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/recordreader">
          RecordReader</a> 从<code>InputSlit</code>读入<code>&lt;key, value&gt;</code>对。 
          </p>

          <p>一般的，<code>RecordReader</code> 把由<code>InputSplit</code>
	  提供的字节样式的输入文件，转化成由<code>Mapper</code>处理的记录样式的文件。
          因此<code>RecordReader</code>负责处理记录的边界情况和把数据表示成keys/values对形式。
          </p>
        </section>
      </section>

      <section>
        <title>作业的输出</title>
        
        <p><a href="ext:api/org/apache/hadoop/mapred/outputformat">
        OutputFormat</a> 描述Map/Reduce作业的输出样式。
        </p>

        <p>Map/Reduce框架根据作业的<code>OutputFormat</code>来：
        </p>
        <ol>
          <li>
            检验作业的输出，例如检查输出路径是否已经存在。
          </li>
          <li>
            提供一个<code>RecordWriter</code>的实现，用来输出作业结果。
            输出文件保存在<code>FileSystem</code>上。
          </li>
        </ol>
 
        <p><code>TextOutputFormat</code>是默认的
        <code>OutputFormat</code>。</p>
 
        <section>
          <title>任务的Side-Effect File</title>
 
          <p>在一些应用程序中，子任务需要产生一些side-file，这些文件与作业实际输出结果的文件不同。
          </p>
 
	  <p>在这种情况下，同一个<code>Mapper</code>或者<code>Reducer</code>的两个实例（比如预防性任务）同时打开或者写
	  <code>FileSystem</code>上的同一文件就会产生冲突。因此应用程序在写文件的时候需要为每次任务尝试（不仅仅是每次任务，每个任务可以尝试执行很多次）选取一个独一无二的文件名(使用attemptid，例如<code>task_200709221812_0001_m_000000_0</code>)。 
          </p> 
 
          <p>为了避免冲突，Map/Reduce框架为每次尝试执行任务都建立和维护一个特殊的
          <code>${mapred.output.dir}/_temporary/_${taskid}</code>子目录，这个目录位于本次尝试执行任务输出结果所在的<code>FileSystem</code>上，可以通过
          <code>${mapred.work.output.dir}</code>来访问这个子目录。
          对于成功完成的任务尝试，只有<code>${mapred.output.dir}/_temporary/_${taskid}</code>下的文件会<em>移动</em>到<code>${mapred.output.dir}</code>。当然，框架会丢弃那些失败的任务尝试的子目录。这种处理过程对于应用程序来说是完全透明的。</p>
 
          <p>在任务执行期间，应用程序在写文件时可以利用这个特性，比如
	  通过<a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/getworkoutputpath">
          FileOutputFormat.getWorkOutputPath()</a>获得<code>${mapred.work.output.dir}</code>目录，
	  并在其下创建任意任务执行时所需的side-file，框架在任务尝试成功时会马上移动这些文件，因此不需要在程序内为每次任务尝试选取一个独一无二的名字。
          </p>
          
          <p>注意：在每次任务尝试执行期间，<code>${mapred.work.output.dir}</code> 的值实际上是
          <code>${mapred.output.dir}/_temporary/_{$taskid}</code>，这个值是Map/Reduce框架创建的。
          所以使用这个特性的方法是，在<a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/getworkoutputpath">
          FileOutputFormat.getWorkOutputPath() </a>
	  路径下创建side-file即可。
	  </p>
          
          <p>对于只使用map不使用reduce的作业，这个结论也成立。这种情况下，map的输出结果直接生成到HDFS上。
           </p> 
        </section>
        
        <section>
          <title>RecordWriter</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/recordwriter">
          RecordWriter</a> 生成<code>&lt;key, value&gt;</code> 
          对到输出文件。</p>

          <p>RecordWriter的实现把作业的输出结果写到
          <code>FileSystem</code>。</p>
        </section>
      </section>
      
      <section>
        <title>其他有用的特性</title>
 
        <section>
          <title>Counters</title>
          
          <p><code>Counters</code> 是多个由Map/Reduce框架或者应用程序定义的全局计数器。
          每一个<code>Counter</code>可以是任何一种 
          <code>Enum</code>类型。同一特定<code>Enum</code>类型的Counter可以汇集到一个组，其类型为<code>Counters.Group</code>。</p>
          
          <p>应用程序可以定义任意(Enum类型)的<code>Counters</code>并且可以通过 <code>map</code> 或者 
          <code>reduce</code>方法中的
          <a href="ext:api/org/apache/hadoop/mapred/reporter/incrcounterEnum">
          Reporter.incrCounter(Enum, long)</a>或者 
          <a href="ext:api/org/apache/hadoop/mapred/reporter/incrcounterString">
          Reporter.incrCounter(String, String, long)</a>
          更新。之后框架会汇总这些全局counters。 
          </p>
        </section>       
        
        <section>
          <title>DistributedCache</title>
          
          <p><a href="ext:api/org/apache/hadoop/filecache/distributedcache">
          DistributedCache</a> 可将具体应用相关的、大尺寸的、只读的文件有效地分布放置。
          </p>
 
          <p><code>DistributedCache</code> 是Map/Reduce框架提供的功能，能够缓存应用程序所需的文件
		（包括文本，档案文件，jar文件等）。
          </p>
          <p>应用程序在<code>JobConf</code>中通过url(hdfs://)指定需要被缓存的文件。
	  <code>DistributedCache</code>假定由hdfs://格式url指定的文件已经在 
          <code>FileSystem</code>上了。</p>

          <p>Map-Redcue框架在作业所有任务执行之前会把必要的文件拷贝到slave节点上。
          它运行高效是因为每个作业的文件只拷贝一次并且为那些没有文档的slave节点缓存文档。      
          </p> 
          
          <p><code>DistributedCache</code> 根据缓存文档修改的时间戳进行追踪。
	  在作业执行期间，当前应用程序或者外部程序不能修改缓存文件。 
          </p>

          <p><code>distributedCache</code>可以分发简单的只读数据或文本文件，也可以分发复杂类型的文件例如归档文件和jar文件。归档文件(zip,tar,tgz和tar.gz文件)在slave节点上会被<em>解档（un-archived）</em>。
          这些文件可以设置<em>执行权限</em>。</p>
          <p>用户可以通过设置<code>mapred.cache.{files|archives}</code>来分发文件。
          如果要分发多个文件，可以使用逗号分隔文件所在路径。也可以利用API来设置该属性：
            <a href="ext:api/org/apache/hadoop/filecache/distributedcache/addcachefile">
          DistributedCache.addCacheFile(URI,conf)</a>/
          <a href="ext:api/org/apache/hadoop/filecache/distributedcache/addcachearchive">
          DistributedCache.addCacheArchive(URI,conf)</a> and
          <a href="ext:api/org/apache/hadoop/filecache/distributedcache/setcachefiles">
          DistributedCache.setCacheFiles(URIs,conf)</a>/
          <a href="ext:api/org/apache/hadoop/filecache/distributedcache/setcachearchives">
          DistributedCache.setCacheArchives(URIs,conf)</a>
          其中URI的形式是
          <code>hdfs://host:port/absolute-path#link-name</code>
          在Streaming程序中，可以通过命令行选项
          <code>-cacheFile/-cacheArchive</code>
          分发文件。</p>
          <p>
	  用户可以通过<a href="ext:api/org/apache/hadoop/filecache/distributedcache/createsymlink">
          DistributedCache.createSymlink(Configuration)</a>方法让<code>DistributedCache</code>
        在<em>当前工作目录</em>下创建到缓存文件的符号链接。
	或者通过设置配置文件属性<code>mapred.create.symlink</code>为<code>yes</code>。
	分布式缓存会截取URI的片段作为链接的名字。
	例如，URI是 <code>hdfs://namenode:port/lib.so.1#lib.so</code>，
	则在task当前工作目录会有名为<code>lib.so</code>的链接，
        它会链接分布式缓存中的<code>lib.so.1</code>。
        </p>

	<p><code>DistributedCache</code>可在map/reduce任务中作为
        一种基础软件分发机制使用。它可以被用于分发jar包和本地库（native libraries）。
        <a href="ext:api/org/apache/hadoop/filecache/distributedcache/addarchivetoclasspath">
        DistributedCache.addArchiveToClassPath(Path, Configuration)</a>和
        <a href="ext:api/org/apache/hadoop/filecache/distributedcache/addfiletoclasspath">
        DistributedCache.addFileToClassPath(Path, Configuration)</a> API能够被用于
        缓存文件和jar包，并把它们加入子jvm的<em>classpath</em>。也可以通过设置配置文档里的属性
        <code>mapred.job.classpath.{files|archives}</code>达到相同的效果。缓存文件可用于分发和装载本地库。
        </p>
        </section>
        
        <section>
          <title>Tool</title>
          
          <p><a href="ext:api/org/apache/hadoop/util/tool">Tool</a> 
          接口支持处理常用的Hadoop命令行选项。
          </p>
          
          <p><code>Tool</code> 是Map/Reduce工具或应用的标准。应用程序应只处理其定制参数，
          要把标准命令行选项通过
		<a href="ext:api/org/apache/hadoop/util/toolrunner/run"> ToolRunner.run(Tool, String[])</a> 
		委托给
          <a href="ext:api/org/apache/hadoop/util/genericoptionsparser">
          GenericOptionsParser</a>处理。
          </p>
          
          <p>
            Hadoop命令行的常用选项有：<br/>
            <code>
              -conf &lt;configuration file&gt;
            </code>
            <br/>
            <code>
              -D &lt;property=value&gt;
            </code>
            <br/>
            <code>
              -fs &lt;local|namenode:port&gt;
            </code>
            <br/>
            <code>
              -jt &lt;local|jobtracker:port&gt;
            </code>
          </p>
        </section>
        
        <section>
          <title>IsolationRunner</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/isolationrunner">
          IsolationRunner</a> 是帮助调试Map/Reduce程序的工具。</p>
          
          <p>使用<code>IsolationRunner</code>的方法是，首先设置
          <code>keep.failed.tasks.files</code>属性为<code>true</code> 
          （同时参考<code>keep.tasks.files.pattern</code>）。</p>
          
          <p>
            然后，登录到任务运行失败的节点上，进入
            <code>TaskTracker</code>的本地路径运行
            <code>IsolationRunner</code>：<br/>
            <code>$ cd &lt;local path&gt;/taskTracker/${taskid}/work</code><br/>
            <code>
              $ bin/hadoop org.apache.hadoop.mapred.IsolationRunner ../job.xml
            </code>
          </p>
          
          <p><code>IsolationRunner</code>会把失败的任务放在单独的一个能够调试的jvm上运行，并且采用和之前完全一样的输入数据。
		</p>
        </section>

         <section>
           <title>Profiling</title>
	   <p>Profiling是一个工具，它使用内置的java profiler工具进行分析获得(2-3个)map或reduce样例运行分析报告。</p>
          <p>用户可以通过设置属性<code>mapred.task.profile</code>指定系统是否采集profiler信息。
          利用api<a href="ext:api/org/apache/hadoop/mapred/jobconf/setprofileenabled">
          JobConf.setProfileEnabled(boolean)可以修改属性值</a>。如果设为<code>true</code>，
          则开启profiling功能。profiler信息保存在用户日志目录下。缺省情况，profiling功能是关闭的。</p>
          <p>如果用户设定使用profiling功能，可以使用配置文档里的属性
          <code>mapred.task.profile.{maps|reduces}</code>
          设置要profile map/reduce task的范围。设置该属性值的api是
           <a href="ext:api/org/apache/hadoop/mapred/jobconf/setprofiletaskrange">
          JobConf.setProfileTaskRange(boolean,String)</a>。
          范围的缺省值是<code>0-2</code>。</p>
          <p>用户可以通过设定配置文档里的属性<code>mapred.task.profile.params</code>
          来指定profiler配置参数。修改属性要使用api
          <a href="ext:api/org/apache/hadoop/mapred/jobconf/setprofileparams">
          JobConf.setProfileParams(String)</a>。当运行task时，如果字符串包含<code>%s</code>。
          它会被替换成profileing的输出文件名。这些参数会在命令行里传递到子JVM中。缺省的profiling
          参数是
          <code>-agentlib:hprof=cpu=samples,heap=sites,force=n,thread=y,verbose=n,file=%s</code>。
          </p>
	 </section>
        
        <section>
          <title>调试</title>
          <p>Map/Reduce框架能够运行用户提供的用于调试的脚本程序。 
          当map/reduce任务失败时，用户可以通过运行脚本在任务日志（例如任务的标准输出、标准错误、系统日志以及作业配置文件）上做后续处理工作。用户提供的调试脚本程序的标准输出和标准错误会输出为诊断文件。如果需要的话这些输出结果也可以打印在用户界面上。</p>

          <p> 在接下来的章节，我们讨论如何与作业一起提交调试脚本。为了提交调试脚本，
          首先要把这个脚本分发出去，而且还要在配置文件里设置。
     	  </p>
          <section>
          <title> 如何分发脚本文件：</title>
          <p>用户要用
          <a href="mapred_tutorial.html#DistributedCache">DistributedCache</a>
          机制来<em>分发</em>和<em>链接</em>脚本文件</p>
         </section>
          <section>
          <title> 如何提交脚本：</title>
          <p> 一个快速提交调试脚本的方法是分别为需要调试的map任务和reduce任务设置
		"mapred.map.task.debug.script" 和 "mapred.reduce.task.debug.script"
	 属性的值。这些属性也可以通过
          <a href="ext:api/org/apache/hadoop/mapred/jobconf/setmapdebugscript">
          JobConf.setMapDebugScript(String) </a>和 
          <a href="ext:api/org/apache/hadoop/mapred/jobconf/setreducedebugscript">
          JobConf.setReduceDebugScript(String) </a>API来设置。对于streaming，
          可以分别为需要调试的map任务和reduce任务使用命令行选项-mapdebug 和 -reducedegug来提交调试脚本。
          </p>
            
          <p>脚本的参数是任务的标准输出、标准错误、系统日志以及作业配置文件。在运行map/reduce失败的节点上运行调试命令是：
		 <br/>
          <code> $script $stdout $stderr $syslog $jobconf </code> </p> 

          <p> Pipes 程序根据第五个参数获得c++程序名。
          因此调试pipes程序的命令是<br/> 
          <code>$script $stdout $stderr $syslog $jobconf $program </code>  
          </p>
          </section>
          
          <section>
          <title> 默认行为 </title>
          <p> 对于pipes，默认的脚本会用gdb处理core dump，
          打印 stack trace并且给出正在运行线程的信息。</p>
          </section>
        </section>
        
        <section>
          <title>JobControl</title>
          
          <p><a href="ext:api/org/apache/hadoop/mapred/jobcontrol/package-summary">
          JobControl</a>是一个工具，它封装了一组Map/Reduce作业以及他们之间的依赖关系。
	  </p>
        </section>
        
        <section>
          <title>数据压缩</title>
          
          <p>Hadoop Map/Reduce框架为应用程序的写入文件操作提供压缩工具，这些工具可以为map输出的中间数据和作业最终输出数据（例如reduce的输出）提供支持。它还附带了一些
          <a href="ext:api/org/apache/hadoop/io/compress/compressioncodec">
          CompressionCodec</a>的实现，比如实现了
          <a href="ext:zlib">zlib</a>和<a href="ext:lzo">lzo</a>压缩算法。
           Hadoop同样支持<a href="ext:gzip">gzip</a>文件格式。 
          </p>
          
          <p>考虑到性能问题（zlib）以及Java类库的缺失（lzo）等因素，Hadoop也为上述压缩解压算法提供本地库的实现。更多的细节请参考
          <a href="native_libraries.html">这里</a>。</p>
          
          <section>
            <title>中间输出</title>
            
            <p>应用程序可以通过
            <a href="ext:api/org/apache/hadoop/mapred/jobconf/setcompressmapoutput">
            JobConf.setCompressMapOutput(boolean)</a>api控制map输出的中间结果，并且可以通过
            <a href="ext:api/org/apache/hadoop/mapred/jobconf/setmapoutputcompressorclass">
            JobConf.setMapOutputCompressorClass(Class)</a>api指定
            <code>CompressionCodec</code>。
        </p>
       </section>
          
          <section>
            <title>作业输出</title>   
            <p>应用程序可以通过
            <a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/setcompressoutput">
            FileOutputFormat.setCompressOutput(JobConf, boolean)</a>
            api控制输出是否需要压缩并且可以使用 
            <a href="ext:api/org/apache/hadoop/mapred/fileoutputformat/setoutputcompressorclass">
            FileOutputFormat.setOutputCompressorClass(JobConf, Class)</a>api指定<code>CompressionCodec</code>。</p> 
            
            <p>如果作业输出要保存成 
            <a href="ext:api/org/apache/hadoop/mapred/sequencefileoutputformat">
            SequenceFileOutputFormat</a>格式，需要使用
            <a href="ext:api/org/apache/hadoop/mapred/sequencefileoutputformat/setoutputcompressiontype">
            SequenceFileOutputFormat.setOutputCompressionType(JobConf, 
            SequenceFile.CompressionType)</a>api，来设定
            <code>SequenceFile.CompressionType</code> (i.e. <code>RECORD</code> / 
            <code>BLOCK</code> - 默认是<code>RECORD</code>)。
            </p>
          </section>
        </section>
        
      </section>
    </section>

    <section>
      <title>例子：WordCount v2.0</title>
      
      <p>这里是一个更全面的<code>WordCount</code>例子，它使用了我们已经讨论过的很多Map/Reduce框架提供的功能。 
      </p>
      
      <p>运行这个例子需要HDFS的某些功能，特别是
      <code>DistributedCache</code>相关功能。因此这个例子只能运行在
      <a href="quickstart.html#SingleNodeSetup">伪分布式</a> 或者
      <a href="quickstart.html#Fully-Distributed+Operation">完全分布式模式</a>的 
      Hadoop上。</p>      
      
       <section>
        <title>源代码</title>
        
        <table>
          <tr>
            <th></th>
            <th>WordCount.java</th>
          </tr>
          <tr>
            <td>1.</td>
            <td>
              <code>package org.myorg;</code>
            </td>
          </tr>
          <tr>
            <td>2.</td>
            <td></td>
          </tr>
          <tr>
            <td>3.</td>
            <td>
              <code>import java.io.*;</code>
            </td>
          </tr>
          <tr>
            <td>4.</td>
            <td>
              <code>import java.util.*;</code>
            </td>
          </tr>
          <tr>
            <td>5.</td>
            <td></td>
          </tr>
          <tr>
            <td>6.</td>
            <td>
              <code>import org.apache.hadoop.fs.Path;</code>
            </td>
          </tr>
          <tr>
            <td>7.</td>
            <td>
              <code>import org.apache.hadoop.filecache.DistributedCache;</code>
            </td>
          </tr>
          <tr>
            <td>8.</td>
            <td>
              <code>import org.apache.hadoop.conf.*;</code>
            </td>
          </tr>
          <tr>
            <td>9.</td>
            <td>
              <code>import org.apache.hadoop.io.*;</code>
            </td>
          </tr>
          <tr>
            <td>10.</td>
            <td>
              <code>import org.apache.hadoop.mapred.*;</code>
            </td>
          </tr>
          <tr>
            <td>11.</td>
            <td>
              <code>import org.apache.hadoop.util.*;</code>
            </td>
          </tr>
          <tr>
            <td>12.</td>
            <td></td>
          </tr>
          <tr>
            <td>13.</td>
            <td>
              <code>public class WordCount extends Configured implements Tool {</code>
            </td>
          </tr>
          <tr>
            <td>14.</td>
            <td></td>
          </tr>
          <tr>
            <td>15.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static class Map extends MapReduceBase 
                implements Mapper&lt;LongWritable, Text, Text, IntWritable&gt; {
              </code>
            </td>
          </tr>
          <tr>
            <td>16.</td>
            <td></td>
          </tr>
          <tr>
            <td>17.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                static enum Counters { INPUT_WORDS }
              </code>
            </td>
          </tr>
          <tr>
            <td>18.</td>
            <td></td>
          </tr>
          <tr>
            <td>19.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                private final static IntWritable one = new IntWritable(1);
              </code>
            </td>
          </tr>
          <tr>
            <td>20.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private Text word = new Text();</code>
            </td>
          </tr>
          <tr>
            <td>21.</td>
            <td></td>
          </tr>
          <tr>
            <td>22.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private boolean caseSensitive = true;</code>
            </td>
          </tr>
          <tr>
            <td>23.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private Set&lt;String&gt; patternsToSkip = new HashSet&lt;String&gt;();</code>
            </td>
          </tr>
          <tr>
            <td>24.</td>
            <td></td>
          </tr>
          <tr>
            <td>25.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private long numRecords = 0;</code>
            </td>
          </tr>
          <tr>
            <td>26.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private String inputFile;</code>
            </td>
          </tr>
          <tr>
            <td>27.</td>
            <td></td>
          </tr>
          <tr>
            <td>28.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>public void configure(JobConf job) {</code>
            </td>
          </tr>
          <tr>
            <td>29.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                caseSensitive = job.getBoolean("wordcount.case.sensitive", true);
              </code>
            </td>
          </tr>
          <tr>
            <td>30.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>inputFile = job.get("map.input.file");</code>
            </td>
          </tr>
          <tr>
            <td>31.</td>
            <td></td>
          </tr>
          <tr>
            <td>32.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>if (job.getBoolean("wordcount.skip.patterns", false)) {</code>
            </td>
          </tr>
          <tr>
            <td>33.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>Path[] patternsFiles = new Path[0];</code>
            </td>
          </tr>
          <tr>
            <td>34.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>try {</code>
            </td>
          </tr>
          <tr>
            <td>35.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                patternsFiles = DistributedCache.getLocalCacheFiles(job);
              </code>
            </td>
          </tr>
          <tr>
            <td>36.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>} catch (IOException ioe) {</code>
            </td>
          </tr>
          <tr>
            <td>37.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                System.err.println("Caught exception while getting cached files: " 
                + StringUtils.stringifyException(ioe));
              </code>
            </td>
          </tr>
          <tr>
            <td>38.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>39.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>for (Path patternsFile : patternsFiles) {</code>
            </td>
          </tr>
          <tr>
            <td>40.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>parseSkipFile(patternsFile);</code>
            </td>
          </tr>
          <tr>
            <td>41.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>42.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>43.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>44.</td>
            <td></td>
          </tr>
          <tr>
            <td>45.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>private void parseSkipFile(Path patternsFile) {</code>
            </td>
          </tr>
          <tr>
            <td>46.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>try {</code>
            </td>
          </tr>
          <tr>
            <td>47.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                BufferedReader fis = 
                  new BufferedReader(new FileReader(patternsFile.toString()));
              </code>
            </td>
          </tr>
          <tr>
            <td>48.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>String pattern = null;</code>
            </td>
          </tr>
          <tr>
            <td>49.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>while ((pattern = fis.readLine()) != null) {</code>
            </td>
          </tr>
          <tr>
            <td>50.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>patternsToSkip.add(pattern);</code>
            </td>
          </tr>
          <tr>
            <td>51.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>52.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>} catch (IOException ioe) {</code>
            </td>
          </tr>
          <tr>
            <td>53.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                System.err.println("Caught exception while parsing the cached file '" +
                                   patternsFile + "' : " + 
                                   StringUtils.stringifyException(ioe));
                
              </code>
            </td>
          </tr>
          <tr>
            <td>54.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>55.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>56.</td>
            <td></td>
          </tr>
          <tr>
            <td>57.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                public void map(LongWritable key, Text value, 
                OutputCollector&lt;Text, IntWritable&gt; output, 
                Reporter reporter) throws IOException {
              </code>
            </td>
          </tr>
          <tr>
            <td>58.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                String line = 
                  (caseSensitive) ? value.toString() : 
                                    value.toString().toLowerCase();
              </code>
            </td>
          </tr>
          <tr>
            <td>59.</td>
            <td></td>
          </tr>
          <tr>
            <td>60.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>for (String pattern : patternsToSkip) {</code>
            </td>
          </tr>
          <tr>
            <td>61.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>line = line.replaceAll(pattern, "");</code>
            </td>
          </tr>
          <tr>
            <td>62.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>63.</td>
            <td></td>
          </tr>
          <tr>
            <td>64.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>StringTokenizer tokenizer = new StringTokenizer(line);</code>
            </td>
          </tr>
          <tr>
            <td>65.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>while (tokenizer.hasMoreTokens()) {</code>
            </td>
          </tr>
          <tr>
            <td>66.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>word.set(tokenizer.nextToken());</code>
            </td>
          </tr>
          <tr>
            <td>67.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>output.collect(word, one);</code>
            </td>
          </tr>
          <tr>
            <td>68.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>reporter.incrCounter(Counters.INPUT_WORDS, 1);</code>
            </td>
          </tr>
          <tr>
            <td>69.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>70.</td>
            <td></td>
          </tr>
          <tr>
            <td>71.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>if ((++numRecords % 100) == 0) {</code>
            </td>
          </tr>
          <tr>
            <td>72.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                reporter.setStatus("Finished processing " + numRecords + 
                                   " records " + "from the input file: " + 
                                   inputFile);
              </code>
            </td>
          </tr>
          <tr>
            <td>73.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>74.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>75.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>76.</td>
            <td></td>
          </tr>
          <tr>
            <td>77.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static class Reduce extends MapReduceBase implements 
                Reducer&lt;Text, IntWritable, Text, IntWritable&gt; {
              </code>
            </td>
          </tr>
          <tr>
            <td>78.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                public void reduce(Text key, Iterator&lt;IntWritable&gt; values,
                OutputCollector&lt;Text, IntWritable&gt; output, 
                Reporter reporter) throws IOException {
              </code>
            </td>
          </tr>
          <tr>
            <td>79.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>int sum = 0;</code>
            </td>
          </tr>
          <tr>
            <td>80.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>while (values.hasNext()) {</code>
            </td>
          </tr>
          <tr>
            <td>81.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>sum += values.next().get();</code>
            </td>
          </tr>
          <tr>
            <td>82.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>83.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>output.collect(key, new IntWritable(sum));</code>
            </td>
          </tr>
          <tr>
            <td>84.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>85.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>86.</td>
            <td></td>
          </tr>
          <tr>
            <td>87.</td>
            <td>
              &nbsp;&nbsp;
              <code>public int run(String[] args) throws Exception {</code>
            </td>
          </tr>
          <tr>
            <td>88.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                JobConf conf = new JobConf(getConf(), WordCount.class);
              </code>
            </td>
          </tr>
          <tr>
            <td>89.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setJobName("wordcount");</code>
            </td>
          </tr>
          <tr>
            <td>90.</td>
            <td></td>
          </tr>
          <tr>
            <td>91.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputKeyClass(Text.class);</code>
            </td>
          </tr>
          <tr>
            <td>92.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputValueClass(IntWritable.class);</code>
            </td>
          </tr>
          <tr>
            <td>93.</td>
            <td></td>
          </tr>
          <tr>
            <td>94.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setMapperClass(Map.class);</code>
            </td>
          </tr>
          <tr>
            <td>95.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setCombinerClass(Reduce.class);</code>
            </td>
          </tr>
          <tr>
            <td>96.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setReducerClass(Reduce.class);</code>
            </td>
          </tr>
          <tr>
            <td>97.</td>
            <td></td>
          </tr>
          <tr>
            <td>98.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setInputFormat(TextInputFormat.class);</code>
            </td>
          </tr>
          <tr>
            <td>99.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>conf.setOutputFormat(TextOutputFormat.class);</code>
            </td>
          </tr>
          <tr>
            <td>100.</td>
            <td></td>
          </tr>
          <tr>
            <td>101.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                List&lt;String&gt; other_args = new ArrayList&lt;String&gt;();
              </code>
            </td>
          </tr>
          <tr>
            <td>102.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>for (int i=0; i &lt; args.length; ++i) {</code>
            </td>
          </tr>
          <tr>
            <td>103.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>if ("-skip".equals(args[i])) {</code>
            </td>
          </tr>
          <tr>
            <td>104.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                DistributedCache.addCacheFile(new Path(args[++i]).toUri(), conf);
              </code>
            </td>
          </tr>
          <tr>
            <td>105.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                conf.setBoolean("wordcount.skip.patterns", true);
              </code>
            </td>
          </tr>
          <tr>
            <td>106.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>} else {</code>
            </td>
          </tr>
          <tr>
            <td>107.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>other_args.add(args[i]);</code>
            </td>
          </tr>
          <tr>
            <td>108.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>109.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>110.</td>
            <td></td>
          </tr>
          <tr>
            <td>111.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>FileInputFormat.setInputPaths(conf, new Path(other_args.get(0)));</code>
            </td>
          </tr>
          <tr>
            <td>112.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>FileOutputFormat.setOutputPath(conf, new Path(other_args.get(1)));</code>
            </td>
          </tr>
          <tr>
            <td>113.</td>
            <td></td>
          </tr>
          <tr>
            <td>114.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>JobClient.runJob(conf);</code>
            </td>
          </tr>
          <tr>
            <td>115.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>return 0;</code>
            </td>
          </tr>
          <tr>
            <td>116.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>117.</td>
            <td></td>
          </tr>
          <tr>
            <td>118.</td>
            <td>
              &nbsp;&nbsp;
              <code>
                public static void main(String[] args) throws Exception {
              </code>
            </td>
          </tr>
          <tr>
            <td>119.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>
                int res = ToolRunner.run(new Configuration(), new WordCount(), 
                                         args);
              </code>
            </td>
          </tr>
          <tr>
            <td>120.</td>
            <td>
              &nbsp;&nbsp;&nbsp;&nbsp;
              <code>System.exit(res);</code>
            </td>
          </tr>
          <tr>
            <td>121.</td>
            <td>
              &nbsp;&nbsp;
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>122.</td>
            <td>
              <code>}</code>
            </td>
          </tr>
          <tr>
            <td>123.</td>
            <td></td>
          </tr>
        </table>
      </section>
        
      <section>
        <title>运行样例</title>
        
        <p>输入样例：</p>
        <p>
          <code>$ bin/hadoop dfs -ls /usr/joe/wordcount/input/</code><br/>
          <code>/usr/joe/wordcount/input/file01</code><br/>
          <code>/usr/joe/wordcount/input/file02</code><br/>
          <br/>
          <code>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file01</code><br/>
          <code>Hello World, Bye World!</code><br/>
          <br/>
          <code>$ bin/hadoop dfs -cat /usr/joe/wordcount/input/file02</code><br/>
          <code>Hello Hadoop, Goodbye to hadoop.</code>
        </p>
        
        <p>运行程序：</p>
        <p>
          <code>
            $ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount 
              /usr/joe/wordcount/input /usr/joe/wordcount/output 
          </code>
        </p>

        <p>输出：</p>
        <p>
          <code>
            $ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000
          </code>
          <br/>
          <code>Bye    1</code><br/>
          <code>Goodbye    1</code><br/>
          <code>Hadoop,    1</code><br/>
          <code>Hello    2</code><br/>
          <code>World!    1</code><br/>
          <code>World,    1</code><br/>
          <code>hadoop.    1</code><br/>
          <code>to    1</code><br/>
        </p>
        
        <p>注意此时的输入与第一个版本的不同，输出的结果也有不同。
	</p>

        <p>现在通过<code>DistributedCache</code>插入一个模式文件，文件中保存了要被忽略的单词模式。
	</p>
        
        <p>
          <code>$ hadoop dfs -cat /user/joe/wordcount/patterns.txt</code><br/>
          <code>\.</code><br/>
          <code>\,</code><br/>
          <code>\!</code><br/>
          <code>to</code><br/>
        </p>
        
        <p>再运行一次，这次使用更多的选项：</p>
        <p>
          <code>
            $ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount 
              -Dwordcount.case.sensitive=true /usr/joe/wordcount/input 
              /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt
          </code>
        </p>
        
        <p>应该得到这样的输出：</p>
        <p>
          <code>
            $ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000
          </code>
          <br/>
          <code>Bye    1</code><br/>
          <code>Goodbye    1</code><br/>
          <code>Hadoop    1</code><br/>
          <code>Hello    2</code><br/>
          <code>World    2</code><br/>
          <code>hadoop    1</code><br/>
        </p>
        
        <p>再运行一次，这一次关闭大小写敏感性（case-sensitivity）：</p>
        <p>
          <code>
            $ bin/hadoop jar /usr/joe/wordcount.jar org.myorg.WordCount 
              -Dwordcount.case.sensitive=false /usr/joe/wordcount/input 
              /usr/joe/wordcount/output -skip /user/joe/wordcount/patterns.txt
          </code>
        </p>
        
        <p>输出：</p>
        <p>
          <code>
            $ bin/hadoop dfs -cat /usr/joe/wordcount/output/part-00000
          </code>
          <br/>
          <code>bye    1</code><br/>
          <code>goodbye    1</code><br/>
          <code>hadoop    2</code><br/>
          <code>hello    2</code><br/>
          <code>world    2</code><br/>
        </p>
      </section>
      
      <section>
        <title>程序要点</title>
        
        <p>
	通过使用一些Map/Reduce框架提供的功能，<code>WordCount</code>的第二个版本在原始版本基础上有了如下的改进：
        </p>
        <ul>
          <li>
            展示了应用程序如何在<code>Mapper</code> (和<code>Reducer</code>)中通过<code>configure</code>方法
		修改配置参数(28-43行)。
          </li>
          <li>
            展示了作业如何使用<code>DistributedCache</code> 来分发只读数据。
	这里允许用户指定单词的模式，在计数时忽略那些符合模式的单词(104行)。
          </li>
          <li>
        展示<code>Tool</code>接口和<code>GenericOptionsParser</code>处理Hadoop命令行选项的功能
            (87-116, 119行)。
          </li>
          <li>
	展示了应用程序如何使用<code>Counters</code>(68行)，如何通过传递给<code>map</code>（和<code>reduce</code>）
	方法的<code>Reporter</code>实例来设置应用程序的状态信息(72行)。
          </li>
        </ul>
        
      </section>
    </section>

    <p>
      <em>Java和JNI是Sun Microsystems, Inc.在美国和其它国家的注册商标。</em>
    </p>
    
  </body>
  
</document>
